<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","constraint.rs"],"content":"/*\n * src/agent/configs/constraint.rs\n *\n * File for Constraint Agent Configuration\n *\n * Purpose:\n *   Store Constraint Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIConfig, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse crate::agent::tools::constraint::*;\nuse sqlx::PgPool;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_constraint_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Get tools - pass LLM as Arc\u003cdyn LLM\u003e and database pool\n\tlet llm_arc: Arc\u003cdyn langchain_rust::language_models::llm::LLM + Send + Sync\u003e =\n\t\tArc::new(llm.clone());\n\tlet tools = constraint_tools(llm_arc, pool);\n\n\t// Create agent with system prompt and tools\n\tconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/constraint.md\");\n\tlet system_prompt = SYSTEM_PROMPT.to_string();\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Limit to 3 iterations - agent should: 1) call tool, 2) get result, 3) return final answer\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_constraint_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Get tools - pass LLM as Arc\u003cdyn LLM\u003e and database pool\n\tlet llm_arc: Arc\u003cdyn langchain_rust::language_models::llm::LLM + Send + Sync\u003e =\n\t\tArc::new(llm.clone());\n\tlet tools = constraint_tools(llm_arc, pool);\n\n\t// Create agent with system prompt and tools\n\tconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/constraint.md\");\n\tlet system_prompt = SYSTEM_PROMPT.to_string();\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","example.rs"],"content":"/*\n * src/agent/config.rs\n *\n * File for Agent Configuration\n *\n * Purpose:\n *   Store Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n\t//tools:: \u003c- Some tools can be gotten from here\n};\n\nuse crate::agent::tools::GreetingTool;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Get tools\n\tlet greeting_tool = GreetingTool;\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Create agent with system prompt and tools\n\tlet system_prompt = format!(\n\t\t\"You are a helpful AI assistant for planning travel itineraries. \\\n\t\tYou help users create and manage their trip plans with a friendly and professional demeanor. \\\n\t\tAlways be concise, clear, and focus on providing practical travel planning advice. \\\n\t\t\\\n\t\tUser Info: \\\n\t\tName: {} \\\n\t\tLocation: {} \\\n\t\tPreferences: {} \\\n\t\tBudget: {} \\\n\t\tTravel Dates: {} \\\n\t\tTravel Type: {} \\\n\t\tTravel Style: {} \\\n\t\tTravel Budget: {} \\\n\t\",\n\t\t\"christian\",\n\t\t\"Philadelphia\",\n\t\t\"Adventurous\",\n\t\t\"Cheap\",\n\t\t\"August 1st - August 8th\",\n\t\t\"Vacation\",\n\t\t\"Adventurous\",\n\t\t\"Cheap\"\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026[Arc::new(greeting_tool)])\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Get tools\n\tlet greeting_tool = GreetingTool;\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Create agent with system prompt and tools\n\tlet system_prompt = \"You are a helpful AI assistant for planning travel itineraries.\";\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026[Arc::new(greeting_tool)])\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","mock.rs"],"content":"/*\n * src/agent/configs/mock.rs\n *\n * Mock LLM implementation for testing\n */\n\nuse async_trait::async_trait;\nuse futures::stream::{self, Stream};\nuse langchain_rust::language_models::GenerateResult;\nuse langchain_rust::language_models::LLMError;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::schemas::{Message, StreamData};\nuse serde_json::Value;\nuse std::pin::Pin;\n\n/// Mock LLM implementation for testing that returns dummy responses\n/// without making actual API calls\n#[derive(Clone)]\npub struct MockLLM;\n\n#[async_trait]\nimpl LLM for MockLLM {\n\tasync fn generate(\u0026self, _messages: \u0026[Message]) -\u003e Result\u003cGenerateResult, LLMError\u003e {\n\t\tOk(GenerateResult {\n\t\t\tgeneration: \"This is a mock response for testing.\".to_string(),\n\t\t\ttokens: None,\n\t\t})\n\t}\n\n\tasync fn stream(\n\t\t\u0026self,\n\t\t_messages: \u0026[Message],\n\t) -\u003e Result\u003cPin\u003cBox\u003cdyn Stream\u003cItem = Result\u003cStreamData, LLMError\u003e\u003e + Send\u003e\u003e, LLMError\u003e {\n\t\tlet response = StreamData::new(\n\t\t\tValue::String(\"This is a mock response for testing.\".to_string()),\n\t\t\tNone,\n\t\t\t\"This is a mock response for testing.\",\n\t\t);\n\t\tlet stream = stream::once(async move { Ok(response) });\n\t\tOk(Box::pin(stream))\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","mod.rs"],"content":"pub mod constraint;\npub mod mock;\npub mod optimizer;\npub mod orchestrator;\npub mod research;\npub mod task;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","optimizer.rs"],"content":"/*\n * src/agent/configs/optimizer.rs\n *\n * File for Optimizer Agent Configuration\n *\n * Purpose:\n *   Store Optimizer Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIConfig, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse crate::agent::tools::optimizer::optimizer_tools;\n\nuse sqlx::PgPool;\n\nconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/optimize.md\");\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_optimize_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tdb: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet agent_llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Create agent\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026optimizer_tools(Arc::new(llm), db))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(agent_llm)\n\t\t.unwrap();\n\n\t// Limit to 3 iterations - agent should: 1) call tool, 2) get result, 3) return final answer\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_optimize_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tdb: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet agent_llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Create agent\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026optimizer_tools(Arc::new(llm), db))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(agent_llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","orchestrator.rs"],"content":"/*\n * src/agent/configs/orchestrator.rs\n *\n * File for Orchestrator Agent Configuration\n */\n\nuse std::sync::Arc;\nuse std::sync::atomic::AtomicI32;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::configs::constraint::create_constraint_agent;\nuse crate::agent::configs::mock::MockLLM;\nuse crate::agent::configs::optimizer::create_optimize_agent;\nuse crate::agent::configs::research::create_research_agent;\nuse crate::agent::configs::task::create_task_agent;\nuse crate::agent::models::context::SharedContextStore;\nuse crate::agent::tools::orchestrator::get_orchestrator_tools;\nuse langchain_rust::language_models::llm::LLM;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_orchestrator_agent(\n\tpool: PgPool,\n) -\u003e Result\u003c\n\t(\n\t\tAgentExecutor\u003cConversationalAgent\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tSharedContextStore,\n\t),\n\tAgentError,\n\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Create a shared LLM instance for the orchestrator and its tools\n\t// Use MockLLM if DEPLOY_LLM != \"1\", otherwise use OpenAI\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tlet llm_for_subagents = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\tlet llm_for_tools: Arc\u003cdyn LLM + Send + Sync\u003e = if use_mock {\n\t\tArc::new(MockLLM)\n\t} else {\n\t\tArc::new(llm_for_subagents.clone())\n\t};\n\n\t// Create memory for conversation history\n\tlet memory = SimpleMemory::new();\n\n\t// Create shared atomics for chat_session_id and user_id (will be set per request)\n\tlet chat_session_id = Arc::new(AtomicI32::new(0));\n\tlet user_id = Arc::new(AtomicI32::new(0));\n\n\t// In-memory context store shared by orchestrator + sub-agents\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\t// Create research agent\n\tlet research_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_research_agent(pool.clone()).unwrap(),\n\t))));\n\n\t// Create constraint agent\n\tlet constraint_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_constraint_agent(llm_for_subagents.clone(), pool.clone()).unwrap(),\n\t))));\n\n\t// Create optimize agent\n\tlet optimize_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_optimize_agent(llm_for_subagents.clone(), pool.clone()).unwrap(),\n\t))));\n\n\t// Create Task Agent (sub-agent used to build context and user profile)\n\tlet task_agent_executor = create_task_agent(\n\t\tpool.clone(),\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store.clone(),\n\t)?;\n\tlet task_agent_inner: AgentType = Arc::new(tokio::sync::Mutex::new(task_agent_executor));\n\tlet task_agent = Arc::new(tokio::sync::Mutex::new(task_agent_inner));\n\n\t// Get orchestrator tools\n\tlet tools = get_orchestrator_tools(\n\t\tllm_for_tools,\n\t\tpool.clone(),\n\t\ttask_agent,\n\t\tresearch_agent,\n\t\tconstraint_agent,\n\t\toptimize_agent,\n\t\tchat_session_id.clone(),\n\t\tuser_id.clone(),\n\t\tcontext_store.clone(),\n\t);\n\n\t// Create agent with system prompt and tools\n\tlet agent = if use_mock {\n\t\tlet mock_llm = MockLLM;\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(mock_llm)\n\t\t\t.unwrap()\n\t} else {\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(llm_for_subagents)\n\t\t\t.unwrap()\n\t};\n\n\t// Create executor with increased max iterations for complex multi-agent workflows\n\t// Default is 10, but we need more for orchestrator → sub-agent → tools chains\n\tOk((\n\t\tAgentExecutor::from_agent(agent)\n\t\t\t.with_memory(memory.into())\n\t\t\t.with_max_iterations(30),\n\t\tchat_session_id,\n\t\tuser_id,\n\t\tcontext_store,\n\t))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_orchestrator_agent(\n\tpool: PgPool,\n) -\u003e Result\u003c\n\t(\n\t\tAgentExecutor\u003cConversationalAgent\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tSharedContextStore,\n\t),\n\tAgentError,\n\u003e {\n\t// Use MockLLM for testing to avoid API key requirements\n\tlet llm = MockLLM;\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\tlet llm_arc = Arc::new(llm.clone());\n\tlet chat_session_id = Arc::new(AtomicI32::new(0));\n\tlet user_id = Arc::new(AtomicI32::new(0));\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\t// Dummy sub-agents (including a dummy Task Agent) share the same simple implementation\n\tlet dummy_agent = Arc::new(tokio::sync::Mutex::new(create_dummy_sub_agent()?));\n\tlet task_agent = Arc::clone(\u0026dummy_agent);\n\tlet research_agent = Arc::clone(\u0026dummy_agent);\n\tlet constraint_agent = Arc::clone(\u0026dummy_agent);\n\tlet optimize_agent = Arc::clone(\u0026dummy_agent);\n\tlet tools = get_orchestrator_tools(\n\t\tllm_arc,\n\t\tpool,\n\t\tArc::new(tokio::sync::Mutex::new(task_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(research_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(constraint_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(optimize_agent)),\n\t\tchat_session_id.clone(),\n\t\tuser_id.clone(),\n\t\tcontext_store.clone(),\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk((\n\t\tAgentExecutor::from_agent(agent).with_memory(memory.into()),\n\t\tchat_session_id,\n\t\tuser_id,\n\t\tcontext_store,\n\t))\n}\n\n#[cfg(test)]\nfn create_dummy_sub_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\tlet memory = SimpleMemory::new();\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(\"Dummy sub-agent\".to_string())\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// The system prompt for the Orchestrator Agent.\npub const ORCHESTRATOR_SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/orchestrator.md\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","research.rs"],"content":"/*\n * src/agent/configs/research.rs\n *\n * File for Research Agent Configuration\n *\n * Purpose:\n *   Store Research Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::tools::research::research_tools;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\nconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/research.md\");\n\npub fn create_research_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026research_tools(pool))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_research_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026research_tools(pool))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","task.rs"],"content":"/*\n * src/agent/configs/task.rs\n *\n * File for Task Agent Configuration\n *\n * Purpose:\n *   Task Agent is a sub-agent used by the Orchestrator.\n *   Its sole responsibility is to gather and prepare context for planning:\n *   - Retrieve user profile \u0026 chat history\n *   - Parse user intent\n *   - Ask for clarification when needed\n *   - Persist this information into the shared chat context\n *\n * The Orchestrator Agent then uses this prepared context to route work\n * to the research / constraint / optimize agents.\n */\n\nuse std::sync::Arc;\nuse std::sync::atomic::AtomicI32;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::configs::mock::MockLLM;\nuse crate::agent::models::context::SharedContextStore;\nuse crate::agent::tools::task::get_task_tools;\nuse langchain_rust::language_models::llm::LLM;\n\n/// Creates the Task Agent used as a sub-agent by the Orchestrator.\n///\n/// The Task Agent shares the same `chat_session_id` and `user_id` atomics\n/// as the Orchestrator so all tools operate on the same conversation context.\npub fn create_task_agent(\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Use MockLLM when DEPLOY_LLM != \"1\" so local/dev can run without a real key\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tlet llm_for_agent = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\tlet llm_for_tools: Arc\u003cdyn LLM + Send + Sync\u003e = if use_mock {\n\t\tArc::new(MockLLM)\n\t} else {\n\t\tArc::new(llm_for_agent.clone())\n\t};\n\n\t// Create memory for conversation history\n\tlet memory = SimpleMemory::new();\n\n\t// Tools focused on context building (profile, chat history, intent, clarification, respond)\n\tlet tools = get_task_tools(\n\t\tllm_for_tools,\n\t\tpool,\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store,\n\t);\n\n\t// Create agent with system prompt and tools\n\tlet agent = if use_mock {\n\t\tlet mock_llm = MockLLM;\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(mock_llm)\n\t\t\t.unwrap()\n\t} else {\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(llm_for_agent)\n\t\t\t.unwrap()\n\t};\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(20))\n}\n\n/// Creates a dummy Task Agent for testing purposes.\n///\n/// Mirrors the dummy orchestrator agent but uses the Task Agent system prompt.\n#[cfg(test)]\npub fn create_dummy_task_agent(\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Use MockLLM for testing to avoid API key requirements\n\tlet llm = MockLLM;\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Dummy sub-agents (all the same simple agent)\n\tlet llm_arc = Arc::new(llm.clone());\n\n\t// In-memory context store for tests\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\tlet tools = get_task_tools(\n\t\tllm_arc,\n\t\tpool,\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store,\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n#[cfg(test)]\nfn create_dummy_sub_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\tlet memory = SimpleMemory::new();\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(\"Dummy sub-agent\".to_string())\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// The system prompt for the Task Agent.\npub const TASK_SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/task.md\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","mod.rs"],"content":"pub mod configs;\npub mod models;\npub mod tools;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","context.rs"],"content":"/*\n   src/agent/models/context.rs\n   File for Agent Context Models\n   Purpose:\n\t   Store Agent Context Models\n\n*/\n\nuse crate::http_models::event::Event;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskRoute {\n\tpub task_type: String, // \"research\", \"constraint\", \"optimize\"\n\tpub payload: Value,\n}\n\n/// TripContext: Single source of truth for all trip details\n/// This object is progressively filled in as the user provides information\n/// Instead of re-parsing chat history, we update this object incrementally\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct TripContext {\n\tpub destination: Option\u003cString\u003e,\n\tpub start_date: Option\u003cString\u003e, // ISO 8601 date format (YYYY-MM-DD)\n\tpub end_date: Option\u003cString\u003e,   // ISO 8601 date format (YYYY-MM-DD)\n\tpub budget: Option\u003cf64\u003e,        // Total budget in USD\n\tpub preferences: Vec\u003cString\u003e,   // [\"cultural experiences\", \"beach time\"] - OPTIONAL\n\tpub constraints: Vec\u003cString\u003e,   // Dietary, accessibility, etc. - pre-filled from profile\n\tpub action: Option\u003cString\u003e,     // \"create\", \"modify\", \"view\", \"delete\"\n\tpub itinerary_id: Option\u003ci32\u003e,  // For modify/view/delete actions\n\tpub asked_clarification: bool,  // Track if we've asked user at least once\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolExecution {\n\tpub tool_name: String,\n\tpub timestamp: String, // ISO 8601 format\n\tpub input: Value,\n\tpub output: Value,\n\tpub success: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum PipelineStage {\n\tInitial,      // Just started, parsing user input\n\tResearching,  // Research agent gathering events\n\tConstraining, // Constraint agent validating events\n\tOptimizing,   // Optimizer agent ranking and scheduling\n\tValidating,   // Orchestrator validating final itinerary\n\tComplete,     // Pipeline complete, ready to display\n\tUserFeedback, // Waiting for or processing user feedback\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContextData {\n\tpub chat_session_id: i32, // Chat session this context belongs to\n\tpub user_id: i32,         // User ID for this context\n\tpub user_profile: Option\u003cValue\u003e,\n\tpub chat_history: Vec\u003cValue\u003e,\n\tpub trip_context: TripContext, // Single source of truth for trip details\n\tpub active_itinerary: Option\u003cValue\u003e,\n\tpub events: Vec\u003cEvent\u003e, // Current running list of events being processed\n\tpub tool_history: Vec\u003cToolExecution\u003e,\n\tpub pipeline_stage: Option\u003cString\u003e, // Current stage in the pipeline\n\tpub researched_events: Vec\u003cEvent\u003e,  // Events from research agent\n\tpub constrained_events: Vec\u003cEvent\u003e, // Events validated by constraint agent\n\tpub optimized_events: Vec\u003cEvent\u003e,   // Events ranked/optimized by optimizer agent\n\tpub constraints: Vec\u003cString\u003e, // User constraints extracted from intent (dietary, accessibility, budget, etc.)\n}\n\n/// Shared in-memory store for per-chat ContextData.\n///\n/// Keyed by chat_session_id so all agents/tools in a conversation can\n/// read/write the same contextual state without round-tripping through\n/// the database on every tool call.\npub type SharedContextStore = Arc\u003cRwLock\u003cHashMap\u003ci32, ContextData\u003e\u003e\u003e;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PartialResult {\n\tpub agent: String,\n\tpub data: Value,\n\tpub success: bool,\n\tpub error: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","event.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse serde::{Deserialize, Serialize};\n\nuse crate::sql_models::Period;\n\n/// A subset of [crate::http_models::event::Event] which only contains fields that the LLM might need for context.\n#[derive(Deserialize, Serialize)]\npub struct Event {\n\t/// Primary key\n\tpub id: i32,\n\tpub event_name: String,\n\tpub event_description: Option\u003cString\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","itinerary.rs"],"content":"/*\n\tsrc/agent/models/itinerary.rs\n\tFile for Agent Itinerary Models\n\tPurpose:\n\t\tStore Agent Itinerary Models\n\n*/\n/*\n * src/models/itinerary.rs\n *\n * File for Itinerary table models and related responses\n *\n * Purpose:\n *   Strongly-typed models for the `itineraries` response DTOs\n *   used by itinerary routes.\n */\n\nuse chrono::NaiveDate;\nuse serde::Deserialize;\n\n/// A complete itinerary with event details\n#[derive(Deserialize)]\npub struct Itinerary {\n\t/// Primary key\n\tpub id: i32,\n\t/// UTC date that the first event may take place (%Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// UTC date that the last event may take place (%Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// List of days containing events for that day\n\t/// * Days are guaranteed to be sorted in chronological order\n\tpub event_days: Vec\u003cEventDay\u003e,\n\t/// Possible associated chat session for easy editing on frontend\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Events that are not assigned to any specific time slot\n\tpub unassigned_events: Vec\u003cEvent\u003e,\n}\n\n/// A single day of events in an itinerary\n#[derive(Deserialize)]\npub struct EventDay {\n\t/// All the events taking place in the morning\n\tpub morning_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the afternoon\n\tpub afternoon_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the evening\n\tpub evening_events: Vec\u003cEvent\u003e,\n\t/// The date of this day within the range of itinerary start and end dates (Destination's local timezone - %Y-%m-%d)\n\tpub date: NaiveDate,\n}\n\n#[derive(Deserialize)]\npub struct Event {\n\tid: i32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","mod.rs"],"content":"pub mod context;\npub mod event;\npub mod itinerary;\npub mod user;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","user.rs"],"content":"/*\n\tsrc/agent/models/user.rs\n\tFile for Agent User Models\n\tPurpose:\n\t\tStore Agent User Models\n\n*/\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserIntent {\n\tpub action: String, // \"create_itinerary\", \"modify\", \"query\"\n\tpub destination: Option\u003cString\u003e,\n\tpub start_date: Option\u003cString\u003e,\n\tpub end_date: Option\u003cString\u003e,\n\tpub budget: Option\u003cf64\u003e,\n\tpub preferences: Vec\u003cString\u003e,\n\tpub constraints: Vec\u003cString\u003e,\n\tpub missing_info: Vec\u003cString\u003e, // What information is still needed\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","constraint.rs"],"content":"/*\n * src/agent/tools/constraint.rs\n *\n * Constraint Agent tools.\n *\n * These tools are used by the Constraint Agent to filter research results\n * based on user constraints (e.g., wheelchair accessibility).\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::time::Instant;\nuse tracing::{debug, info};\n\nuse crate::http_models::event::Event;\n\n/// Uses an LLM to intelligently determine if an event should be included\n/// based on trip context, user preferences, and constraints\nasync fn should_include_event(\n\tllm: \u0026Arc\u003cdyn LLM + Send + Sync\u003e,\n\tevent: \u0026Event,\n\tpreferences: \u0026[String],\n\tconstraints: \u0026[String],\n) -\u003e Result\u003c(bool, Option\u003cString\u003e), Box\u003cdyn Error\u003e\u003e {\n\t// Serialize the event as JSON for the LLM to analyze\n\tlet event_json = serde_json::to_string_pretty(event)\n\t\t.unwrap_or_else(|_| format!(\"Event: {}\", event.event_name));\n\n\t// Create a prompt with all event details\n\tlet prompt = format!(\n\t\tr#\"You are evaluating whether a place/event is relevant for a vacation trip.\n\nTRIP CONTEXT:\n- User preferences: {}\n- User constraints: {}\n\nPLACE TO EVALUATE (all available data):\n{}\n\nRULES:\n1. ALWAYS EXCLUDE: schools, universities, hospitals, clinics, retail stores (Home Depot, Target, CVS, Staples), DMV, government offices, gas stations, banks\n2. INCLUDE places that match user preferences (e.g., if they want to \"eat a lot\", include restaurants, cafes, bars, wineries)\n3. INCLUDE potentially interesting vacation spots: parks, museums, theaters, attractions, hotels, landmarks\n4. For food preferences, only include actual dining establishments (restaurants, cafes, bars, bakeries, wineries) - NOT grocery stores\n5. If user requires wheelchair accessibility, check the wheelchair_accessible fields and EXCLUDE places that are not accessible\n\nShould this place be INCLUDED in the vacation itinerary?\nRespond with ONLY a JSON object in this exact format:\n{{\"include\": true/false, \"reason\": \"brief reason\"}}\"#,\n\t\tif preferences.is_empty() {\n\t\t\t\"none specified\".to_string()\n\t\t} else {\n\t\t\tpreferences.join(\", \")\n\t\t},\n\t\tif constraints.is_empty() {\n\t\t\t\"none\".to_string()\n\t\t} else {\n\t\t\tconstraints.join(\", \")\n\t\t},\n\t\tevent_json\n\t);\n\n\tlet response = llm.invoke(\u0026prompt).await?;\n\n\t// Parse the LLM response\n\tlet cleaned = response\n\t\t.trim()\n\t\t.trim_start_matches(\"```json\")\n\t\t.trim_end_matches(\"```\")\n\t\t.trim();\n\n\tmatch serde_json::from_str::\u003cValue\u003e(cleaned) {\n\t\tOk(parsed) =\u003e {\n\t\t\tlet include = parsed\n\t\t\t\t.get(\"include\")\n\t\t\t\t.and_then(|v| v.as_bool())\n\t\t\t\t.unwrap_or(false);\n\t\t\tlet reason = parsed\n\t\t\t\t.get(\"reason\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.map(|s| s.to_string());\n\t\t\tOk((include, reason))\n\t\t}\n\t\tErr(_) =\u003e {\n\t\t\t// If parsing fails, default to including the event\n\t\t\tdebug!(target: \"constraint_tools\", \"Failed to parse LLM response for event: {}, response: {}\", event.event_name, response);\n\t\t\tOk((\n\t\t\t\ttrue,\n\t\t\t\tSome(\"LLM response parsing failed, including by default\".to_string()),\n\t\t\t))\n\t\t}\n\t}\n}\n\n/// Tool that filters a list of event IDs based on user constraints.\n///\n/// Expected input (from the Orchestrator via `route_task` with `task_type = \"constraint\"`):\n///\n/// ```json\n/// {\n///   \"event_ids\": [1, 2, 3, ...], // array of event IDs from research agent\n///   \"constraints\": [\"No Tree Nuts\", \"No Peanuts\", \"Wheelchair accessible required: ...\"],\n///   \"trip_context\": { ... } // optional, for future use\n/// }\n/// ```\n///\n/// - If `constraints` is empty, this tool returns a natural-language question\n///   asking the user for constraints/preferences.\n/// - If constraints are present, it fetches the events from the database by ID,\n///   evaluates each with an LLM, and returns:\n///\n/// ```json\n/// {\n///   \"filtered_event_ids\": [1, 3, 5, ...],\n///   \"removed_events\": [ { \"event_id\": 2, \"event_name\": \"...\", \"reasons\": [\"...\"] } ]\n/// }\n/// ```\n#[derive(Clone)]\npub struct FilterEventsByConstraintsTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tdb: PgPool,\n}\n\nimpl FilterEventsByConstraintsTool {\n\tpub fn new(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Self {\n\t\tSelf { llm, db }\n\t}\n}\n\n#[async_trait]\nimpl Tool for FilterEventsByConstraintsTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"filter_events_by_constraints\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Filters a list of event IDs from the Research Agent using the user's constraints (e.g., wheelchair accessibility). IMPORTANT: Pass the entire JSON input you received (with event_ids, constraints, and trip_context) as the action_input. The tool will extract what it needs.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"input_data\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Pass the entire JSON input you received as a string. Do not pass empty string.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"constraint\",\n\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\"Starting constraint filtering\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Normalize input: langchain_rust passes `action_input` as a STRING.\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Extract event_ids array - handle both array and JSON string formats\n\t\tlet mut event_ids_val = parsed_input\n\t\t\t.get(\"event_ids\")\n\t\t\t.cloned()\n\t\t\t.or_else(|| {\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"events\")\n\t\t\t\t\t.and_then(|v| v.get(\"event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.or_else(|| {\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"data\")\n\t\t\t\t\t.and_then(|v| v.get(\"event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.unwrap_or(Value::Null);\n\n\t\t// If event_ids is a JSON string, parse it into an array\n\t\tif event_ids_val.is_string() {\n\t\t\tlet event_ids_str = event_ids_val.as_str().unwrap_or(\"[]\");\n\t\t\tevent_ids_val = serde_json::from_str(event_ids_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\t// Check if we already have a result (agent calling tool on previous output)\n\t\tif event_ids_val.is_null() \u0026\u0026 parsed_input.get(\"filtered_event_ids\").is_some() {\n\t\t\t// Agent is trying to call the tool on its own previous output\n\t\t\t// Just return that output directly\n\t\t\tinfo!(\n\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\t\"Tool called with previous output, returning it directly\"\n\t\t\t);\n\t\t\treturn Ok(serde_json::to_string(\u0026parsed_input)?);\n\t\t}\n\n\t\tlet event_ids: Vec\u003ci32\u003e = event_ids_val\n\t\t\t.as_array()\n\t\t\t.ok_or(\"event_ids should be an array of integers\")?\n\t\t\t.iter()\n\t\t\t.filter_map(|v| v.as_i64().map(|i| i as i32))\n\t\t\t.collect();\n\n\t\tif event_ids.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"constraint\",\n\t\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no event IDs provided\"\n\t\t\t);\n\t\t\treturn Err(\"No event IDs provided to constraint agent\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tevent_ids_count = event_ids.len(),\n\t\t\t\"Fetching events from database\"\n\t\t);\n\n\t\t// Fetch all events from database by their IDs\n\t\tlet rows = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT \n\t\t\t\tid,\n\t\t\t\tevent_name,\n\t\t\t\tevent_description,\n\t\t\t\tstreet_address,\n\t\t\t\tcity,\n\t\t\t\tcountry,\n\t\t\t\tpostal_code,\n\t\t\t\tlat,\n\t\t\t\tlng,\n\t\t\t\tevent_type,\n\t\t\t\tuser_created,\n\t\t\t\thard_start,\n\t\t\t\thard_end,\n\t\t\t\ttimezone,\n\t\t\t\tplace_id,\n\t\t\t\twheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food,\n\t\t\t\tprice_level,\n\t\t\t\tutc_offset_minutes,\n\t\t\t\twebsite_uri,\n\t\t\t\ttypes,\n\t\t\t\tphoto_name,\n\t\t\t\tphoto_width,\n\t\t\t\tphoto_height,\n\t\t\t\tphoto_author,\n\t\t\t\tphoto_author_uri,\n\t\t\t\tphoto_author_photo_uri,\n\t\t\t\tweekday_descriptions,\n\t\t\t\tsecondary_hours_type,\n\t\t\t\tnext_open_time,\n\t\t\t\tnext_close_time,\n\t\t\t\topen_now,\n\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\tspecial_days\n\t\t\tFROM events\n\t\t\tWHERE id = ANY($1)\n\t\t\t\"#,\n\t\t\t\u0026event_ids\n\t\t)\n\t\t.fetch_all(\u0026self.db)\n\t\t.await?;\n\n\t\t// Map rows to Event structs\n\t\tlet events: Vec\u003cEvent\u003e = rows\n\t\t\t.into_iter()\n\t\t\t.map(|row| Event {\n\t\t\t\tid: row.id,\n\t\t\t\tevent_name: row.event_name,\n\t\t\t\tevent_description: row.event_description,\n\t\t\t\tstreet_address: row.street_address,\n\t\t\t\tcity: row.city,\n\t\t\t\tcountry: row.country,\n\t\t\t\tpostal_code: row.postal_code,\n\t\t\t\tlat: row.lat,\n\t\t\t\tlng: row.lng,\n\t\t\t\tevent_type: row.event_type,\n\t\t\t\tuser_created: row.user_created,\n\t\t\t\thard_start: row.hard_start,\n\t\t\t\thard_end: row.hard_end,\n\t\t\t\ttimezone: row.timezone,\n\t\t\t\tplace_id: row.place_id,\n\t\t\t\twheelchair_accessible_parking: row.wheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance: row.wheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom: row.wheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating: row.wheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food: row.serves_vegetarian_food,\n\t\t\t\tprice_level: row.price_level,\n\t\t\t\tutc_offset_minutes: row.utc_offset_minutes,\n\t\t\t\twebsite_uri: row.website_uri,\n\t\t\t\ttypes: row.types,\n\t\t\t\tphoto_name: row.photo_name,\n\t\t\t\tphoto_width: row.photo_width,\n\t\t\t\tphoto_height: row.photo_height,\n\t\t\t\tphoto_author: row.photo_author,\n\t\t\t\tphoto_author_uri: row.photo_author_uri,\n\t\t\t\tphoto_author_photo_uri: row.photo_author_photo_uri,\n\t\t\t\tweekday_descriptions: row.weekday_descriptions,\n\t\t\t\tsecondary_hours_type: row.secondary_hours_type,\n\t\t\t\tnext_open_time: row.next_open_time,\n\t\t\t\tnext_close_time: row.next_close_time,\n\t\t\t\topen_now: row.open_now,\n\t\t\t\tperiods: row.periods,\n\t\t\t\tspecial_days: row.special_days,\n\t\t\t\tblock_index: None, // Not used in constraint filtering\n\t\t\t})\n\t\t\t.collect();\n\n\t\tif events.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"constraint\",\n\t\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no events found in database for provided IDs\"\n\t\t\t);\n\t\t\treturn Err(\"No events found in database for the provided IDs\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tevents_fetched = events.len(),\n\t\t\t\"Events fetched successfully\"\n\t\t);\n\n\t\t// Extract constraints (strings, lowercased for matching)\n\t\tlet mut constraints_val = if parsed_input.get(\"constraints\").is_some() {\n\t\t\tparsed_input\n\t\t\t\t.get(\"constraints\")\n\t\t\t\t.cloned()\n\t\t\t\t.unwrap_or(Value::Null)\n\t\t} else {\n\t\t\tparsed_input\n\t\t\t\t.get(\"trip_context\")\n\t\t\t\t.and_then(|tc| tc.get(\"constraints\"))\n\t\t\t\t.cloned()\n\t\t\t\t.unwrap_or(Value::Null)\n\t\t};\n\n\t\t// If constraints is a JSON string, parse it into an array\n\t\tif constraints_val.is_string() {\n\t\t\tlet constraints_str = constraints_val.as_str().unwrap_or(\"[]\");\n\t\t\tconstraints_val = serde_json::from_str(constraints_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\tlet constraints: Vec\u003cString\u003e = if let Some(arr) = constraints_val.as_array() {\n\t\t\tarr.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_lowercase()))\n\t\t\t\t.collect()\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\n\t\t// Extract preferences from trip_context\n\t\tlet preferences: Vec\u003cString\u003e = parsed_input\n\t\t\t.get(\"trip_context\")\n\t\t\t.and_then(|tc| tc.get(\"preferences\"))\n\t\t\t.and_then(|p| p.as_array())\n\t\t\t.map(|arr| {\n\t\t\t\tarr.iter()\n\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_lowercase()))\n\t\t\t\t\t.collect()\n\t\t\t})\n\t\t\t.unwrap_or_else(Vec::new);\n\n\t\t// Constraints are optional - if none exist, we proceed with no filtering\n\t\t// The task agent should have already asked for clarification if critical info was missing\n\t\tif constraints.is_empty() {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\t\"No constraints provided - will include all events\"\n\t\t\t);\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tpreferences = ?preferences,\n\t\t\tconstraints = ?constraints,\n\t\t\tevents_count = events.len(),\n\t\t\t\"Processing events with LLM-based filtering\"\n\t\t);\n\n\t\tlet mut filtered_ids: Vec\u003ci32\u003e = Vec::new();\n\t\tlet mut removed: Vec\u003cValue\u003e = Vec::new();\n\n\t\t// Process each event with LLM evaluation\n\t\tfor event in events.iter() {\n\t\t\t// Use LLM to evaluate if event should be included\n\t\t\tmatch should_include_event(\u0026self.llm, event, \u0026preferences, \u0026constraints).await {\n\t\t\t\tOk((should_include, reason)) =\u003e {\n\t\t\t\t\tif should_include {\n\t\t\t\t\t\tfiltered_ids.push(event.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet reason_text =\n\t\t\t\t\t\t\treason.unwrap_or_else(|| \"not relevant for trip\".to_string());\n\t\t\t\t\t\tremoved.push(json!({\n\t\t\t\t\t\t\t\"event_id\": event.id,\n\t\t\t\t\t\t\t\"event_name\": \u0026event.event_name,\n\t\t\t\t\t\t\t\"reasons\": [reason_text],\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\t\t\terror = %e,\n\t\t\t\t\t\tevent_name = %event.event_name,\n\t\t\t\t\t\t\"LLM evaluation failed, including event by default\"\n\t\t\t\t\t);\n\t\t\t\t\t// On error, include the event by default to avoid over-filtering\n\t\t\t\t\tfiltered_ids.push(event.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet result = json!({\n\t\t\t\"filtered_event_ids\": filtered_ids,\n\t\t\t\"removed_events\": removed,\n\t\t\t\"count\": filtered_ids.len()\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\t// Extract event names for debugging\n\t\tlet filtered_names: Vec\u003cString\u003e = events\n\t\t\t.iter()\n\t\t\t.filter(|e| filtered_ids.contains(\u0026e.id))\n\t\t\t.map(|e| e.event_name.clone())\n\t\t\t.collect();\n\n\t\tlet removed_names: Vec\u003cString\u003e = result[\"removed_events\"]\n\t\t\t.as_array()\n\t\t\t.map(|arr| {\n\t\t\t\tarr.iter()\n\t\t\t\t\t.filter_map(|e| {\n\t\t\t\t\t\te.get(\"event_name\")\n\t\t\t\t\t\t\t.and_then(|n| n.as_str())\n\t\t\t\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t\t})\n\t\t\t\t\t.collect()\n\t\t\t})\n\t\t\t.unwrap_or_default();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"constraint\",\n\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\n\t\t\t\t\"elapsed_ms={}, filtered_count={}, removed_count={}, filtered=[{}], removed=[{}]\",\n\t\t\t\telapsed.as_millis(),\n\t\t\t\tfiltered_ids.len(),\n\t\t\t\tremoved.len(),\n\t\t\t\tfiltered_names.join(\", \"),\n\t\t\t\tremoved_names.join(\", \")\n\t\t\t)\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tfiltered_count = filtered_ids.len(),\n\t\t\tremoved_count = removed.len(),\n\t\t\t\"Constraint filtering completed\"\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n\npub fn constraint_tools(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![Arc::new(FilterEventsByConstraintsTool::new(llm, db))]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","example.rs"],"content":"/*\n * src/agent/example.rs\n *\n * File for Agent Tools\n *\n * Purpose:\n *   Store Agent Tools\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse std::error::Error;\n\n/// Example tool that returns a greeting message\n///\n/// This tool accepts a name as input and generates a friendly greeting.\n/// It implements the Tool trait from langchain-rust to be used by AI agents.\n#[derive(Clone)]\npub struct GreetingTool;\n\n#[async_trait]\nimpl Tool for GreetingTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"greeting_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that generates a friendly greeting message. Use this when you need to greet the user or create a welcoming message.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"name\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The name of the person to greet\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"name\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet name = input[\"name\"].as_str().ok_or(\"Name should be a string\")?;\n\n\t\tOk(format!(\"Hello, {}! Welcome to our AI assistant.\", name))\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","mod.rs"],"content":"pub mod constraint;\npub mod optimizer;\npub mod orchestrator;\npub mod research;\npub mod task;\npub mod tsp;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","optimizer.rs"],"content":"/*\n * src/agent/tools/optimizer.rs\n *\n * File for Optimizer Agent Tools\n *\n * Purpose:\n *   Store Optimizer Agent Tools for itinerary optimization\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::{language_models::llm::LLM, tools::Tool};\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::{error::Error, sync::Arc, time::Instant};\nuse tracing::{debug, info, warn};\n\nuse crate::agent::models::event::Event;\n\npub fn optimizer_tools(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![Arc::new(OptimizeItineraryTool::new(\n\t\tllm.clone(),\n\t\tdb.clone(),\n\t))]\n}\n\n/// Main tool that orchestrates the full optimization workflow.\n/// This tool:\n/// 1. Accepts filtered event IDs from the constraint agent\n/// 2. Fetches events from the database\n/// 3. Retrieves user profile from context\n/// 4. Ranks POIs by preference\n/// 5. Drafts an itinerary\n/// 6. Optimizes routes for each day\n/// 7. Returns a complete structured itinerary\n#[derive(Clone)]\nstruct OptimizeItineraryTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tdb: PgPool,\n}\n\nimpl OptimizeItineraryTool {\n\tpub fn new(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Self {\n\t\tSelf { llm, db }\n\t}\n}\n\n#[async_trait]\nimpl Tool for OptimizeItineraryTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"optimize_itinerary\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Main optimization workflow tool. IMPORTANT: Pass the entire JSON input you received (with filtered_event_ids, trip_context, and user_profile) as the action_input. Fetches events from database, ranks them by user preference, drafts an itinerary, and optimizes routes. Returns a complete structured itinerary ready for storage.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"input_data\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Pass the entire JSON input you received as a string. Do not pass empty string.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_itinerary\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"optimize_itinerary\",\n\t\t\t\"Starting itinerary optimization workflow\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Parse input (handle both string and object formats from langchain_rust)\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Extract and parse filtered_event_ids\n\t\tlet mut event_ids_val = parsed_input\n\t\t\t.get(\"filtered_event_ids\")\n\t\t\t.cloned()\n\t\t\t.or_else(|| {\n\t\t\t\t// Try alternative paths from orchestrator payload\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"events\")\n\t\t\t\t\t.and_then(|v| v.get(\"filtered_event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.unwrap_or(Value::Null);\n\n\t\t// If event_ids is a JSON string, parse it\n\t\tif event_ids_val.is_string() {\n\t\t\tlet event_ids_str = event_ids_val.as_str().unwrap_or(\"[]\");\n\t\t\tevent_ids_val = serde_json::from_str(event_ids_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\t// Check if we already have a result (agent calling tool on previous output)\n\t\tif event_ids_val.is_null() \u0026\u0026 parsed_input.get(\"event_days\").is_some() {\n\t\t\t// Agent is trying to call the tool on its own previous output (an itinerary)\n\t\t\t// Just return that output directly\n\t\t\tinfo!(\n\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\"Tool called with previous output, returning it directly\"\n\t\t\t);\n\t\t\treturn Ok(serde_json::to_string(\u0026parsed_input)?);\n\t\t}\n\n\t\tlet event_ids: Vec\u003ci32\u003e = event_ids_val\n\t\t\t.as_array()\n\t\t\t.ok_or(\"filtered_event_ids should be an array of integers\")?\n\t\t\t.iter()\n\t\t\t.filter_map(|v| v.as_i64().map(|i| i as i32))\n\t\t\t.collect();\n\n\t\tif event_ids.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"optimize\",\n\t\t\t\ttool: \"optimize_itinerary\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no event IDs provided\"\n\t\t\t);\n\t\t\treturn Err(\"No event IDs provided to optimize agent\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tevent_count = event_ids.len(),\n\t\t\t\"Fetching events from database\"\n\t\t);\n\n\t\t// Fetch all events from database\n\t\tlet rows = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tid,\n\t\t\t\tevent_name,\n\t\t\t\tevent_description,\n\t\t\t\tstreet_address,\n\t\t\t\tcity,\n\t\t\t\tcountry,\n\t\t\t\tpostal_code,\n\t\t\t\tlat,\n\t\t\t\tlng,\n\t\t\t\tevent_type,\n\t\t\t\thard_start,\n\t\t\t\thard_end,\n\t\t\t\ttimezone,\n\t\t\t\twheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food,\n\t\t\t\tprice_level,\n\t\t\t\tutc_offset_minutes,\n\t\t\t\ttypes,\n\t\t\t\tweekday_descriptions,\n\t\t\t\tsecondary_hours_type,\n\t\t\t\tnext_open_time,\n\t\t\t\tnext_close_time,\n\t\t\t\topen_now,\n\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\tspecial_days\n\t\t\tFROM events\n\t\t\tWHERE id = ANY($1)\n\t\t\t\"#,\n\t\t\t\u0026event_ids\n\t\t)\n\t\t.fetch_all(\u0026self.db)\n\t\t.await?;\n\n\t\tlet events: Vec\u003cEvent\u003e = rows\n\t\t\t.into_iter()\n\t\t\t.map(|row| Event {\n\t\t\t\tid: row.id,\n\t\t\t\tevent_name: row.event_name,\n\t\t\t\tevent_description: row.event_description,\n\t\t\t\tstreet_address: row.street_address,\n\t\t\t\tcity: row.city,\n\t\t\t\tcountry: row.country,\n\t\t\t\tpostal_code: row.postal_code,\n\t\t\t\tlat: row.lat,\n\t\t\t\tlng: row.lng,\n\t\t\t\tevent_type: row.event_type,\n\t\t\t\thard_start: row.hard_start,\n\t\t\t\thard_end: row.hard_end,\n\t\t\t\ttimezone: row.timezone,\n\t\t\t\twheelchair_accessible_parking: row.wheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance: row.wheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom: row.wheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating: row.wheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food: row.serves_vegetarian_food,\n\t\t\t\tprice_level: row.price_level,\n\t\t\t\tutc_offset_minutes: row.utc_offset_minutes,\n\t\t\t\ttypes: row.types,\n\t\t\t\tweekday_descriptions: row.weekday_descriptions,\n\t\t\t\tsecondary_hours_type: row.secondary_hours_type,\n\t\t\t\tnext_open_time: row.next_open_time,\n\t\t\t\tnext_close_time: row.next_close_time,\n\t\t\t\topen_now: row.open_now,\n\t\t\t\tperiods: row.periods,\n\t\t\t\tspecial_days: row.special_days,\n\t\t\t\tblock_index: None,\n\t\t\t})\n\t\t\t.collect();\n\n\t\tif events.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"optimize\",\n\t\t\t\ttool: \"optimize_itinerary\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no events found in database\"\n\t\t\t);\n\t\t\treturn Err(\"No events found in database for provided IDs\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tevents_fetched = events.len(),\n\t\t\t\"Events fetched successfully\"\n\t\t);\n\n\t\t// Extract trip_context and user_profile\n\t\tlet mut trip_context_val = parsed_input\n\t\t\t.get(\"trip_context\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\tif trip_context_val.is_string() {\n\t\t\ttrip_context_val = serde_json::from_str(trip_context_val.as_str().unwrap_or(\"{}\"))\n\t\t\t\t.unwrap_or(json!({}));\n\t\t}\n\n\t\tlet mut user_profile_val = parsed_input\n\t\t\t.get(\"user_profile\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\tif user_profile_val.is_string() {\n\t\t\tuser_profile_val = serde_json::from_str(user_profile_val.as_str().unwrap_or(\"{}\"))\n\t\t\t\t.unwrap_or(json!({}));\n\t\t}\n\n\t\t// STEP 1: Rank POIs by preference\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 1: Ranking POIs by user preference\"\n\t\t);\n\n\t\tlet events_json = serde_json::to_value(\u0026events)?;\n\t\tlet rank_input = json!({\n\t\t\t\"pois\": events_json,\n\t\t\t\"user_profile\": user_profile_val\n\t\t});\n\n\t\tlet rank_tool = RankPOIsByPreferenceTool {\n\t\t\tllm: self.llm.clone(),\n\t\t};\n\t\tlet ranked_result = rank_tool.run(rank_input).await?;\n\n\t\t// Parse the ranked POIs (should be JSON array with rank fields added)\n\t\t// Try to extract JSON from markdown code blocks if present\n\t\tlet cleaned_result = ranked_result\n\t\t\t.trim()\n\t\t\t.strip_prefix(\"```json\")\n\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t.or_else(|| {\n\t\t\t\tranked_result\n\t\t\t\t\t.trim()\n\t\t\t\t\t.strip_prefix(\"```\")\n\t\t\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t})\n\t\t\t.unwrap_or(ranked_result.trim());\n\n\t\tlet mut ranked_pois: Vec\u003cValue\u003e = serde_json::from_str(cleaned_result)\n\t\t\t.map_err(|e| {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\terror = %e,\n\t\t\t\t\tresponse = %ranked_result,\n\t\t\t\t\t\"Failed to parse ranked POIs, adding default ranks\"\n\t\t\t\t);\n\t\t\t\te\n\t\t\t})\n\t\t\t.unwrap_or_else(|_| {\n\t\t\t\t// Fallback: use original events and add default ranks\n\t\t\t\tevents_json.as_array().cloned().unwrap_or_default()\n\t\t\t});\n\n\t\t// Ensure all POIs have a rank field (add default if missing)\n\t\tfor poi in ranked_pois.iter_mut() {\n\t\t\tif poi.get(\"rank\").is_none() {\n\t\t\t\t// Add a high default rank for POIs missing the rank field\n\t\t\t\tif let Some(obj) = poi.as_object_mut() {\n\t\t\t\t\tobj.insert(\"rank\".to_string(), json!(999));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Sort by rank to ensure best POIs come first\n\t\tranked_pois.sort_by(|a, b| {\n\t\t\tlet rank_a = a.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\tlet rank_b = b.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\trank_a.cmp(\u0026rank_b)\n\t\t});\n\n\t\t// Extract ranking summary for logging\n\t\tlet mut rankings: Vec\u003cString\u003e = ranked_pois\n\t\t\t.iter()\n\t\t\t.map(|poi| {\n\t\t\t\tlet name = poi\n\t\t\t\t\t.get(\"event_name\")\n\t\t\t\t\t.and_then(|n| n.as_str())\n\t\t\t\t\t.unwrap_or(\"Unknown\");\n\t\t\t\tlet rank = poi.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\t\tformat!(\"{}(rank:{})\", name, rank)\n\t\t\t})\n\t\t\t.collect();\n\t\trankings.sort_by_key(|s| {\n\t\t\t// Extract rank number for sorting\n\t\t\ts.split(\"rank:\")\n\t\t\t\t.nth(1)\n\t\t\t\t.and_then(|r| r.trim_end_matches(')').parse::\u003ci64\u003e().ok())\n\t\t\t\t.unwrap_or(999)\n\t\t});\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tranked_count = ranked_pois.len(),\n\t\t\t\"POIs ranked successfully\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"rankings=[{}]\", rankings.join(\", \"))\n\t\t);\n\n\t\t// STEP 2: Draft the itinerary\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 2: Drafting itinerary structure\"\n\t\t);\n\n\t\tlet draft_input = json!({\n\t\t\t\"pois\": ranked_pois,\n\t\t\t\"diversity_factor\": 0.7,\n\t\t\t\"trip_context\": trip_context_val\n\t\t});\n\n\t\tlet draft_tool = DraftItineraryTool {\n\t\t\tllm: self.llm.clone(),\n\t\t};\n\t\tlet draft_result = draft_tool.run(draft_input).await?;\n\n\t\t// Parse the draft itinerary\n\t\t// Try to extract JSON from markdown code blocks if present\n\t\tlet cleaned_draft = draft_result\n\t\t\t.trim()\n\t\t\t.strip_prefix(\"```json\")\n\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t.or_else(|| {\n\t\t\t\tdraft_result\n\t\t\t\t\t.trim()\n\t\t\t\t\t.strip_prefix(\"```\")\n\t\t\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t})\n\t\t\t.unwrap_or(draft_result.trim());\n\n\t\t// Try standard JSON parsing first\n\t\tlet mut itinerary: Value = match serde_json::from_str(cleaned_draft) {\n\t\t\tOk(value) =\u003e value,\n\t\t\tErr(e) =\u003e {\n\t\t\t\twarn!(\n\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\terror = %e,\n\t\t\t\t\tresponse_len = draft_result.len(),\n\t\t\t\t\t\"Failed to parse draft itinerary with standard JSON parser, trying JSON5\"\n\t\t\t\t);\n\n\t\t\t\t// Try JSON5 parser which is more lenient (handles trailing commas, comments, etc.)\n\t\t\t\tmatch json5::from_str(cleaned_draft) {\n\t\t\t\t\tOk(value) =\u003e {\n\t\t\t\t\t\tinfo!(\n\t\t\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\t\t\t\"Successfully parsed draft itinerary using JSON5 (lenient parser)\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t\tErr(json5_err) =\u003e {\n\t\t\t\t\t\t// Both parsers failed - log detailed error and return error\n\t\t\t\t\t\tlet preview = draft_result.chars().take(500).collect::\u003cString\u003e();\n\n\t\t\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\t\t\tagent: \"optimize\",\n\t\t\t\t\t\t\ttool: \"draft_itinerary\",\n\t\t\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\t\t\tdetails: format!(\"JSON parse failed: {}\", e)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn Err(format!(\n\t\t\t\t\t\t\"Failed to parse draft itinerary. Standard JSON error: {}. JSON5 error: {}. Response preview: {}\",\n\t\t\t\t\t\te, json5_err, preview\n\t\t\t\t\t).into());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Build schedule summary\n\t\tlet mut schedule_summary: Vec\u003cString\u003e = Vec::new();\n\t\tif let Some(event_days) = itinerary.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\tfor (day_idx, day) in event_days.iter().enumerate() {\n\t\t\t\tlet date = day\n\t\t\t\t\t.get(\"date\")\n\t\t\t\t\t.and_then(|d| d.as_str())\n\t\t\t\t\t.unwrap_or(\"unknown\");\n\n\t\t\t\tlet morning = day\n\t\t\t\t\t.get(\"morning_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet afternoon = day\n\t\t\t\t\t.get(\"afternoon_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet evening = day\n\t\t\t\t\t.get(\"evening_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet mut day_parts = Vec::new();\n\t\t\t\tif !morning.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"AM:[{}]\", morning));\n\t\t\t\t}\n\t\t\t\tif !afternoon.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"PM:[{}]\", afternoon));\n\t\t\t\t}\n\t\t\t\tif !evening.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"EVE:[{}]\", evening));\n\t\t\t\t}\n\n\t\t\t\tschedule_summary.push(format!(\n\t\t\t\t\t\"Day{}({}):{}\",\n\t\t\t\t\tday_idx + 1,\n\t\t\t\t\tdate,\n\t\t\t\t\tif day_parts.is_empty() {\n\t\t\t\t\t\t\"empty\".to_string()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tday_parts.join(\" \")\n\t\t\t\t\t}\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tlet days_count = schedule_summary.len();\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tdays_count = days_count,\n\t\t\t\"Draft itinerary created\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"schedule=[{}]\", schedule_summary.join(\" | \"))\n\t\t);\n\n\t\t// STEP 3: Optimize routes for each day\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 3: Optimizing routes for each day\"\n\t\t);\n\n\t\tlet optimize_route_tool = OptimizeRouteTool;\n\t\tlet mut optimized_days = 0;\n\n\t\t// Get event_days array\n\t\tif let Some(event_days) = itinerary\n\t\t\t.get_mut(\"event_days\")\n\t\t\t.and_then(|v| v.as_array_mut())\n\t\t{\n\t\t\tfor day in event_days.iter_mut() {\n\t\t\t\t// Optimize morning events\n\t\t\t\tif let Some(morning) = day.get(\"morning_events\").cloned() {\n\t\t\t\t\tif let Some(morning_arr) = morning.as_array() {\n\t\t\t\t\t\tif !morning_arr.is_empty() \u0026\u0026 morning_arr.len() \u003e 1 {\n\t\t\t\t\t\t\t// Get first event location as start\n\t\t\t\t\t\t\tif let Some(first) = morning_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": morning,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"morning_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Optimize afternoon events\n\t\t\t\tif let Some(afternoon) = day.get(\"afternoon_events\").cloned() {\n\t\t\t\t\tif let Some(afternoon_arr) = afternoon.as_array() {\n\t\t\t\t\t\tif !afternoon_arr.is_empty() \u0026\u0026 afternoon_arr.len() \u003e 1 {\n\t\t\t\t\t\t\tif let Some(first) = afternoon_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": afternoon,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"afternoon_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Optimize evening events\n\t\t\t\tif let Some(evening) = day.get(\"evening_events\").cloned() {\n\t\t\t\t\tif let Some(evening_arr) = evening.as_array() {\n\t\t\t\t\t\tif !evening_arr.is_empty() \u0026\u0026 evening_arr.len() \u003e 1 {\n\t\t\t\t\t\t\tif let Some(first) = evening_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": evening,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"evening_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\toptimized_blocks = optimized_days,\n\t\t\t\"Routes optimized for all days\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{} time blocks optimized\", optimized_days)\n\t\t);\n\n\t\t// Add metadata to itinerary\n\t\titinerary[\"start_date\"] = trip_context_val\n\t\t\t.get(\"start_date\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\titinerary[\"end_date\"] = trip_context_val\n\t\t\t.get(\"end_date\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\titinerary[\"title\"] = trip_context_val\n\t\t\t.get(\"destination\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(json!(\"Trip Itinerary\"));\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tlet result = serde_json::to_string(\u0026itinerary)?;\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, events_processed={}\", elapsed.as_millis(), events.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tevents_processed = events.len(),\n\t\t\t\"Optimization workflow completed successfully\"\n\t\t);\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool that ranks Points of Interest based on user preferences and constraints\n///\n/// This tool evaluates and ranks POIs considering user profile factors such as:\n/// - Budget constraints\n/// - Risk tolerance\n/// - Dietary restrictions/allergies\n/// - Accessibility needs/disabilities\n/// - Personal interests and preferences\n#[derive(Clone)]\nstruct RankPOIsByPreferenceTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n}\n\n/// Tool that builds an itinerary from a list of events\n#[derive(Clone)]\nstruct DraftItineraryTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n}\n\n/// Tool that optimizes the travel route for a day using TSP algorithms\n///\n/// This tool applies Traveling Salesman Problem optimization to minimize\n/// travel time and distance between POIs in a single day. Considers:\n/// - Geographic proximity\n/// - Transportation methods available\n/// - Traffic patterns\n/// - Walking distances\n#[derive(Clone)]\nstruct OptimizeRouteTool;\n\n#[async_trait]\nimpl Tool for RankPOIsByPreferenceTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"rank_pois_by_preference\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Ranks a list of Points of Interest based on user preferences, budget, risk tolerance, allergies, and accessibility needs. Returns a prioritized list of POIs with scores.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects to be ranked\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"user_profile\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"User profile containing budget, risk tolerance, allergies, disabilities, and preferences\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"budget\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"risk_tolerance\": {\"type\": \"string\"},\n\t\t\t\t\t\t\"allergies\": {\"type\": \"array\"},\n\t\t\t\t\t\t\"disabilities\": {\"type\": \"array\"},\n\t\t\t\t\t\t\"interests\": {\"type\": \"array\"}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"pois\", \"user_profile\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"rank_pois_by_preference\",\n\t\t\t\"Starting POI ranking\"\n\t\t);\n\n\t\tlet pois = input[\"pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"pois must be an array of objects\")?;\n\t\tlet profile = input[\"user_profile\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"user_profile must be an object\")?;\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tpois_count = pois.len(),\n\t\t\t\"Ranking POIs by preference\"\n\t\t);\n\n\t\tlet prompt = format!(\n\t\t\tinclude_str!(\"../prompts/rank_pois_preference.md\"),\n\t\t\tserde_json::to_string_pretty(\u0026pois)?,\n\t\t\tserde_json::to_string_pretty(\u0026profile)?\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, pois_count={}\", elapsed.as_millis(), pois.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tpois_count = pois.len(),\n\t\t\t\"POI ranking completed\"\n\t\t);\n\n\t\tOk(response.trim().to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for DraftItineraryTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"draft_itinerary\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Assemble an itinerary from the list of POIs into the provided itinerary model structure.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects to be clustered\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"diversity_factor\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"Factor controlling how much diversity to enforce (0.0 to 1.0)\",\n\t\t\t\t\t\"default\": 0.7\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"pois\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"draft_itinerary\",\n\t\t\t\"Starting itinerary drafting\"\n\t\t);\n\n\t\tlet pois = input[\"pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"pois must be an array of objects\")?;\n\t\tlet diversity_factor = input[\"diversity_factor\"].as_number().map(|n| {\n\t\t\tn.as_f64()\n\t\t\t\t.ok_or(\"diversity_factor must be a 64-bit floating point number\")\n\t\t});\n\t\tlet trip_context = input.get(\"trip_context\").cloned().unwrap_or(json!({}));\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tpois_count = pois.len(),\n\t\t\tdiversity_factor = diversity_factor.unwrap_or(Ok(0.7)).unwrap_or(0.7),\n\t\t\t\"Drafting itinerary from POIs\"\n\t\t);\n\n\t\tlet prompt = format!(\n\t\t\tinclude_str!(\"../prompts/draft_itinerary.md\"),\n\t\t\tserde_json::to_string_pretty(\u0026pois)?,\n\t\t\tinclude_str!(\"../prompts/itinerary.ts\"),\n\t\t\tdiversity_factor.unwrap_or(Ok(0.7))?,\n\t\t\tserde_json::to_string_pretty(\u0026trip_context)?\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, pois_count={}\", elapsed.as_millis(), pois.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tpois_count = pois.len(),\n\t\t\t\"Itinerary draft completed\"\n\t\t);\n\n\t\tOk(response.trim().to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for OptimizeRouteTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"optimize_route\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Optimizes the order of POIs for a day to minimize travel time and distance using Traveling Salesman Problem algorithms. Returns the most efficient route. Input must be a single array of events, and the output will be that array sorted to optimize for shortest routes between events.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"day_pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects for a single day with location data. Should not include start_location or end_location.\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\"id\": {\"type\": \"string\"},\n\t\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"start_location\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"Starting location (e.g., hotel)\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"end_location\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"Ending location (optional, defaults to start_location)\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"day_pois\", \"start_location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tuse super::tsp::{EndpointMode, Pt, compute_route};\n\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"optimize_route\",\n\t\t\t\"Starting route optimization\"\n\t\t);\n\n\t\tlet mut pois = input[\"day_pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"day_pois must be an array of objects\")?\n\t\t\t.iter()\n\t\t\t.map(|poi| {\n\t\t\t\tlet poi = poi\n\t\t\t\t\t.as_object()\n\t\t\t\t\t.ok_or(\"day_pois must be an array of objects\")?;\n\t\t\t\tOk(Pt {\n\t\t\t\t\tid: Some(poi[\"id\"].as_str().ok_or(\"id must be a string\")?),\n\t\t\t\t\tlat: poi[\"latitude\"]\n\t\t\t\t\t\t.as_number()\n\t\t\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t\t\t.as_f64()\n\t\t\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\t\t\tlng: poi[\"longitude\"]\n\t\t\t\t\t\t.as_number()\n\t\t\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t\t\t.as_f64()\n\t\t\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect::\u003cResult\u003cVec\u003cPt\u003e, \u0026str\u003e\u003e()?;\n\n\t\tlet start = input[\"start_location\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"start_location must be an object\")?;\n\t\tlet start = Pt {\n\t\t\tid: None,\n\t\t\tlat: start[\"latitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\tlng: start[\"longitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t};\n\n\t\tpois.insert(0, start);\n\n\t\tif input[\"end_location\"].is_null() {\n\t\t\tpois = compute_route(pois.as_slice(), EndpointMode::Circle)\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|i| pois[i])\n\t\t\t\t.collect();\n\t\t\treturn Ok(json!(pois).to_string());\n\t\t}\n\n\t\tlet end = input[\"end_location\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"end_location must be an object\")?;\n\t\tlet end = Pt {\n\t\t\tid: None,\n\t\t\tlat: end[\"latitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\tlng: end[\"longitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t};\n\n\t\tif start.lat == end.lat \u0026\u0026 start.lng == end.lng {\n\t\t\tpois = compute_route(pois.as_slice(), EndpointMode::Circle)\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|i| pois[i])\n\t\t\t\t.collect();\n\t\t\treturn Ok(json!(pois).to_string());\n\t\t}\n\n\t\tpois.push(end);\n\n\t\tpois = compute_route(pois.as_slice(), EndpointMode::Path)\n\t\t\t.into_iter()\n\t\t\t.map(|i| pois[i])\n\t\t\t.collect();\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}\", elapsed.as_millis())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Route optimization completed\"\n\t\t);\n\n\t\tOk(json!(pois).to_string())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","orchestrator.rs"],"content":"/*\n * src/agent/tools/orchestrator.rs\n *\n * Orchestrator Agent Tools Implementation - LLM-based extraction\n *\n * IMPORTANT: Tool Parameter Schema Pattern\n * ========================================\n * For parameters that can be objects/arrays, ALWAYS use \"type\": \"string\" in the schema.\n * Do NOT use \"anyOf\" or omit the type - langchain_rust 4.6.0 has a validation bug\n * that causes \"invalid type: map, expected a string\" errors during agent planning.\n *\n * Pattern to follow:\n * 1. Schema: Use \"type\": \"string\" for flexible parameters (objects/arrays)\n * 2. Description: Explicitly instruct LLM to pass JSON as strings\n * 3. Run method: Parse strings as JSON, but handle objects/arrays as fallback\n *\n * Example (see ask_for_clarification tool):\n *   \"missing_info\": {\n *     \"type\": \"string\",  // NOT \"anyOf\" or no type!\n *     \"description\": \"...as a JSON string. Example: '[\\\"item\\\"]'\"\n *   }\n *\n * This allows langchain_rust validation to pass while still accepting\n * whatever format the LLM generates (we handle both in run()).\n */\n\nuse crate::agent::models::context::{ContextData, SharedContextStore, ToolExecution};\nuse crate::agent::tools::task::RespondToUserTool;\nuse crate::sql_models::LlmProgress;\nuse async_trait::async_trait;\nuse langchain_rust::chain::Chain;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse tokio::sync::Mutex;\nuse tracing::{debug, error, info};\n\n/// Helper function to automatically track tool executions in context.\n/// This is called by every tool to record its execution in the tool_history.\n///\n/// Marked pub(crate) so it can be reused by Task tools without exposing it outside\n/// the agent tools module.\npub(crate) async fn track_tool_execution(\n\t_context_store: \u0026SharedContextStore,\n\tchat_session_id: \u0026Arc\u003cAtomicI32\u003e,\n\ttool_name: \u0026str,\n\tinput: \u0026Value,\n\toutput: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n\tlet chat_id = chat_session_id.load(Ordering::Relaxed);\n\tif chat_id == 0 {\n\t\t// If chat_session_id is not set, we're probably in a test or the tool is being called outside the agent context\n\t\treturn Ok(());\n\t}\n\n\t// Get existing in-memory context (should exist from controller initialization)\n\tlet mut store_guard = _context_store.write().await;\n\tlet context_data = match store_guard.get_mut(\u0026chat_id) {\n\t\tSome(ctx) =\u003e ctx,\n\t\tNone =\u003e {\n\t\t\t// Context doesn't exist - this shouldn't happen in normal flow\n\t\t\t// but create it to be safe\n\t\t\tstore_guard.insert(\n\t\t\t\tchat_id,\n\t\t\t\tContextData {\n\t\t\t\t\tchat_session_id: chat_id,\n\t\t\t\t\tuser_id: 0, // Unknown\n\t\t\t\t\tuser_profile: None,\n\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\tevents: vec![],\n\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\tconstraints: vec![],\n\t\t\t\t},\n\t\t\t);\n\t\t\tstore_guard.get_mut(\u0026chat_id).unwrap()\n\t\t}\n\t};\n\n\t// Add tool execution to history\n\tlet tool_exec = ToolExecution {\n\t\ttool_name: tool_name.to_string(),\n\t\tinput: input.clone(),\n\t\toutput: serde_json::from_str(output).unwrap_or_else(|_| json!(output)),\n\t\ttimestamp: chrono::Utc::now().to_rfc3339(),\n\t\tsuccess: true, // Assume success if the tool is calling this function\n\t};\n\n\tcontext_data.tool_history.push(tool_exec);\n\n\t// Keep only last 100 entries\n\tif context_data.tool_history.len() \u003e 100 {\n\t\tcontext_data.tool_history.remove(0);\n\t}\n\n\tdebug!(\n\t\ttarget: \"orchestrator_tool\",\n\t\ttool = tool_name,\n\t\tchat_id = chat_id,\n\t\ttool_history_count = context_data.tool_history.len(),\n\t\t\"Tracked tool execution\"\n\t);\n\n\tOk(())\n}\n\n#[derive(Clone)]\npub struct RouteTaskTool {\n\tpub task_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub research_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub constraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub optimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RouteTaskTool {\n\tpub fn new(\n\t\ttask_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tresearch_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tconstraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\toptimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\ttask_agent,\n\t\t\tresearch_agent,\n\t\t\tconstraint_agent,\n\t\t\toptimize_agent,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n/// Tool 4: Route Task to Sub-Agent\n/// Routes a task to the appropriate sub-agent (research, constraint, or optimize).\n/// Returns a TaskRoute object.\n#[async_trait]\nimpl Tool for RouteTaskTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"route_task\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Routes a task to the appropriate sub-agent (research, constraint, or optimize). IMPORTANT: All parameters must be passed as strings. For 'payload', pass the JSON object as a JSON string.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"task_type\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"enum\": [\"task\", \"research\", \"constraint\", \"optimize\"],\n\t\t\t\t\t\"description\": \"The type of task to route: 'task' (Task Agent for context building), 'research', 'constraint', or 'optimize'\"\n\t\t\t\t},\n\t\t\t\t\"payload\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The data to send to the sub-agent as a JSON string. If you have an object, serialize it to JSON first.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"task_type\", \"payload\"]\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in route_task\"\n\t\t);\n\n\t\t// langchain_rust passes action_input as a STRING, so parse it first if needed\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| {\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\ttool = \"route_task\",\n\t\t\t\t\t\"Failed to parse input as JSON, using as-is\"\n\t\t\t\t);\n\t\t\t\tinput.clone()\n\t\t\t})\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle task_type - prefer simple string, but be defensive about weird shapes\n\t\t//\n\t\t// In theory the LLM should always pass a plain string (\\\"task\\\", \\\"research\\\", etc.)\n\t\t// but in practice we have seen cases in logs where this ended up as \\\"null\\\"\n\t\t// and caused `Unknown task type: null` errors, preventing the Task Agent from running.\n\t\t//\n\t\t// Strategy:\n\t\t// - If we can read a string, use it directly.\n\t\t// - If it's an object, look for common fields (`value`, `task_type`).\n\t\t// - If it's missing / null / empty, *default to \\\"task\\\"* so first-turn\n\t\t//   orchestration still calls the Task Agent instead of hard failing.\n\t\tlet raw_task_type_value = \u0026parsed_input[\"task_type\"];\n\n\t\tlet mut task_type = if let Some(s) = raw_task_type_value.as_str() {\n\t\t\ts.to_string()\n\t\t} else if raw_task_type_value.is_object() {\n\t\t\traw_task_type_value\n\t\t\t\t.get(\"value\")\n\t\t\t\t.or_else(|| raw_task_type_value.get(\"task_type\"))\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t.unwrap_or_else(|| raw_task_type_value.to_string())\n\t\t} else if raw_task_type_value.is_null() {\n\t\t\t// This is the problematic case we've seen in logs; default to \\\"task\\\"\n\t\t\t\"task\".to_string()\n\t\t} else {\n\t\t\traw_task_type_value.to_string()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\traw_task_type = %serde_json::to_string(\u0026raw_task_type_value)?,\n\t\t\tparsed_task_type = %task_type,\n\t\t\t\"Parsed task_type from input\"\n\t\t);\n\n\t\t// Handle payload - can be string (JSON), object, or already a string\n\t\tlet payload_str = if let Some(s) = parsed_input[\"payload\"].as_str() {\n\t\t\t// If it's a string, check if it's valid JSON, otherwise use as-is\n\t\t\tif serde_json::from_str::\u003cValue\u003e(s).is_ok() {\n\t\t\t\ts.to_string()\n\t\t\t} else {\n\t\t\t\ts.to_string()\n\t\t\t}\n\t\t} else if parsed_input[\"payload\"].is_object() {\n\t\t\t// If it's an object, serialize it to string\n\t\t\tserde_json::to_string(\u0026parsed_input[\"payload\"])?\n\t\t} else {\n\t\t\t// Fallback: convert to string representation\n\t\t\tparsed_input[\"payload\"].to_string()\n\t\t};\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\ttask_type = task_type,\n\t\t\t\"Routing task to sub-agent\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tinput = %serde_json::to_string(\u0026parsed_input)?,\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Normalize task_type to lowercase string and handle degenerate values\n\t\tlet mut task_type_normalized = task_type.to_lowercase().trim().to_string();\n\n\t\t// If the normalized value is empty or literally \\\"null\\\", treat it as \\\"task\\\"\n\t\t// so that we still invoke the Task Agent instead of erroring.\n\t\tif task_type_normalized.is_empty() || task_type_normalized == \"null\" {\n\t\t\tdebug!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"route_task\",\n\t\t\t\traw_task_type = %raw_task_type_value,\n\t\t\t\t\"task_type was empty or 'null'; defaulting to 'task'\"\n\t\t\t);\n\t\t\ttask_type_normalized = \"task\".to_string();\n\t\t\ttask_type = \"task\".to_string();\n\t\t}\n\n\t\t// Tool trace logging\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"orchestrator\",\n\t\t\ttool: \"route_task\",\n\t\t\tstatus: \"start\",\n\t\t\tdetails: format!(\"task_type={}\", task_type)\n\t\t);\n\n\t\t// Update LLM progress status in database BEFORE processing\n\t\tif let Some(progress) = match task_type_normalized.as_str() {\n\t\t\t\"research\" =\u003e Some(LlmProgress::Searching),\n\t\t\t\"constraint\" =\u003e Some(LlmProgress::Filtering),\n\t\t\t\"optimize\" =\u003e Some(LlmProgress::Optimizing),\n\t\t\t\"task\" =\u003e Some(LlmProgress::Scheduling),\n\t\t\t_ =\u003e None,\n\t\t} {\n\t\t\tlet chat_session_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tinfo!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, progress = ?progress, \"Updating LLM progress\");\n\n\t\t\tmatch sqlx::query!(\n\t\t\t\tr#\"UPDATE chat_sessions\n\t\t\t\tSET llm_progress=$1\n\t\t\t\tWHERE id=$2;\"#,\n\t\t\t\tprogress as _,\n\t\t\t\tchat_session_id\n\t\t\t)\n\t\t\t.execute(\u0026self.pool)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(result) =\u003e {\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, rows_affected = result.rows_affected(), \"LLM progress updated successfully\");\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\terror!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, error = %e, \"Failed to update LLM progress\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// SPECIAL HANDLING: High-level Task Agent\n\t\t//\n\t\t// When task_type == \"task\", we want to delegate the entire planning pipeline\n\t\t// to the Task Agent and propagate its raw string output back to the controller.\n\t\t// This preserves markers like \"MESSAGE_INSERTED:\" and \"FINAL_ANSWER:\" so that\n\t\t// `send_message_to_llm` can handle them as before.\n\t\tif task_type_normalized == \"task\" {\n\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"begin\", status: \"invoked\");\n\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", \"Invoking task agent\");\n\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"task\", payload = %payload_str, \"Agent input\");\n\n\t\t\tlet agent_outer = self.task_agent.lock().await;\n\t\t\tlet agent_inner = agent_outer.lock().await;\n\n\t\t\tlet response = match agent_inner\n\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t})\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"complete\", status: \"success\");\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", status = \"completed\", \"Task agent completed\");\n\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"task\", response = %response, \"Task agent raw output\");\n\t\t\t\t\tresponse\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", status = \"error\", error = %e, \"Task agent error\");\n\t\t\t\t\tformat!(\"TASK_AGENT_ERROR: {}\", e)\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Track this tool execution with a JSON wrapper for observability,\n\t\t\t// but return the raw response string so the controller can interpret it.\n\t\t\tlet tracking_value = json!({\n\t\t\t\t\"agent\": \"task\",\n\t\t\t\t\"status\": if response.starts_with(\"TASK_AGENT_ERROR:\") { \"error\" } else { \"completed\" },\n\t\t\t\t\"raw\": response,\n\t\t\t});\n\t\t\tlet tracking_str = serde_json::to_string(\u0026tracking_value)?;\n\n\t\t\ttrack_tool_execution(\n\t\t\t\t\u0026self.context_store,\n\t\t\t\t\u0026self.chat_session_id,\n\t\t\t\t\"route_task\",\n\t\t\t\t\u0026input_clone,\n\t\t\t\t\u0026tracking_str,\n\t\t\t)\n\t\t\t.await?;\n\n\t\t\treturn Ok(response);\n\t\t}\n\n\t\t// For research/constraint/optimize agents, inject context from context_store\n\t\tlet payload_str = if task_type_normalized == \"research\" {\n\t\t\t// Research gets the current trip_context snapshot\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\tlet trip_context_json = serde_json::to_string(\u0026context_data.trip_context)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"research\",\n\t\t\t\t\t\t\"Injecting trip context into payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\ttrip_context = %trip_context_json,\n\t\t\t\t\t\t\"Trip context being passed to research agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\ttrip_context_json\n\t\t\t\t} else {\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else if task_type_normalized == \"constraint\" {\n\t\t\t// Constraint gets both trip context and the latest research results\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\t// Find latest successful research result from tool_history\n\t\t\t\t\tlet mut research_data: Value = json!(null);\n\t\t\t\t\tfor exec in context_data.tool_history.iter().rev() {\n\t\t\t\t\t\tif exec.tool_name == \"route_task\" {\n\t\t\t\t\t\t\tif let Some(agent) = exec.output.get(\"agent\").and_then(|v| v.as_str()) {\n\t\t\t\t\t\t\t\tif agent == \"research\" {\n\t\t\t\t\t\t\t\t\tif exec.output.get(\"status\").and_then(|v| v.as_str())\n\t\t\t\t\t\t\t\t\t\t== Some(\"completed\")\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tresearch_data =\n\t\t\t\t\t\t\t\t\t\t\texec.output.get(\"data\").cloned().unwrap_or(json!(null));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extract event_ids from research data\n\t\t\t\t\tlet event_ids = if let Some(ids) = research_data.get(\"event_ids\") {\n\t\t\t\t\t\tids.clone()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Research data might be wrapped differently\n\t\t\t\t\t\tjson!([])\n\t\t\t\t\t};\n\n\t\t\t\t\tlet constraint_payload = json!({\n\t\t\t\t\t\t\"trip_context\": \u0026context_data.trip_context,\n\t\t\t\t\t\t\"constraints\": \u0026context_data.constraints,\n\t\t\t\t\t\t\"event_ids\": event_ids\n\t\t\t\t\t});\n\n\t\t\t\t\tlet payload_json = serde_json::to_string(\u0026constraint_payload)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"constraint\",\n\t\t\t\t\t\t\"Injecting trip context and research results into constraint payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tpayload = %payload_json,\n\t\t\t\t\t\t\"Constraint payload being passed to agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\tpayload_json\n\t\t\t\t} else {\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else if task_type_normalized == \"optimize\" {\n\t\t\t// Optimize gets trip context, user profile, and constraint results\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tdebug!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tagent = \"optimize\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\t\"Building optimize payload from context\"\n\t\t\t);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\ttool_history_count = context_data.tool_history.len(),\n\t\t\t\t\t\t\"Found context data with tool history\"\n\t\t\t\t\t);\n\t\t\t\t\t// Find latest successful constraint result from tool_history\n\t\t\t\t\tlet mut constraint_data: Value = json!(null);\n\t\t\t\t\tfor exec in context_data.tool_history.iter().rev() {\n\t\t\t\t\t\tif exec.tool_name == \"route_task\" {\n\t\t\t\t\t\t\tif let Some(agent) = exec.output.get(\"agent\").and_then(|v| v.as_str()) {\n\t\t\t\t\t\t\t\tif agent == \"constraint\" {\n\t\t\t\t\t\t\t\t\tif exec.output.get(\"status\").and_then(|v| v.as_str())\n\t\t\t\t\t\t\t\t\t\t== Some(\"completed\")\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconstraint_data =\n\t\t\t\t\t\t\t\t\t\t\texec.output.get(\"data\").cloned().unwrap_or(json!(null));\n\t\t\t\t\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\t\t\t\t\tconstraint_data = %serde_json::to_string(\u0026constraint_data).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\t\t\t\t\t\"Found constraint result in tool_history\"\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extract filtered_event_ids from constraint result\n\t\t\t\t\t// Handle multiple possible structures:\n\t\t\t\t\t// 1. Direct: {\"filtered_event_ids\": [...]}\n\t\t\t\t\t// 2. Wrapped in raw string: {\"raw\": \"{\\\"filtered_event_ids\\\":[...]}\"}\n\t\t\t\t\tlet filtered_ids = if let Some(ids) = constraint_data.get(\"filtered_event_ids\")\n\t\t\t\t\t{\n\t\t\t\t\t\tids.clone()\n\t\t\t\t\t} else if let Some(raw) = constraint_data.get(\"raw\") {\n\t\t\t\t\t\t// Parse the raw string\n\t\t\t\t\t\tif let Some(raw_str) = raw.as_str() {\n\t\t\t\t\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cValue\u003e(raw_str) {\n\t\t\t\t\t\t\t\tparsed\n\t\t\t\t\t\t\t\t\t.get(\"filtered_event_ids\")\n\t\t\t\t\t\t\t\t\t.cloned()\n\t\t\t\t\t\t\t\t\t.unwrap_or(json!([]))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if constraint_data.is_string() {\n\t\t\t\t\t\t// Parse constraint result if it's a string itself\n\t\t\t\t\t\tlet constraint_str = constraint_data.as_str().unwrap_or(\"{}\");\n\t\t\t\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cValue\u003e(constraint_str) {\n\t\t\t\t\t\t\tparsed\n\t\t\t\t\t\t\t\t.get(\"filtered_event_ids\")\n\t\t\t\t\t\t\t\t.cloned()\n\t\t\t\t\t\t\t\t.unwrap_or(json!([]))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson!([])\n\t\t\t\t\t};\n\n\t\t\t\t\t// Log what we extracted for debugging\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\tfiltered_ids = %serde_json::to_string(\u0026filtered_ids).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\"Extracted filtered_event_ids from constraint result\"\n\t\t\t\t\t);\n\n\t\t\t\t\tlet optimize_payload = json!({\n\t\t\t\t\t\t\"trip_context\": \u0026context_data.trip_context,\n\t\t\t\t\t\t\"user_profile\": \u0026context_data.user_profile,\n\t\t\t\t\t\t\"filtered_event_ids\": filtered_ids\n\t\t\t\t\t});\n\n\t\t\t\t\tlet payload_json = serde_json::to_string(\u0026optimize_payload)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\"Injecting trip context, user profile, and constraint results into optimize payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tpayload = %payload_json,\n\t\t\t\t\t\t\"Optimize payload being passed to agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\tpayload_json\n\t\t\t\t} else {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\t\"No context data found for chat_id, using original payload\"\n\t\t\t\t\t);\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\"chat_id is 0, using original payload\"\n\t\t\t\t);\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else {\n\t\t\tpayload_str\n\t\t};\n\n\t\tlet result = match task_type_normalized.as_str() {\n\t\t\t\"research\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", \"Invoking research agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"research\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.research_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\t// Parse response as JSON Value if possible\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", status = \"completed\", \"Research agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"research\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"research\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", status = \"error\", error = %e, \"Research agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"research\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\"constraint\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", \"Invoking constraint agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"constraint\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.constraint_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\tagent = \"constraint\",\n\t\t\t\t\t\t\traw_response = %response,\n\t\t\t\t\t\t\t\"Constraint agent raw response before parsing\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", status = \"completed\", \"Constraint agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"constraint\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"constraint\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", status = \"error\", error = %e, \"Constraint agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"constraint\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\"optimize\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", \"Invoking optimize agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"optimize\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.optimize_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\traw_response = %response,\n\t\t\t\t\t\t\t\"Optimize agent raw response before parsing\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\t// Store the complete itinerary in active_itinerary context\n\t\t\t\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\t\t\t\tif chat_id \u003e 0 {\n\t\t\t\t\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\t\t\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\t\t\t\t\tcontext_data.active_itinerary = Some(data.clone());\n\t\t\t\t\t\t\t\tinfo!(\n\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\t\t\t\"Stored itinerary in active_itinerary context\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\titinerary = %serde_json::to_string(\u0026data).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\t\t\t\"Itinerary stored in context\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", status = \"completed\", \"Optimize agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"optimize\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"optimize\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", status = \"error\", error = %e, \"Optimize agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"optimize\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t_ =\u003e {\n\t\t\t\treturn Err(format!(\"Unknown task type: {}\", task_type).into());\n\t\t\t}\n\t\t};\n\n\t\tlet result_str = serde_json::to_string(\u0026result)?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\ttask_type = task_type,\n\t\t\tstatus = result.get(\"status\").and_then(|s| s.as_str()).unwrap_or(\"unknown\"),\n\t\t\t\"Task routing completed\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tresult = %result_str,\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"route_task\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result_str,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result_str)\n\t}\n}\n\n/// Gets all the orchestrator tools.\n/// Returns a vector of Arc\u003cdyn Tool\u003e objects.\n/// chat_session_id and user_id are shared across tools that need them and can be updated per request.\npub fn get_orchestrator_tools(\n\t_llm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\ttask_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tresearch_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tconstraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\toptimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t_user_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![\n\t\tArc::new(RouteTaskTool::new(\n\t\t\ttask_agent,\n\t\t\tresearch_agent,\n\t\t\tconstraint_agent,\n\t\t\toptimize_agent,\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RespondToUserTool::new(pool, chat_session_id, context_store)),\n\t\t// Note: context-building tools (profile, chat history, intent, clarification)\n\t\t// are exposed via the Task Agent through `get_task_tools` and should not be\n\t\t// called directly by the Orchestrator.\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","research.rs"],"content":"/*\n * src/agent/tools/research.rs\n *\n * File for Reseearch Agent Tools\n *\n * Purpose:\n *   Store Research Agent Tools\n */\n\nuse async_trait::async_trait;\nuse google_maps::places_new::{Field, FieldMask, PlaceType};\nuse langchain_rust::tools::Tool;\nuse serde::{Deserialize, de::IntoDeserializer};\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse sqlx::prelude::FromRow;\nuse std::time::Instant;\nuse std::{error::Error, sync::Arc};\nuse tracing::{debug, info};\n\nuse crate::{global::GOOGLE_MAPS_API_KEY, http_models::event::Event};\n\npub fn research_tools(db: PgPool) -\u003e [Arc\u003cdyn Tool\u003e; 2] {\n\t[\n\t\tArc::new(GeocodeTool),\n\t\t// Arc::new(QueryDbEventsTool { db: db.clone() }),\n\t\tArc::new(NearbySearchTool { db }),\n\t]\n}\n\n/// This tool takes an address and converts it into coordinates using Google Maps Geocoding API.\n#[derive(Clone)]\nstruct GeocodeTool;\n\n/// This tool queries the DB for events that may be relevant to the itinerary being generated.\n#[derive(Clone)]\n#[allow(dead_code)]\nstruct QueryDbEventsTool {\n\tpub db: PgPool,\n}\n\n/// This tool uses Google Maps Nearby Search to fetch a list of places in a given area with certain input criteria.\n/// The resulting events are inserted or updated in the database.\n#[derive(Clone)]\nstruct NearbySearchTool {\n\tpub db: PgPool,\n}\n\n#[async_trait]\nimpl Tool for GeocodeTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"geocode_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that takes an address or location and converts it into coordinates using Google Maps Geocoding API.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"location\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The street address that you want to geocode, in the format used by the national postal service of the country concerned. Additional address elements such as business names and unit, suite or floor numbers hould be avoided. The street will likely not always be provided, but city should almost always be expected.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(agent: \"research\", tool: \"geocode_tool\", status: \"start\");\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\t\"Starting geocoding\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// langchain-rust passes `action_input` as a STRING, but the LLM may:\n\t\t// - pass a plain text location like \"Connecticut\"\n\t\t// - pass a JSON string like \"{\\\"location\\\":\\\"Connecticut\\\"}\"\n\t\t// - or pass an object with `location` or `destination` fields.\n\t\t//\n\t\t// Normalize all of these into a single `location` string.\n\t\tlet location: String = if input.is_string() {\n\t\t\tlet raw = input.as_str().unwrap_or(\"\").trim();\n\n\t\t\tif raw.is_empty() {\n\t\t\t\treturn Err(\"Location is required\".into());\n\t\t\t}\n\n\t\t\tif raw.starts_with('{') || raw.starts_with('[') {\n\t\t\t\tlet v: Value =\n\t\t\t\t\tserde_json::from_str(raw).unwrap_or_else(|_| json!({ \"location\": raw }));\n\n\t\t\t\tv.get(\"location\")\n\t\t\t\t\t.or_else(|| v.get(\"destination\"))\n\t\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t\t.ok_or(\"Location or destination field should be a string\")?\n\t\t\t\t\t.to_string()\n\t\t\t} else {\n\t\t\t\traw.to_string()\n\t\t\t}\n\t\t} else {\n\t\t\tinput\n\t\t\t\t.get(\"location\")\n\t\t\t\t.or_else(|| input.get(\"destination\"))\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.ok_or(\"Location or destination field should be a string\")?\n\t\t\t\t.to_string()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tlocation = %location,\n\t\t\t\"Geocoding location\"\n\t\t);\n\n\t\tdotenvy::dotenv().map_err(|_| \"Failed to load environment variables\")?;\n\t\tlet gm_api_key =\n\t\t\tstd::env::var(GOOGLE_MAPS_API_KEY).map_err(|_| \"GOOGLE_MAPS_API_KEY is not set\")?;\n\n\t\t// use google maps api to get the address from the provided location and use geocoding to get its coordinates\n\t\tlet gm_client = google_maps::Client::try_new(gm_api_key)\n\t\t\t.map_err(|_| \"Failed to create client for Google Maps API\")?;\n\t\tlet geocode_res = gm_client\n\t\t\t.geocoding()\n\t\t\t.with_address(\u0026location)\n\t\t\t.execute()\n\t\t\t.await?;\n\t\tif let Some(err) = geocode_res.error_message {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - Geocoding API error: {}\", elapsed.as_millis(), err)\n\t\t\t);\n\t\t\treturn Err(format!(\n\t\t\t\t\"Geocoding failed with status {} - {err}\",\n\t\t\t\tgeocode_res.status\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\t\tif !matches!(geocode_res.status, google_maps::geocoding::Status::Ok) {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - Bad status: {}\", elapsed.as_millis(), geocode_res.status)\n\t\t\t);\n\t\t\treturn Err(format!(\"Geocoding failed with status {}\", geocode_res.status).into());\n\t\t}\n\t\tif geocode_res.results.is_empty() {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - No results\", elapsed.as_millis())\n\t\t\t);\n\t\t\treturn Err(format!(\"Geocoding could not get coordinates for {location}\").into());\n\t\t}\n\n\t\tlet result = json!({\n\t\t\t\"lat\": geocode_res.results[0].geometry.location.lat,\n\t\t\t\"lng\": geocode_res.results[0].geometry.location.lng\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tlat = %geocode_res.results[0].geometry.location.lat,\n\t\t\tlng = %geocode_res.results[0].geometry.location.lng,\n\t\t\t\"Geocoding completed successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tresult = %result.to_string(),\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"research\",\n\t\t\ttool: \"geocode_tool\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{}ms\", elapsed.as_millis())\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for QueryDbEventsTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"query_db_events_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that queries the DB for events that may be relevant to the itinerary being generated.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"location\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"A location in the world from the user's prompt; ideally a city name or postal code, but could be anything that indicates a place like a street address or country.\"\n\t\t\t\t},\n\t\t\t\t\"keywords\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of keywords from the user's prompt that can be used to search for relevant events.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\t// TODO create filters and query the db for possibly relevant events\n\n\t\tlet name = input[\"name\"].as_str().ok_or(\"Name should be a string\")?;\n\t\tOk(format!(\"Hello, {}! Welcome to our AI assistant.\", name))\n\t}\n}\n\n#[async_trait]\nimpl\u003c'db\u003e Tool for NearbySearchTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"nearby_search_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that uses Google Maps Nearby Search to fetch a list of places in a given area with certain input criteria. The resulting events are inserted or updated in the database and their IDs are returned. Returns a JSON object with 'event_ids' (array of integer IDs) and 'count' (number of events found).\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"lat\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"The lattitude of the target location.\"\n\t\t\t\t},\n\t\t\t\t\"lng\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"The longitude of the target location.\"\n\t\t\t\t},\n\t\t\t\t\"includedTypes\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of places types to include.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t},\n\t\t\t\t\"excludedTypes\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of places types to exclude.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t},\n\t\t\t\t\"cities\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of strings representing cities the user would like to travel to. If a list of cities cannot be interpreted from the user's prompt, this must be an empty array. Cities could be obtained directly from the user's prompt or by using neighboring cities that weren't mentioned.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"},\n\t\t\t\t\t\"default\": []\n\t\t\t\t},\n\t\t\t\t\"country\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The country the user would like to travel to.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"lat\", \"lng\", \"cities\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(agent: \"research\", tool: \"nearby_search_tool\", status: \"start\");\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\"Starting nearby search\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// langchain-rust usually passes `action_input` as a STRING. Normalize it:\n\t\t// - If it's a JSON string, parse it into an object.\n\t\t// - If it's a plain string, treat it as a \"lat,lng\" location string.\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tlet raw = input.as_str().unwrap_or(\"\").trim();\n\t\t\tif raw.starts_with('{') || raw.starts_with('[') {\n\t\t\t\tserde_json::from_str(raw).unwrap_or_else(|_| json!({ \"location\": raw }))\n\t\t\t} else {\n\t\t\t\tjson!({ \"location\": raw })\n\t\t\t}\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Handle multiple input formats:\n\t\t// 1. Combined \"location\" field as \"lat,lng\" string\n\t\t// 2. \"location\" field as object with lat/lng properties\n\t\t// 3. Separate lat/lng fields (as numbers or strings)\n\t\tlet (lat, lng) = if let Some(location_val) = parsed_input.get(\"location\") {\n\t\t\tdebug!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\tlocation_val = %location_val,\n\t\t\t\t\"Processing location field\"\n\t\t\t);\n\n\t\t\t// Check if location is an object with lat/lng properties\n\t\t\tif location_val.is_object() {\n\t\t\t\tlet lat = if let Some(f) = location_val.get(\"lat\").and_then(|v| v.as_f64()) {\n\t\t\t\t\tf\n\t\t\t\t} else if let Some(s) = location_val.get(\"lat\").and_then(|v| v.as_str()) {\n\t\t\t\t\ts.parse::\u003cf64\u003e().map_err(|e| {\n\t\t\t\t\t\tformat!(\"lat in location object should be a valid number: {}\", e)\n\t\t\t\t\t})?\n\t\t\t\t} else {\n\t\t\t\t\treturn Err(\n\t\t\t\t\t\t\"location object must have a 'lat' field as a number or string\".into(),\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tlet lng = if let Some(f) = location_val.get(\"lng\").and_then(|v| v.as_f64()) {\n\t\t\t\t\tf\n\t\t\t\t} else if let Some(s) = location_val.get(\"lng\").and_then(|v| v.as_str()) {\n\t\t\t\t\ts.parse::\u003cf64\u003e().map_err(|e| {\n\t\t\t\t\t\tformat!(\"lng in location object should be a valid number: {}\", e)\n\t\t\t\t\t})?\n\t\t\t\t} else {\n\t\t\t\t\treturn Err(\n\t\t\t\t\t\t\"location object must have a 'lng' field as a number or string\".into(),\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t(lat, lng)\n\t\t\t} else if let Some(location_str) = location_val.as_str() {\n\t\t\t\t// Parse from \"location\" field as \"lat,lng\" string\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\tlocation = %location_str,\n\t\t\t\t\t\"Parsing location string\"\n\t\t\t\t);\n\n\t\t\t\tlet parts: Vec\u003c\u0026str\u003e = location_str.split(',').collect();\n\t\t\t\tif parts.len() != 2 {\n\t\t\t\t\treturn Err(\"location string should be in format 'lat,lng'\".into());\n\t\t\t\t}\n\t\t\t\tlet lat = parts[0]\n\t\t\t\t\t.trim()\n\t\t\t\t\t.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"Invalid latitude in location string: {}\", e))?;\n\t\t\t\tlet lng = parts[1]\n\t\t\t\t\t.trim()\n\t\t\t\t\t.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"Invalid longitude in location string: {}\", e))?;\n\t\t\t\t(lat, lng)\n\t\t\t} else {\n\t\t\t\treturn Err(\"location field should be either a string in format 'lat,lng' or an object with lat/lng properties\".into());\n\t\t\t}\n\t\t} else {\n\t\t\t// Parse from separate lat/lng fields\n\t\t\tdebug!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\"No location field, looking for separate lat/lng fields\"\n\t\t\t);\n\n\t\t\tlet lat = if let Some(f) = parsed_input.get(\"lat\").and_then(|v| v.as_f64()) {\n\t\t\t\tf\n\t\t\t} else if let Some(s) = parsed_input.get(\"lat\").and_then(|v| v.as_str()) {\n\t\t\t\ts.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"lat should be a valid number: {}\", e))?\n\t\t\t} else {\n\t\t\t\treturn Err(\"lat should be a 64-bit floating point number\".into());\n\t\t\t};\n\n\t\t\tlet lng = if let Some(f) = parsed_input.get(\"lng\").and_then(|v| v.as_f64()) {\n\t\t\t\tf\n\t\t\t} else if let Some(s) = parsed_input.get(\"lng\").and_then(|v| v.as_str()) {\n\t\t\t\ts.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"lng should be a valid number: {}\", e))?\n\t\t\t} else {\n\t\t\t\treturn Err(\"lng should be a 64-bit floating point number\".into());\n\t\t\t};\n\t\t\t(lat, lng)\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tlat = lat,\n\t\t\tlng = lng,\n\t\t\t\"Search coordinates\"\n\t\t);\n\n\t\tlet cities = parsed_input[\"cities\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"cities should be an array of strings\")?\n\t\t\t.into_iter()\n\t\t\t.map(|v| v.as_str().ok_or(\"cities should be an array of strings\"))\n\t\t\t.collect::\u003cResult\u003cVec\u003c\u0026str\u003e, \u0026str\u003e\u003e()?;\n\n\t\tconst INCLUDE_TYPES_ERR: \u0026str = \"includedTypes should be an array of strings\";\n\t\tconst EXCLUDE_TYPES_ERR: \u0026str = \"excludedTypes should be an array of strings\";\n\t\tlet included_types = if !parsed_input[\"includedTypes\"].is_null() {\n\t\t\tparsed_input[\"includedTypes\"]\n\t\t\t\t.as_array()\n\t\t\t\t.ok_or(INCLUDE_TYPES_ERR)?\n\t\t\t\t.iter()\n\t\t\t\t.map(|v| v.as_str().ok_or(INCLUDE_TYPES_ERR))\n\t\t\t\t.collect::\u003cResult\u003c_, _\u003e\u003e()\n\t\t\t\t.map_err(|_| INCLUDE_TYPES_ERR)?\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\t\tlet excluded_types = if !parsed_input[\"excludedTypes\"].is_null() {\n\t\t\tparsed_input[\"excludedTypes\"]\n\t\t\t\t.as_array()\n\t\t\t\t.ok_or(EXCLUDE_TYPES_ERR)?\n\t\t\t\t.iter()\n\t\t\t\t.map(|v| v.as_str().ok_or(EXCLUDE_TYPES_ERR))\n\t\t\t\t.collect::\u003cResult\u003c_, _\u003e\u003e()\n\t\t\t\t.map_err(|_| EXCLUDE_TYPES_ERR)?\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tincluded_types_count = included_types.len(),\n\t\t\texcluded_types_count = excluded_types.len(),\n\t\t\t\"Place type filters\"\n\t\t);\n\n\t\tdotenvy::dotenv().map_err(|_| \"Failed to load environment variables\")?;\n\t\tlet gm_api_key =\n\t\t\tstd::env::var(GOOGLE_MAPS_API_KEY).map_err(|_| \"GOOGLE_MAPS_API_KEY is not set\")?;\n\n\t\t// use google maps api to get nearby places\n\t\tlet gm_client = google_maps::Client::try_new(gm_api_key)\n\t\t\t.map_err(|_| \"Failed to create client for Google Maps API\")?;\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\"Calling Google Maps API\"\n\t\t);\n\n\t\t// Query DB and do nearby search concurrently\n\t\tlet nearby_search = async move |radius: f64| {\n\t\t\tlet search_res = gm_client\n\t\t\t\t.nearby_search((lat, lng, radius))\n\t\t\t\t.map_err(|e| e.to_string())?\n\t\t\t\t.field_mask(FieldMask::Specific(vec![\n\t\t\t\t\tField::PlacesAccessibilityOptions,\n\t\t\t\t\tField::PlacesAdrFormatAddress,\n\t\t\t\t\tField::PlacesDisplayName,\n\t\t\t\t\tField::PlacesId,\n\t\t\t\t\tField::PlacesPhotos,\n\t\t\t\t\tField::PlacesUtcOffsetMinutes,\n\t\t\t\t\tField::PlacesPriceLevel,\n\t\t\t\t\tField::PlacesRegularOpeningHours,\n\t\t\t\t\tField::PlacesWebsiteUri,\n\t\t\t\t\tField::PlacesServesVegetarianFood,\n\t\t\t\t\tField::PlacesTypes,\n\t\t\t\t\tField::PlacesPrimaryType,\n\t\t\t\t\tField::PlacesEditorialSummary,\n\t\t\t\t]))\n\t\t\t\t// pray to our lord and savior Terry Davis that this works\n\t\t\t\t.included_types(\n\t\t\t\t\tincluded_types\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|t| {\n\t\t\t\t\t\t\tPlaceType::deserialize(t.into_deserializer()).map_err(\n\t\t\t\t\t\t\t\t|_: serde::de::value::Error| \"Could not deserialize place type within includedTypes array\",\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n\t\t\t\t\t\t.map_err(|e| e.to_string())?,\n\t\t\t\t)\n\t\t\t\t.excluded_types(\n\t\t\t\t\texcluded_types\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|t| {\n\t\t\t\t\t\t\tPlaceType::deserialize(t.into_deserializer()).map_err(\n\t\t\t\t\t\t\t\t|_: serde::de::value::Error| \"Could not deserialize place type within excludedTypes array\",\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n\t\t\t\t\t\t.map_err(|e| e.to_string())?,\n\t\t\t\t)\n\t\t\t\t.execute()\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| e.to_string())?;\n\n\t\t\tif let Some(err) = search_res.error() {\n\t\t\t\tlet elapsed = start_time.elapsed();\n\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\tagent: \"research\",\n\t\t\t\t\ttool: \"nearby_search_tool\",\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tdetails: format!(\"{}ms - API error: {}\", elapsed.as_millis(), err)\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\terror = %err,\n\t\t\t\t\t\"Nearby search API error\"\n\t\t\t\t);\n\t\t\t\treturn Err(format!(\"Nearby Search failed - {err}\"));\n\t\t\t}\n\t\t\tlet places = search_res.places();\n\t\t\tif places.is_empty() {\n\t\t\t\tlet elapsed = start_time.elapsed();\n\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\tagent: \"research\",\n\t\t\t\t\ttool: \"nearby_search_tool\",\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tdetails: format!(\"{}ms - No places found\", elapsed.as_millis())\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\t\"No places found in nearby search\"\n\t\t\t\t);\n\t\t\t\treturn Err(format!(\"Nearby Search returned an empty array of places\").into());\n\t\t\t}\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\tplaces_count = places.len(),\n\t\t\t\t\"Found places from Google Maps\"\n\t\t\t);\n\t\t\tOk(places\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|p| Event::from(p))\n\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e())\n\t\t};\n\n\t\t// Define a struct to capture the RETURNING clause results\n\t\t#[derive(FromRow)]\n\t\tstruct EventInsertResult {\n\t\t\tid: i32,\n\t\t\tevent_name: String,\n\t\t}\n\n\t\tlet (mut nearby_search_events, db_query_events) =\n\t\t\tif let Some(country) = parsed_input[\"country\"].as_str() {\n\t\t\t\tlet db_query_task = async move {\n\t\t\t\t\tlet mut qb = sqlx::QueryBuilder::new(\n\t\t\t\t\t\t\"SELECT id, event_name FROM events WHERE country ILIKE \",\n\t\t\t\t\t);\n\t\t\t\t\tqb.push_bind(country);\n\t\t\t\t\tlet mut separated = qb.separated(\" OR \");\n\t\t\t\t\tfor city in cities {\n\t\t\t\t\t\t// Add \"%\" wildcards here if needed\n\t\t\t\t\t\tseparated.push(\"city ILIKE \");\n\t\t\t\t\t\tseparated.push_bind(format!(\"%{}%\", city));\n\t\t\t\t\t}\n\t\t\t\t\tlet query = qb.build_query_as::\u003cEventInsertResult\u003e();\n\t\t\t\t\tquery.fetch_all(\u0026self.db).await\n\t\t\t\t};\n\n\t\t\t\tlet (nearby_search_50, nearby_search_10, db_query_task) = tokio::join!(\n\t\t\t\t\tnearby_search(50_000.),\n\t\t\t\t\tnearby_search(10_000.),\n\t\t\t\t\tdb_query_task\n\t\t\t\t);\n\t\t\t\tlet mut nearby_searches = nearby_search_50?;\n\t\t\t\tnearby_searches.append(\u0026mut nearby_search_10?);\n\t\t\t\t(nearby_searches, db_query_task?)\n\t\t\t} else {\n\t\t\t\tlet (nearby_search_50, nearby_search_10) =\n\t\t\t\t\ttokio::join!(nearby_search(50_000.), nearby_search(10_000.));\n\t\t\t\tlet mut nearby_searches = nearby_search_50?;\n\t\t\t\tnearby_searches.append(\u0026mut nearby_search_10?);\n\t\t\t\tlet len = nearby_searches.len();\n\t\t\t\t(nearby_searches, Vec::with_capacity(len))\n\t\t\t};\n\n\t\tnearby_search_events.sort_unstable_by(|a, b| a.place_id.cmp(\u0026b.place_id));\n\t\tnearby_search_events.dedup_by(|a, b| a.place_id == b.place_id);\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tevents_to_insert = nearby_search_events.len(),\n\t\t\t\"Inserting/updating events in database\"\n\t\t);\n\n\t\t// Use query! macro for compile-time type checking\n\t\t// Insert events one by one to use the type-safe macro\n\t\tlet mut results: Vec\u003cEventInsertResult\u003e = db_query_events;\n\t\tresults.reserve(nearby_search_events.len());\n\n\t\tfor ev in nearby_search_events.iter() {\n\t\t\tlet result = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO events (\n\t\t\t\t\tevent_name,\n\t\t\t\t\tevent_description,\n\t\t\t\t\tstreet_address,\n\t\t\t\t\tcity,\n\t\t\t\t\tcountry,\n\t\t\t\t\tpostal_code,\n\t\t\t\t\tlat,\n\t\t\t\t\tlng,\n\t\t\t\t\tevent_type,\n\t\t\t\t\tuser_created,\n\t\t\t\t\thard_start,\n\t\t\t\t\thard_end,\n\t\t\t\t\ttimezone,\n\t\t\t\t\tplace_id,\n\t\t\t\t\twheelchair_accessible_parking,\n\t\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\t\twheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food,\n\t\t\t\t\tprice_level,\n\t\t\t\t\tutc_offset_minutes,\n\t\t\t\t\twebsite_uri,\n\t\t\t\t\ttypes,\n\t\t\t\t\tphoto_name,\n\t\t\t\t\tphoto_width,\n\t\t\t\t\tphoto_height,\n\t\t\t\t\tphoto_author,\n\t\t\t\t\tphoto_author_uri,\n\t\t\t\t\tphoto_author_photo_uri,\n\t\t\t\t\tweekday_descriptions,\n\t\t\t\t\tsecondary_hours_type,\n\t\t\t\t\tnext_open_time,\n\t\t\t\t\tnext_close_time,\n\t\t\t\t\topen_now,\n\t\t\t\t\tperiods,\n\t\t\t\t\tspecial_days\n\t\t\t\t)\n\t\t\t\tVALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)\n\t\t\t\tON CONFLICT (place_id) DO UPDATE SET\n\t\t\t\t\tevent_name = EXCLUDED.event_name,\n\t\t\t\t\tevent_description = EXCLUDED.event_description,\n\t\t\t\t\tstreet_address = EXCLUDED.street_address,\n\t\t\t\t\tcity = EXCLUDED.city,\n\t\t\t\t\tcountry = EXCLUDED.country,\n\t\t\t\t\tpostal_code = EXCLUDED.postal_code,\n\t\t\t\t\tlat = EXCLUDED.lat,\n\t\t\t\t\tlng = EXCLUDED.lng,\n\t\t\t\t\tevent_type = EXCLUDED.event_type,\n\t\t\t\t\tuser_created = EXCLUDED.user_created,\n\t\t\t\t\thard_start = EXCLUDED.hard_start,\n\t\t\t\t\thard_end = EXCLUDED.hard_end,\n\t\t\t\t\ttimezone = EXCLUDED.timezone,\n\t\t\t\t\twheelchair_accessible_parking = EXCLUDED.wheelchair_accessible_parking,\n\t\t\t\t\twheelchair_accessible_entrance = EXCLUDED.wheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom = EXCLUDED.wheelchair_accessible_restroom,\n\t\t\t\t\twheelchair_accessible_seating = EXCLUDED.wheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food = EXCLUDED.serves_vegetarian_food,\n\t\t\t\t\tprice_level = EXCLUDED.price_level,\n\t\t\t\t\tutc_offset_minutes = EXCLUDED.utc_offset_minutes,\n\t\t\t\t\twebsite_uri = EXCLUDED.website_uri,\n\t\t\t\t\ttypes = EXCLUDED.types,\n\t\t\t\t\tphoto_name = EXCLUDED.photo_name,\n\t\t\t\t\tphoto_width = EXCLUDED.photo_width,\n\t\t\t\t\tphoto_height = EXCLUDED.photo_height,\n\t\t\t\t\tphoto_author = EXCLUDED.photo_author,\n\t\t\t\t\tphoto_author_uri = EXCLUDED.photo_author_uri,\n\t\t\t\t\tphoto_author_photo_uri = EXCLUDED.photo_author_photo_uri,\n\t\t\t\t\tweekday_descriptions = EXCLUDED.weekday_descriptions,\n\t\t\t\t\tsecondary_hours_type = EXCLUDED.secondary_hours_type,\n\t\t\t\t\tnext_open_time = EXCLUDED.next_open_time,\n\t\t\t\t\tnext_close_time = EXCLUDED.next_close_time,\n\t\t\t\t\topen_now = EXCLUDED.open_now,\n\t\t\t\t\tperiods = EXCLUDED.periods,\n\t\t\t\t\tspecial_days = EXCLUDED.special_days\n\t\t\t\tRETURNING id, event_name\n\t\t\t\t\"#,\n\t\t\t\t\u0026ev.event_name,\n\t\t\t\tev.event_description.as_ref(),\n\t\t\t\tev.street_address.as_ref(),\n\t\t\t\tev.city.as_ref(),\n\t\t\t\tev.country.as_ref(),\n\t\t\t\tev.postal_code,\n\t\t\t\tev.lat,\n\t\t\t\tev.lng,\n\t\t\t\tev.event_type.as_ref(),\n\t\t\t\tev.user_created,\n\t\t\t\tev.hard_start,\n\t\t\t\tev.hard_end,\n\t\t\t\tev.timezone.as_ref(),\n\t\t\t\tev.place_id.as_ref(),\n\t\t\t\tev.wheelchair_accessible_parking,\n\t\t\t\tev.wheelchair_accessible_entrance,\n\t\t\t\tev.wheelchair_accessible_restroom,\n\t\t\t\tev.wheelchair_accessible_seating,\n\t\t\t\tev.serves_vegetarian_food,\n\t\t\t\tev.price_level,\n\t\t\t\tev.utc_offset_minutes,\n\t\t\t\tev.website_uri.as_ref(),\n\t\t\t\tev.types.as_ref(),\n\t\t\t\tev.photo_name.as_ref(),\n\t\t\t\tev.photo_width,\n\t\t\t\tev.photo_height,\n\t\t\t\tev.photo_author.as_ref(),\n\t\t\t\tev.photo_author_uri.as_ref(),\n\t\t\t\tev.photo_author_photo_uri.as_ref(),\n\t\t\t\tev.weekday_descriptions.as_ref(),\n\t\t\t\tev.secondary_hours_type,\n\t\t\t\tev.next_open_time,\n\t\t\t\tev.next_close_time,\n\t\t\t\tev.open_now,\n\t\t\t\t\u0026ev.periods as _,\n\t\t\t\t\u0026ev.special_days as _,\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.db)\n\t\t\t.await?;\n\n\t\t\tresults.push(EventInsertResult {\n\t\t\t\tid: result.id,\n\t\t\t\tevent_name: result.event_name,\n\t\t\t});\n\t\t}\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\t// Extract event IDs and names for the response and debugging\n\t\tresults.sort_unstable_by(|a, b| a.id.cmp(\u0026b.id));\n\t\tresults.dedup_by(|a, b| a.id == b.id);\n\t\tlet event_ids: Vec\u003ci32\u003e = results.iter().map(|r| r.id).collect();\n\t\tlet event_names: Vec\u003cString\u003e = results.iter().map(|r| r.event_name.clone()).collect();\n\n\t\t// Return only the IDs to keep the context window clean\n\t\tlet result = json!({\n\t\t\t\"event_ids\": event_ids,\n\t\t\t\"count\": event_ids.len()\n\t\t});\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tevents_count = event_ids.len(),\n\t\t\tevent_ids = ?event_ids,\n\t\t\t\"Nearby search completed successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tevents_sample = %serde_json::to_string(\u0026results.iter().take(3).map(|r| json!({\"id\": r.id, \"name\": \u0026r.event_name})).collect::\u003cVec\u003c_\u003e\u003e()).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\"Sample of events (first 3)\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"research\",\n\t\t\ttool: \"nearby_search_tool\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{}ms - {} events - [{}]\", elapsed.as_millis(), event_ids.len(), event_names.join(\", \"))\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","task.rs"],"content":"/*\n * src/agent/tools/task.rs\n *\n * Task Agent Tools Implementation - context and intent helpers\n *\n * These tools are focused on:\n * - retrieving user profile\n * - retrieving chat history/context\n * - parsing user intent\n * - asking for clarification when information is missing\n * - responding to the user\n *\n * They are used by the Task Agent and are intentionally kept separate\n * from the Orchestrator-specific tools.\n */\n\nuse crate::agent::models::context::{ContextData, SharedContextStore};\nuse crate::agent::models::user::UserIntent;\nuse crate::agent::tools::orchestrator::track_tool_execution;\nuse crate::controllers::itinerary::insert_event_list;\nuse crate::http_models::itinerary::Itinerary as HttpItinerary;\nuse crate::sql_models::LlmProgress;\nuse async_trait::async_trait;\nuse chrono::Datelike;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse std::time::Instant;\nuse tracing::{debug, info};\n\n/// Tool 1: Parse User Intent\n/// Parses user input to extract intent, destination, dates, budget, and constraints.\n/// Returns a UserIntent object.\n#[derive(Clone)]\npub struct ParseUserIntentTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl ParseUserIntentTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for ParseUserIntentTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"parse_user_intent\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Parses user input using an LLM to extract intent, destination, dates, budget, preferences, and constraints. Returns a UserIntent object with constraints array that should be stored in context for other agents to access. IMPORTANT: If you have retrieved chat context, include the recent conversation history in your analysis to extract information from previous messages.\"\n             .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"user_message\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The raw user message to parse. If you have conversation history from retrieve_chat_context, include the recent messages (last 3-5 exchanges) as context in this field to help extract information from previous messages.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"user_message\"]\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"parse_user_intent\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in parse_user_intent\"\n\t\t);\n\n\t\t// Handle user_message as string or object (convert object to string)\n\t\tlet user_message = if let Some(s) = input[\"user_message\"].as_str() {\n\t\t\ts.to_string()\n\t\t} else if input[\"user_message\"].is_object() {\n\t\t\tserde_json::to_string(\u0026input[\"user_message\"])?\n\t\t} else {\n\t\t\tinput[\"user_message\"].to_string()\n\t\t};\n\n\t\tlet prompt = format!(\n\t\t\tr#\"Extract travel planning information from the user's conversation history.\n\nCRITICAL: You will receive either:\n1. A JSON string containing a chat_history array with role/content messages\n2. A JSON object with destination/dates/budget fields that you should parse\n3. Plain text describing the travel request\n\nYour job is to extract ALL information mentioned in ANY format.\n\nUser input: {}\n\nExtract the following information and return ONLY a valid JSON object with these fields:\n{{\n  \"action\": \"create_itinerary\" | \"modify_itinerary\" | \"query\" | \"other\",\n  \"destination\": string or null (extract from ANY field - look for country/city names like \"brazil\", \"paris\", \"destination\", etc.),\n  \"start_date\": string or null (ISO format YYYY-MM-DD if mentioned - look in \"dates\", \"start_date\", or message content),\n  \"end_date\": string or null (ISO format YYYY-MM-DD if mentioned - look in \"dates\", \"end_date\", or message content),\n  \"budget\": number or null (total budget in USD - look in \"budget\" field or dollar amounts in messages. Use midpoint for ranges like \"20-30\"),\n  \"preferences\": [array of strings - look in \"preferences\" field or message content for activities, interests],\n  \"constraints\": [array of strings - dietary restrictions, accessibility needs found anywhere],\n  \"missing_info\": [array of strings - list ONLY what is truly missing. If destination/dates/budget appear ANYWHERE, they are NOT missing]\n}}\n\nRules:\n- If input has a \"chat_history\" array, read ALL messages in it\n- If input has direct fields like \"destination\", \"dates\", \"budget\", extract those\n- If input is plain text, parse it directly\n- For \"july 20-30th\" or \"june 10-20\", extract as start_date \"2026-07-20\" and end_date \"2026-07-30\" (year 2026 since we're in Dec 2025)\n- For budget ranges like \"20-30 dollars\", use the midpoint: 25\n- If preferences say \"no preferences\" or similar, use empty array but don't list it as missing\n- missing_info should ONLY contain items that are completely absent from the input\n\nReturn ONLY the JSON object, no other text.\"#,\n\t\t\tuser_message\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\t// Clean up the response - remove markdown code blocks if present\n\t\tlet cleaned = response\n\t\t\t.trim()\n\t\t\t.trim_start_matches(\"```json\")\n\t\t\t.trim_start_matches(\"```\")\n\t\t\t.trim_end_matches(\"```\")\n\t\t\t.trim();\n\n\t\t// Validate it's proper JSON and return as UserIntent\n\t\tlet intent: UserIntent = serde_json::from_str(cleaned).map_err(|e| {\n\t\t\tformat!(\n\t\t\t\t\"Failed to parse LLM response as JSON: {}. Response was: {}\",\n\t\t\t\te, cleaned\n\t\t\t)\n\t\t})?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\taction = %intent.action,\n\t\t\tdestination = ?intent.destination,\n\t\t\tstart_date = ?intent.start_date,\n\t\t\tend_date = ?intent.end_date,\n\t\t\tbudget = ?intent.budget,\n\t\t\tpreferences_count = intent.preferences.len(),\n\t\t\tconstraints_count = intent.constraints.len(),\n\t\t\tmissing_info = ?intent.missing_info,\n\t\t\t\"Parsed user intent successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tintent = %serde_json::to_string(\u0026intent)?,\n\t\t\t\"Full parsed intent\"\n\t\t);\n\n\t\t// Return serialized UserIntent\n\t\tlet result = serde_json::to_string(\u0026intent)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"parse_user_intent\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool 2: Retrieve Chat Context\n/// Retrieves chat history and context for the current conversation.\n/// Returns a vector of Message objects.\n#[derive(Clone)]\npub struct RetrieveChatContextTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RetrieveChatContextTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RetrieveChatContextTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"retrieve_chat_context\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Retrieves chat history and context for the current conversation.\".to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, _input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = _input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"retrieve_chat_context\", status: \"start\");\n\n\t\t// Get chat_session_id from shared atomic (set by controller before agent invocation)\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"Retrieving chat context\"\n\t\t);\n\n\t\t// Query database for chat history\n\t\tlet messages = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tm.id,\n\t\t\t\tm.is_user,\n\t\t\t\tm.timestamp,\n\t\t\t\tm.text,\n\t\t\t\tm.itinerary_id\n\t\t\tFROM messages m\n\t\t\tWHERE m.chat_session_id = $1\n\t\t\tORDER BY m.timestamp ASC\n\t\t\tLIMIT 50\n\t\t\t\"#,\n\t\t\tchat_id\n\t\t)\n\t\t.fetch_all(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tlet chat_history: Vec\u003cValue\u003e = messages\n\t\t\t.into_iter()\n\t\t\t.map(|msg| {\n\t\t\t\tjson!({\n\t\t\t\t\t\"id\": msg.id,\n\t\t\t\t\t\"role\": if msg.is_user { \"user\" } else { \"assistant\" },\n\t\t\t\t\t\"content\": msg.text,\n\t\t\t\t\t\"timestamp\": msg.timestamp.format(\"%Y-%m-%dT%H:%M:%S%.fZ\").to_string(),\n\t\t\t\t\t\"itinerary_id\": msg.itinerary_id\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect();\n\n\t\t// Retrieve or initialize in-memory context (includes pipeline state and events)\n\t\tlet mut store_guard = self.context_store.write().await;\n\t\tlet context_data = match store_guard.get_mut(\u0026chat_id) {\n\t\t\tSome(ctx) =\u003e ctx,\n\t\t\tNone =\u003e {\n\t\t\t\t// Context doesn't exist - create it\n\t\t\t\tstore_guard.insert(\n\t\t\t\t\tchat_id,\n\t\t\t\t\tContextData {\n\t\t\t\t\t\tchat_session_id: chat_id,\n\t\t\t\t\t\tuser_id: 0,\n\t\t\t\t\t\tuser_profile: None,\n\t\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\t\tevents: vec![],\n\t\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\t\tconstraints: vec![],\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tstore_guard.get_mut(\u0026chat_id).unwrap()\n\t\t\t}\n\t\t};\n\n\t\t// Update chat_history with the messages we just retrieved\n\t\tcontext_data.chat_history = chat_history.clone();\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tchat_id = chat_id,\n\t\t\tchat_history_count = context_data.chat_history.len(),\n\t\t\tpipeline_stage = ?context_data.pipeline_stage,\n\t\t\tevents_count = context_data.events.len(),\n\t\t\tconstraints_count = context_data.constraints.len(),\n\t\t\t\"Retrieved chat context\"\n\t\t);\n\n\t\tlet result = serde_json::to_string(\u0026context_data.clone())?;\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tcontext = %result,\n\t\t\t\"Full context data\"\n\t\t);\n\n\t\t// Log trip_context specifically for debugging\n\t\tif let Ok(context_obj) = serde_json::from_str::\u003cValue\u003e(\u0026result) {\n\t\t\tif let Some(trip_ctx) = context_obj.get(\"trip_context\") {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"retrieve_chat_context\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"Retrieved trip_context from database\",\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttrip_context = %serde_json::to_string_pretty(\u0026trip_ctx).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\"Trip context at retrieve_chat_context\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Return full context including pipeline state\n\t\tdrop(store_guard);\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tchat_history_count = chat_history.len(),\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"retrieve_chat_context\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool 3: Retrieve User Profile\n/// Retrieves user profile information including preferences and past trips.\n/// Returns a UserProfile object.\n#[derive(Clone)]\npub struct RetrieveUserProfileTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RetrieveUserProfileTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tuser_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tuser_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RetrieveUserProfileTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"retrieve_user_profile\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Retrieves user profile information including preferences and past trips. Automatically uses the logged-in user's ID.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"retrieve_user_profile\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_user_profile\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in retrieve_user_profile\"\n\t\t);\n\n\t\t// Get chat_session_id from atomic\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\t// Get user_id from context (safer than atomics - no race conditions)\n\t\tlet user_id = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tstore_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.map(|ctx| ctx.user_id)\n\t\t\t\t.unwrap_or(0)\n\t\t};\n\n\t\tif user_id == 0 {\n\t\t\t// In some flows (e.g., tests or unauthenticated calls) we may not have\n\t\t\t// a user_id. Treat this as \"no profile available\" instead of a hard\n\t\t\t// error so the Task Agent can still proceed and rely on chat history.\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\t\"User ID not set in context; proceeding with empty profile\"\n\t\t\t);\n\n\t\t\tlet empty_profile = json!({\n\t\t\t\t\"user_id\": null,\n\t\t\t\t\"email\": null,\n\t\t\t\t\"first_name\": null,\n\t\t\t\t\"last_name\": null,\n\t\t\t\t\"budget_preference\": null,\n\t\t\t\t\"risk_preference\": null,\n\t\t\t\t\"food_allergies\": \"\",\n\t\t\t\t\"disabilities\": \"\"\n\t\t\t});\n\n\t\t\t// Save empty profile into in-memory context for this chat (if any)\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.user_profile = Some(empty_profile.clone());\n\t\t\t}\n\n\t\t\tlet result = serde_json::to_string(\u0026empty_profile)?;\n\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\"Tool completed (no user logged in)\"\n\t\t\t);\n\n\t\t\ttrack_tool_execution(\n\t\t\t\t\u0026self.context_store,\n\t\t\t\t\u0026self.chat_session_id,\n\t\t\t\t\"retrieve_user_profile\",\n\t\t\t\t\u0026input_clone,\n\t\t\t\t\u0026result,\n\t\t\t)\n\t\t\t.await?;\n\n\t\t\treturn Ok(result);\n\t\t}\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"retrieve_user_profile\", user_id = user_id, \"Retrieving user profile\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"retrieve_user_profile\", input = %serde_json::to_string(\u0026input)?, \"Tool input\");\n\n\t\t// Query database for user profile\n\t\tuse crate::sql_models::{BudgetBucket, RiskTolerence};\n\t\tlet account = sqlx::query_as!(\n\t\t\tcrate::http_models::account::CurrentResponse,\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\temail,\n\t\t\t\tfirst_name,\n\t\t\t\tlast_name,\n\t\t\t\tbudget_preference as \"budget_preference: BudgetBucket\",\n\t\t\t\trisk_preference as \"risk_preference: RiskTolerence\",\n\t\t\t\tCOALESCE(food_allergies, '') as \"food_allergies!: String\",\n\t\t\t\tCOALESCE(disabilities, '') as \"disabilities!: String\",\n\t\t\t\tCOALESCE(profile_picture, '') as \"profile_picture!: String\"\n\t\t\tFROM accounts\n\t\t\tWHERE id = $1\n\t\t\t\"#,\n\t\t\tuser_id\n\t\t)\n\t\t.fetch_optional(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tlet profile = if let Some(acc) = account {\n\t\t\tjson!({\n\t\t\t\t\"user_id\": user_id,\n\t\t\t\t\"email\": acc.email,\n\t\t\t\t\"first_name\": acc.first_name,\n\t\t\t\t\"last_name\": acc.last_name,\n\t\t\t\t\"budget_preference\": acc.budget_preference,\n\t\t\t\t\"risk_preference\": acc.risk_preference,\n\t\t\t\t\"food_allergies\": acc.food_allergies,\n\t\t\t\t\"disabilities\": acc.disabilities\n\t\t\t})\n\t\t} else {\n\t\t\treturn Err(format!(\"User with id {} not found\", user_id).into());\n\t\t};\n\n\t\t// Automatically save user profile to in-memory context AND pre-fill trip context\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id != 0 {\n\t\t\t// Get existing in-memory context\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.user_profile = Some(profile.clone());\n\n\t\t\t\t// Pre-fill trip_context constraints from user profile\n\t\t\t\tlet mut constraints = Vec::new();\n\n\t\t\t\t// Add food allergies as constraints\n\t\t\t\tif let Some(allergies) = profile.get(\"food_allergies\").and_then(|v| v.as_str()) {\n\t\t\t\t\tif !allergies.is_empty() {\n\t\t\t\t\t\tfor allergy in allergies.split(',') {\n\t\t\t\t\t\t\tlet allergy_trimmed = allergy.trim();\n\t\t\t\t\t\t\tif !allergy_trimmed.is_empty() {\n\t\t\t\t\t\t\t\tconstraints.push(format!(\"No {}\", allergy_trimmed));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add disabilities as constraints\n\t\t\t\tif let Some(disabilities) = profile.get(\"disabilities\").and_then(|v| v.as_str()) {\n\t\t\t\t\tif !disabilities.is_empty() {\n\t\t\t\t\t\tconstraints\n\t\t\t\t\t\t\t.push(format!(\"Wheelchair accessible required: {}\", disabilities));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Store constraints in trip_context\n\t\t\t\tcontext_data.trip_context.constraints = constraints.clone();\n\n\t\t\t\t// Also store in the legacy constraints field for backward compatibility\n\t\t\t\tcontext_data.constraints = constraints;\n\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\tuser_id = user_id,\n\t\t\t\t\tconstraints_count = context_data.trip_context.constraints.len(),\n\t\t\t\t\t\"Saved user profile to context and pre-filled trip constraints\"\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\t\tconstraints = ?context_data.trip_context.constraints,\n\t\t\t\t\t\"Pre-filled constraints from user profile\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tlet result = serde_json::to_string(\u0026profile)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_user_profile\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tuser_id = user_id,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"retrieve_user_profile\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Ask for Clarification\n/// Generates a natural clarification question using an LLM when user input is ambiguous.\n/// STOPS THE PIPELINE by inserting the clarification message into the chat and returning success.\n#[derive(Clone)]\npub struct AskForClarificationTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl AskForClarificationTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for AskForClarificationTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"ask_for_clarification\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"STOPS THE PIPELINE by generating a natural, human-readable clarification question and sending it to the user. This tool inserts a message into the chat and returns the readable question text. Use this when critical information is missing. CRITICAL STOPPING RULE: After calling this tool, you MUST immediately return 'Final Answer' with the EXACT text returned by this tool. DO NOT call this tool again. DO NOT call any other tools. DO NOT call retrieve_chat_context or parse_user_intent after this. The tool returns ONLY the readable question text - use that EXACT text as your Final Answer. This is your FINAL response to the user - stop immediately after receiving the tool response. Always provide the missing_info parameter as a JSON string array (e.g., '[\\\"destination\\\", \\\"dates\\\", \\\"budget\\\"]'). If missing_info is not provided, the tool will use default common missing information.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"missing_info\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Array of strings describing what information is missing, as a JSON string. Example: '[\\\"destination\\\", \\\"dates\\\", \\\"budget\\\"]'. If you have an array, serialize it to JSON first.\"\n\t\t\t\t},\n\t\t\t\t\"context\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Additional context about the conversation as a JSON string. Optional.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"ask_for_clarification\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in ask_for_clarification\"\n\t\t);\n\n\t\t// langchain_rust passes action_input as a STRING, so we need to parse it first\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle missing_info - can be array, string, object, or missing\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tmissing_info_type = ?parsed_input.get(\"missing_info\").map(|v| {\n\t\t\t\tif v.is_array() { \"array\" }\n\t\t\t\telse if v.is_string() { \"string\" }\n\t\t\t\telse if v.is_object() { \"object\" }\n\t\t\t\telse { \"other\" }\n\t\t\t}),\n\t\t\tmissing_info_value = ?parsed_input.get(\"missing_info\"),\n\t\t\t\"Processing missing_info\"\n\t\t);\n\n\t\t// missing_info should be a JSON string, but handle all cases for robustness\n\t\tlet missing_info: Vec\u003cString\u003e = if let Some(s) = parsed_input[\"missing_info\"].as_str() {\n\t\t\t// Try to parse as JSON array first\n\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cVec\u003cString\u003e\u003e(s) {\n\t\t\t\tparsed\n\t\t\t} else {\n\t\t\t\t// If not valid JSON, treat as single string\n\t\t\t\tvec![s.to_string()]\n\t\t\t}\n\t\t} else if let Some(arr) = parsed_input[\"missing_info\"].as_array() {\n\t\t\t// Fallback: if somehow we get an array directly\n\t\t\tarr.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t.collect()\n\t\t} else if parsed_input[\"missing_info\"].is_object() {\n\t\t\t// If it's an object, try to find an array field in it\n\t\t\tparsed_input[\"missing_info\"]\n\t\t\t\t.get(\"missing_info\")\n\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t\t.map(|arr| {\n\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t\t\t.collect()\n\t\t\t\t})\n\t\t\t\t.or_else(|| {\n\t\t\t\t\t// Try other common field names\n\t\t\t\t\tparsed_input[\"missing_info\"]\n\t\t\t\t\t\t.get(\"items\")\n\t\t\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t\t\t\t\t.collect()\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or_else(|| {\n\t\t\t\t\tvec![\n\t\t\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\t\t\"dates\".to_string(),\n\t\t\t\t\t\t\"budget\".to_string(),\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t} else if parsed_input.get(\"missing_info\").is_some() {\n\t\t\t// Some other type - use defaults\n\t\t\tvec![\n\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\"dates\".to_string(),\n\t\t\t\t\"budget\".to_string(),\n\t\t\t]\n\t\t} else {\n\t\t\t// If missing_info is not provided at all, use default common missing information\n\t\t\t// This prevents the tool from failing and allows the agent to continue\n\t\t\tinfo!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", \"missing_info not provided, using defaults\");\n\t\t\tvec![\n\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\"travel dates\".to_string(),\n\t\t\t\t\"budget\".to_string(),\n\t\t\t\t\"preferences\".to_string(),\n\t\t\t]\n\t\t};\n\n\t\t// Handle context - can be string (JSON), object, or missing\n\t\tlet context = parsed_input.get(\"context\").unwrap_or(\u0026Value::Null);\n\t\tlet context_str = if let Some(s) = context.as_str() {\n\t\t\t// If it's a string, check if it's JSON, otherwise use as-is\n\t\t\tif serde_json::from_str::\u003cValue\u003e(s).is_ok() {\n\t\t\t\ts.to_string()\n\t\t\t} else {\n\t\t\t\ts.to_string()\n\t\t\t}\n\t\t} else if context.is_object() {\n\t\t\tserde_json::to_string(context).unwrap_or_else(|_| \"{}\".to_string())\n\t\t} else {\n\t\t\t\"\".to_string()\n\t\t};\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", missing_info_count = missing_info.len(), \"Asking for clarification\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", input = %serde_json::to_string(\u0026parsed_input)?, \"Tool input\");\n\n\t\t// Retrieve chat context to extract known information\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\t// ANTI-LOOP PROTECTION: Check if we've already asked for clarification\n\t\t// If asked_clarification flag is already true in trip context, we should NOT ask again\n\t\t{\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\tif context_data.trip_context.asked_clarification {\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\t\ttool = \"ask_for_clarification\",\n\t\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\t\"Already asked for clarification before - returning ready signal to prevent loop\"\n\t\t\t\t\t);\n\t\t\t\t\t// Return a signal that tells the agent we're ready to proceed\n\t\t\t\t\treturn Ok(\"Ready for research pipeline.\".to_string());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get chat history to extract known information\n\t\tlet messages = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tm.id,\n\t\t\t\tm.is_user,\n\t\t\t\tm.timestamp,\n\t\t\t\tm.text,\n\t\t\t\tm.itinerary_id\n\t\t\tFROM messages m\n\t\t\tWHERE m.chat_session_id = $1\n\t\t\tORDER BY m.timestamp ASC\n\t\t\tLIMIT 50\n\t\t\t\"#,\n\t\t\tchat_id\n\t\t)\n\t\t.fetch_all(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t// Extract known information from chat history and in-memory context\n\t\tlet mut known_info: Vec\u003cString\u003e = Vec::new();\n\t\tlet chat_text = messages\n\t\t\t.iter()\n\t\t\t.filter(|m| m.is_user)\n\t\t\t.map(|m| m.text.as_str())\n\t\t\t.collect::\u003cVec\u003c\u0026str\u003e\u003e()\n\t\t\t.join(\" \");\n\n\t\t// Try to extract from chat history using simple patterns\n\t\tif known_info.is_empty() {\n\t\t\tlet chat_lower = chat_text.to_lowercase();\n\n\t\t\t// Check for destination (common country/city names)\n\t\t\tlet destinations = vec![\n\t\t\t\t\"brazil\",\n\t\t\t\t\"paris\",\n\t\t\t\t\"tokyo\",\n\t\t\t\t\"london\",\n\t\t\t\t\"new york\",\n\t\t\t\t\"rome\",\n\t\t\t\t\"barcelona\",\n\t\t\t\t\"amsterdam\",\n\t\t\t\t\"berlin\",\n\t\t\t\t\"dubai\",\n\t\t\t\t\"singapore\",\n\t\t\t\t\"sydney\",\n\t\t\t\t\"mumbai\",\n\t\t\t\t\"bangkok\",\n\t\t\t];\n\t\t\tfor dest in destinations {\n\t\t\t\tif chat_lower.contains(dest) {\n\t\t\t\t\tknown_info.push(format!(\n\t\t\t\t\t\t\"Destination: {}\",\n\t\t\t\t\t\tdest.split_whitespace()\n\t\t\t\t\t\t\t.next()\n\t\t\t\t\t\t\t.unwrap_or(dest)\n\t\t\t\t\t\t\t.to_uppercase()\n\t\t\t\t\t));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for budget (numbers with $ or dollar/buck keywords)\n\t\t\tif chat_lower.contains(\"$\")\n\t\t\t\t|| chat_lower.contains(\"dollar\")\n\t\t\t\t|| chat_lower.contains(\"budget\")\n\t\t\t\t|| chat_lower.contains(\"buck\")\n\t\t\t{\n\t\t\t\tlet words: Vec\u003c\u0026str\u003e = chat_text.split_whitespace().collect();\n\t\t\t\tfor (i, word) in words.iter().enumerate() {\n\t\t\t\t\tlet word_lower = word.to_lowercase();\n\t\t\t\t\tif word_lower.contains(\"$\")\n\t\t\t\t\t\t|| word_lower.contains(\"dollar\")\n\t\t\t\t\t\t|| word_lower.contains(\"budget\")\n\t\t\t\t\t\t|| word_lower.contains(\"buck\")\n\t\t\t\t\t{\n\t\t\t\t\t\t// Look for numbers nearby\n\t\t\t\t\t\tfor j in i.saturating_sub(2)..(i + 3).min(words.len()) {\n\t\t\t\t\t\t\tif words[j].chars().any(|c| c.is_numeric()) {\n\t\t\t\t\t\t\t\tknown_info.push(format!(\"Budget: {}\", words[j]));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for dates (months or date patterns)\n\t\t\tlet months = vec![\n\t\t\t\t\"january\",\n\t\t\t\t\"february\",\n\t\t\t\t\"march\",\n\t\t\t\t\"april\",\n\t\t\t\t\"may\",\n\t\t\t\t\"june\",\n\t\t\t\t\"july\",\n\t\t\t\t\"august\",\n\t\t\t\t\"september\",\n\t\t\t\t\"october\",\n\t\t\t\t\"november\",\n\t\t\t\t\"december\",\n\t\t\t];\n\t\t\tfor month in months {\n\t\t\t\tif chat_lower.contains(month) {\n\t\t\t\t\tknown_info.push(format!(\"Dates: mentioned in conversation\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet known_info_str = if known_info.is_empty() {\n\t\t\t\"None yet\".to_string()\n\t\t} else {\n\t\t\tknown_info.join(\", \")\n\t\t};\n\t\tlet missing_info_str = missing_info.join(\", \");\n\n\t\tlet prompt = format!(\n\t\t\tr#\"Generate a friendly, natural clarification message for a travel planning conversation.\n\nIMPORTANT: You must show the user what information you already have and what you still need.\n\nInformation I Already Have:\n{}\n\nInformation I Still Need:\n{}\n\nConversation Context: {}\n\nCreate a friendly message that:\n1. Acknowledges what information you already have (if any)\n2. Clearly states what information is still needed to create the itinerary\n3. Asks for the missing information in a natural, conversational way\n\nFormat your response as a complete message that shows both what you know and what you need.\nExample: \"Great! I see you're planning a trip to [destination]. To create your itinerary, I still need to know [missing info]. Could you share [specific questions]?\"\n\nReturn ONLY the message text, nothing else.\"#,\n\t\t\tknown_info_str, missing_info_str, context_str\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\t\tlet clarification = response.trim().to_string();\n\n\t\t// Insert the clarification message into the database to stop the pipeline\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\tchat_id,\n\t\t\tclarification\n\t\t)\n\t\t.fetch_one(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tchat_id = chat_id,\n\t\t\tmessage_id = record.id,\n\t\t\t\"Clarification message sent - pipeline stopped\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tclarification = %clarification,\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\t// Mark that we've asked for clarification in the trip context\n\t\t{\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.trip_context.asked_clarification = true;\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"ask_for_clarification\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"Marked asked_clarification flag in trip context\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Return the clarification text directly.\n\t\t// The message is already inserted in the database with the ID in record.id\n\t\t// The agent prompt instructs to use this as Final Answer immediately.\n\t\tlet result = clarification.clone();\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed - pipeline stopped\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"ask_for_clarification\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Respond to User\n/// Sends a response to the user with the current itinerary (if available) or asks for more information.\n/// This tool STOPS the pipeline and sends the final message to the user.\n#[derive(Clone)]\npub struct RespondToUserTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RespondToUserTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RespondToUserTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"respond_to_user\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"STOPS THE PIPELINE and sends a response to the user. If active_itinerary exists in context, creates/updates the itinerary in the database and sends it to the user. If active_itinerary is empty or missing, sends a message asking for more information. This tool inserts a message into the chat and returns a success message. CRITICAL: After calling this tool, you MUST immediately return 'Final Answer' with a confirmation. DO NOT call any other tools. Use this as your final action when ready to respond to the user.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"message\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Optional message to send to the user as a string. If not provided, will generate based on itinerary status.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"orchestrator\", tool: \"respond_to_user\", status: \"start\");\n\n\t\t// Update progress to FinalizingItinerary\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id \u003e 0 {\n\t\t\t_ = sqlx::query!(\n\t\t\t\tr#\"UPDATE chat_sessions\n\t\t\t\tSET llm_progress=$1\n\t\t\t\tWHERE id=$2;\"#,\n\t\t\t\tLlmProgress::FinalizingItinerary as _,\n\t\t\t\tchat_id\n\t\t\t)\n\t\t\t.execute(\u0026self.pool)\n\t\t\t.await;\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"respond_to_user\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in respond_to_user\"\n\t\t);\n\n\t\t// Get chat_session_id from shared atomic (set by controller before agent invocation)\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\t// langchain_rust passes action_input as a STRING, so we need to parse it first\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle message as either string or object (convert object to string)\n\t\tlet optional_message = parsed_input.get(\"message\").map(|m| {\n\t\t\tif m.is_string() {\n\t\t\t\tm.as_str().unwrap_or(\"\").to_string()\n\t\t\t} else if m.is_object() {\n\t\t\t\tserde_json::to_string(m).unwrap_or_else(|_| \"{}\".to_string())\n\t\t\t} else {\n\t\t\t\tm.to_string()\n\t\t\t}\n\t\t});\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"respond_to_user\", chat_id = chat_id, \"Responding to user - pipeline stopped\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"respond_to_user\", input = %serde_json::to_string(\u0026parsed_input)?, \"Tool input\");\n\n\t\t// Get context to check for active_itinerary\n\t\tlet store_guard = self.context_store.read().await;\n\t\tlet context_data = store_guard\n\t\t\t.get(\u0026chat_id)\n\t\t\t.cloned()\n\t\t\t.unwrap_or_else(|| ContextData {\n\t\t\t\tchat_session_id: chat_id,\n\t\t\t\tuser_id: 0,\n\t\t\t\tuser_profile: None,\n\t\t\t\tchat_history: vec![],\n\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\tactive_itinerary: None,\n\t\t\t\tevents: vec![],\n\t\t\t\ttool_history: vec![],\n\t\t\t\tpipeline_stage: None,\n\t\t\t\tresearched_events: vec![],\n\t\t\t\tconstrained_events: vec![],\n\t\t\t\toptimized_events: vec![],\n\t\t\t\tconstraints: vec![],\n\t\t\t});\n\n\t\t// Check if we have an active itinerary\n\t\tlet has_itinerary = context_data.active_itinerary.is_some()\n\t\t\t\u0026\u0026 context_data\n\t\t\t\t.active_itinerary\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|it| {\n\t\t\t\t\t// Check if itinerary is not empty (has some structure)\n\t\t\t\t\t!it.is_null() \u0026\u0026 (!it.is_object() || !it.as_object().unwrap().is_empty())\n\t\t\t\t})\n\t\t\t\t.unwrap_or(false);\n\n\t\tlet (message_text, message_id) = if has_itinerary {\n\t\t\t// Parse and save the itinerary to database\n\t\t\tlet itinerary_json = context_data.active_itinerary.clone().unwrap();\n\n\t\t\t// Get user_id from chat_session\n\t\t\tlet user_id = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\tSELECT cs.account_id\n\t\t\tFROM chat_sessions cs\n\t\t\tWHERE cs.id = $1\n\t\t\t\"#,\n\t\t\t\tchat_id\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Failed to get user_id from chat_session: {}\", e))?\n\t\t\t.account_id;\n\n\t\t\t// Extract event IDs from the LLM-generated itinerary\n\t\t\tlet mut all_event_ids = Vec::new();\n\t\t\tif let Some(event_days) = itinerary_json.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\t\tfor day in event_days {\n\t\t\t\t\tfor time_block in \u0026[\"morning_events\", \"afternoon_events\", \"evening_events\"] {\n\t\t\t\t\t\tif let Some(events) = day.get(time_block).and_then(|v| v.as_array()) {\n\t\t\t\t\t\t\tfor event in events {\n\t\t\t\t\t\t\t\tif let Some(id) = event.get(\"id\").and_then(|v| v.as_i64()) {\n\t\t\t\t\t\t\t\t\tall_event_ids.push(id as i32);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif let Some(unassigned) = itinerary_json\n\t\t\t\t.get(\"unassigned_events\")\n\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t{\n\t\t\t\tfor event in unassigned {\n\t\t\t\t\tif let Some(id) = event.get(\"id\").and_then(|v| v.as_i64()) {\n\t\t\t\t\t\tall_event_ids.push(id as i32);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fetch full event objects from database\n\t\t\tuse crate::http_models::event::Event as HttpEvent;\n\t\t\tlet full_events = if !all_event_ids.is_empty() {\n\t\t\t\tsqlx::query_as!(\n\t\t\t\t\tHttpEvent,\n\t\t\t\t\tr#\"\n\t\t\t\tSELECT \n\t\t\t\t\tid, event_name, event_description, street_address, city, country, postal_code,\n\t\t\t\t\tlat, lng, event_type, user_created, hard_start, hard_end, timezone, place_id,\n\t\t\t\t\twheelchair_accessible_parking, wheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom, wheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food, price_level, utc_offset_minutes, website_uri, types,\n\t\t\t\t\tphoto_name, photo_width, photo_height, photo_author, photo_author_uri,\n\t\t\t\t\tphoto_author_photo_uri, weekday_descriptions, secondary_hours_type,\n\t\t\t\t\tnext_open_time, next_close_time, open_now,\n\t\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\t\tspecial_days,\n\t\t\t\t\tNULL::int4 as block_index\n\t\t\t\tFROM events\n\t\t\t\tWHERE id = ANY($1)\n\t\t\t\t\"#,\n\t\t\t\t\t\u0026all_event_ids\n\t\t\t\t)\n\t\t\t\t.fetch_all(\u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Failed to fetch full events: {}\", e))?\n\t\t\t} else {\n\t\t\t\tVec::new()\n\t\t\t};\n\n\t\t\t// Create a map of event ID -\u003e full event for quick lookup\n\t\t\tlet event_map: std::collections::HashMap\u003ci32, HttpEvent\u003e =\n\t\t\t\tfull_events.into_iter().map(|e| (e.id, e)).collect();\n\n\t\t\t// Helper function to hydrate events with full data from database\n\t\t\tlet hydrate_events = |partial_events: \u0026Value| -\u003e Vec\u003cHttpEvent\u003e {\n\t\t\t\tif let Some(events_arr) = partial_events.as_array() {\n\t\t\t\t\tevents_arr\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.filter_map(|e| {\n\t\t\t\t\t\t\te.get(\"id\")\n\t\t\t\t\t\t\t\t.and_then(|v| v.as_i64())\n\t\t\t\t\t\t\t\t.and_then(|id| event_map.get(\u0026(id as i32)).cloned())\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect()\n\t\t\t\t} else {\n\t\t\t\t\tVec::new()\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Parse itinerary structure (dates, title, days)\n\t\t\tuse crate::http_models::itinerary::EventDay as HttpEventDay;\n\t\t\tlet mut event_days = Vec::new();\n\t\t\tif let Some(days) = itinerary_json.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\t\tfor day in days {\n\t\t\t\t\tlet date_str = day\n\t\t\t\t\t\t.get(\"date\")\n\t\t\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\t\t\tlet date = chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\")\n\t\t\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\n\t\t\t\t\tevent_days.push(HttpEventDay {\n\t\t\t\t\t\tmorning_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"morning_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tafternoon_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"afternoon_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tevening_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"evening_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tdate,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet unassigned_events = hydrate_events(\n\t\t\t\t\u0026itinerary_json\n\t\t\t\t\t.get(\"unassigned_events\")\n\t\t\t\t\t.cloned()\n\t\t\t\t\t.unwrap_or(json!([])),\n\t\t\t);\n\n\t\t\t// Create HttpItinerary with hydrated events\n\t\t\tlet start_date_str = itinerary_json\n\t\t\t\t.get(\"start_date\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\tlet end_date_str = itinerary_json\n\t\t\t\t.get(\"end_date\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\tlet start_date = chrono::NaiveDate::parse_from_str(start_date_str, \"%Y-%m-%d\")\n\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\t\t\tlet end_date = chrono::NaiveDate::parse_from_str(end_date_str, \"%Y-%m-%d\")\n\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\t\t\tlet title = itinerary_json\n\t\t\t\t.get(\"title\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"Trip Itinerary\")\n\t\t\t\t.to_string();\n\n\t\t\tlet mut itinerary = HttpItinerary {\n\t\t\t\tid: 0, // Temporary, will be set after insert\n\t\t\t\tstart_date,\n\t\t\t\tend_date,\n\t\t\t\tevent_days,\n\t\t\t\tchat_session_id: Some(chat_id),\n\t\t\t\ttitle,\n\t\t\t\tunassigned_events,\n\t\t\t};\n\n\t\t\t// Extract unassigned event IDs\n\t\t\tlet unassigned_event_ids: Vec\u003ci32\u003e =\n\t\t\t\titinerary.unassigned_events.iter().map(|e| e.id).collect();\n\n\t\t\t// Insert itinerary into database\n\t\t\tlet itinerary_id = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title, unassigned_event_ids)\n\t\t\tVALUES ($1, FALSE, $2, $3, $4, FALSE, $5, $6)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\tuser_id,\n\t\t\titinerary.start_date,\n\t\t\titinerary.end_date,\n\t\t\tchat_id,\n\t\t\titinerary.title,\n\t\t\t\u0026unassigned_event_ids\n\t\t)\n\t\t.fetch_one(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Failed to insert itinerary: {}\", e))?\n\t\t.id;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Created itinerary in database\"\n\t\t\t);\n\n\t\t\t// Update itinerary ID for insert_event_list\n\t\t\titinerary.id = itinerary_id;\n\n\t\t\t// Capture the number of days before moving itinerary\n\t\t\tlet num_days = itinerary.event_days.len();\n\n\t\t\t// Insert all events into event_list table\n\t\t\tinsert_event_list(itinerary, \u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Failed to insert event list: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Inserted event list for itinerary\"\n\t\t\t);\n\n\t\t\t// Create user-friendly message\n\t\t\tlet default_message = format!(\n\t\t\t\t\"I've created your travel itinerary! It includes {} days with events scheduled throughout. You can view and edit it in your saved itineraries.\",\n\t\t\t\tnum_days\n\t\t\t);\n\t\t\tlet message = optional_message\n\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t.unwrap_or(default_message);\n\n\t\t\t// Insert message with itinerary_id\n\t\t\tlet record = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, $2, FALSE, NOW(), $3)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\t\tchat_id,\n\t\t\t\titinerary_id,\n\t\t\t\tmessage\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_id = record.id,\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Sent itinerary to user\"\n\t\t\t);\n\n\t\t\t(message, record.id)\n\t\t} else {\n\t\t\t// No itinerary - ask for more information\n\t\t\tlet default_message = \"I need more information to create your itinerary. Could you please provide:\\n- Your travel destination\\n- Travel dates (start and end)\\n- Budget\\n- Any preferences or constraints you have?\";\n\t\t\tlet message = optional_message.unwrap_or(default_message.to_string());\n\n\t\t\t// Insert message asking for more info\n\t\t\tlet record = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\t\t\tRETURNING id;\n\t\t\t\t\"#,\n\t\t\t\tchat_id,\n\t\t\t\tmessage\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_id = record.id,\n\t\t\t\t\"Asked user for more information\"\n\t\t\t);\n\n\t\t\t(message, record.id)\n\t\t};\n\n\t\t// Return a special marker that send_message_to_llm can detect\n\t\t// Format: \"MESSAGE_INSERTED:\u003cmessage_id\u003e:\u003cmessage_text\u003e\"\n\t\tlet result = format!(\"MESSAGE_INSERTED:{}:{}\", message_id, message_text);\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"respond_to_user\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"respond_to_user\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Update Trip Context\n/// Updates the trip context with new information from the user's latest message.\n/// This tool should be called AFTER retrieve_chat_context to incrementally fill in trip details.\n#[derive(Clone)]\npub struct UpdateTripContextTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl UpdateTripContextTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for UpdateTripContextTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"update_trip_context\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Updates the trip context with new information extracted from the user's latest message in the chat history. Call this AFTER retrieve_chat_context to incrementally fill in destination, dates, budget, preferences. Automatically extracts the most recent user message from chat_history. Only updates fields that are present in the new information - existing fields are preserved. Returns the updated trip context showing what information we now have and what is still missing.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone();\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"update_trip_context\", status: \"start\");\n\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"Updating trip context from chat history\"\n\t\t);\n\n\t\t// Get current trip context AND extract the last 5 user messages from chat_history\n\t\t// We need multiple messages because user provides info across multiple turns\n\t\tlet (current_context, user_messages) = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tlet context_data = store_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.ok_or(\"Context not found for chat_id\")?;\n\n\t\t\t// Extract the last 5 user messages from chat_history (most recent first)\n\t\t\tlet recent_user_msgs: Vec\u003cString\u003e = context_data\n\t\t\t\t.chat_history\n\t\t\t\t.iter()\n\t\t\t\t.rev() // Start from the end (most recent)\n\t\t\t\t.filter(|msg| msg.get(\"role\").and_then(|r| r.as_str()) == Some(\"user\"))\n\t\t\t\t.take(5) // Get last 5 user messages\n\t\t\t\t.filter_map(|msg| {\n\t\t\t\t\tmsg.get(\"content\")\n\t\t\t\t\t\t.and_then(|c| c.as_str())\n\t\t\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t})\n\t\t\t\t.collect();\n\n\t\t\t// Combine them into one string (most recent first)\n\t\t\tlet combined_messages = recent_user_msgs.join(\"\\n\");\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\ttool = \"update_trip_context\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_count = recent_user_msgs.len(),\n\t\t\t\tcombined_length = combined_messages.len(),\n\t\t\t\t\"Extracted recent user messages from chat history\"\n\t\t\t);\n\t\t\tdebug!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\tmessages = %combined_messages,\n\t\t\t\t\"Combined user messages for extraction\"\n\t\t\t);\n\n\t\t\t(context_data.trip_context.clone(), combined_messages)\n\t\t};\n\n\t\tinfo!(\n\t\t\ttarget: \"trip_context\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"BEFORE UPDATE - Current trip context\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tcurrent_destination = ?current_context.destination,\n\t\t\tcurrent_start_date = ?current_context.start_date,\n\t\t\tcurrent_end_date = ?current_context.end_date,\n\t\t\tcurrent_budget = ?current_context.budget,\n\t\t\tcurrent_preferences = ?current_context.preferences,\n\t\t\tcurrent_constraints = ?current_context.constraints,\n\t\t\t\"Current trip context details\"\n\t\t);\n\n\t\t// Use LLM to extract trip information from the messages\n\t\tlet extraction_prompt = format!(\n\t\t\tr#\"Extract trip planning information from these recent user messages. Return ONLY a JSON object.\n\nCurrent context (preserve these if not mentioned in new messages):\n- destination: {}\n- start_date: {}\n- end_date: {}\n- budget: {}\n- preferences: {}\n\nRecent user messages (newest first):\n\"{}\"\n\nIMPORTANT: Extract information from ALL the messages above, not just the first one.\n\nReturn JSON with the information found across all messages:\n{{\n  \"destination\": \"string or null\",\n  \"start_date\": \"YYYY-MM-DD or null\",\n  \"end_date\": \"YYYY-MM-DD or null\",\n  \"budget\": number or null,\n  \"preferences\": [\"array\", \"of\", \"strings\"] or [],\n  \"action\": \"create|modify|view|delete or null\"\n}}\n\nExamples:\n- \"Brazil\" + \"10/8 to 10/20\" → {{\"destination\": \"Brazil\", \"start_date\": \"2023-10-08\", \"end_date\": \"2023-10-20\"}}\n- \"no preferences\" → {{\"preferences\": []}}\n\nReturn valid JSON only.\"#,\n\t\t\tcurrent_context.destination.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context.start_date.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context.end_date.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context\n\t\t\t\t.budget\n\t\t\t\t.map(|b| b.to_string())\n\t\t\t\t.as_deref()\n\t\t\t\t.unwrap_or(\"null\"),\n\t\t\tserde_json::to_string(\u0026current_context.preferences)\n\t\t\t\t.unwrap_or_else(|_| \"[]\".to_string()),\n\t\t\tuser_messages\n\t\t);\n\n\t\tlet llm_response = self\n\t\t\t.llm\n\t\t\t.invoke(\u0026extraction_prompt)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"LLM error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"trip_context\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"LLM extraction response\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tllm_response = %llm_response,\n\t\t\t\"Raw LLM response for extraction\"\n\t\t);\n\n\t\t// Parse LLM response\n\t\tlet extracted: Value = serde_json::from_str(\u0026llm_response).unwrap_or_else(|e| {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\terror = %e,\n\t\t\t\traw_response = %llm_response,\n\t\t\t\t\"Failed to parse LLM response as JSON, using empty object\"\n\t\t\t);\n\t\t\tjson!({})\n\t\t});\n\n\t\t// Merge with current context (only update non-null fields)\n\t\tlet mut updated_context = current_context;\n\n\t\tif let Some(dest) = extracted[\"destination\"].as_str() {\n\t\t\tupdated_context.destination = Some(dest.to_string());\n\t\t}\n\t\tif let Some(start) = extracted[\"start_date\"].as_str() {\n\t\t\tupdated_context.start_date = Some(start.to_string());\n\t\t}\n\t\tif let Some(end) = extracted[\"end_date\"].as_str() {\n\t\t\tupdated_context.end_date = Some(end.to_string());\n\t\t}\n\t\tif let Some(budget) = extracted[\"budget\"].as_f64() {\n\t\t\tupdated_context.budget = Some(budget);\n\t\t}\n\t\tif let Some(prefs) = extracted[\"preferences\"].as_array() {\n\t\t\tlet new_prefs: Vec\u003cString\u003e = prefs\n\t\t\t\t.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t.collect();\n\t\t\tif !new_prefs.is_empty() {\n\t\t\t\tupdated_context.preferences.extend(new_prefs);\n\t\t\t\tupdated_context.preferences.dedup();\n\t\t\t}\n\t\t}\n\t\tif let Some(action) = extracted[\"action\"].as_str() {\n\t\t\tupdated_context.action = Some(action.to_string());\n\t\t}\n\n\t\t// Save updated context\n\t\t{\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.trip_context = updated_context.clone();\n\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"update_trip_context\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"AFTER UPDATE - Updated trip context saved\",\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\tupdated_destination = ?updated_context.destination,\n\t\t\t\t\tupdated_start_date = ?updated_context.start_date,\n\t\t\t\t\tupdated_end_date = ?updated_context.end_date,\n\t\t\t\t\tupdated_budget = ?updated_context.budget,\n\t\t\t\t\tupdated_preferences = ?updated_context.preferences,\n\t\t\t\t\tupdated_constraints = ?updated_context.constraints,\n\t\t\t\t\t\"Updated trip context details\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Determine what's still missing - ONLY require destination and dates\n\t\t// Budget, preferences, and constraints are ALL optional\n\t\tlet mut missing = Vec::new();\n\t\tif updated_context.destination.is_none() {\n\t\t\tmissing.push(\"destination\");\n\t\t}\n\t\tif updated_context.start_date.is_none() {\n\t\t\tmissing.push(\"start_date\");\n\t\t}\n\t\tif updated_context.end_date.is_none() {\n\t\t\tmissing.push(\"end_date\");\n\t\t}\n\t\t// Budget, preferences, and constraints are optional - don't add to missing\n\n\t\t// Check if we've asked clarification at least once\n\t\tlet has_asked_before = updated_context.asked_clarification;\n\n\t\t// Ready for pipeline only if:\n\t\t// 1. No missing required fields AND\n\t\t// 2. We've asked clarification at least once\n\t\tlet ready_for_pipeline = missing.is_empty() \u0026\u0026 has_asked_before;\n\n\t\tlet result = json!({\n\t\t\t\"trip_context\": updated_context,\n\t\t\t\"missing_info\": missing,\n\t\t\t\"ready_for_pipeline\": ready_for_pipeline,\n\t\t\t\"asked_clarification_before\": has_asked_before\n\t\t});\n\n\t\tlet result_str = serde_json::to_string(\u0026result)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tchat_id = chat_id,\n\t\t\tmissing_count = missing.len(),\n\t\t\tready = missing.is_empty(),\n\t\t\t\"Trip context update complete - SUMMARY\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tmissing_fields = ?missing,\n\t\t\t\"Missing information details\"\n\t\t);\n\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"update_trip_context\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result_str,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result_str)\n\t}\n}\n\n/// Tool 6: Update Chat Title\n/// Automatically updates the chat session title based on trip context\n/// Only updates if the title is still \"New Chat\" (default)\n#[derive(Clone)]\npub struct UpdateChatTitleTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl UpdateChatTitleTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for UpdateChatTitleTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"update_chat_title\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Automatically updates the chat session title with destination and dates when trip context is available. Only updates if title is still 'New Chat'. Call this after update_trip_context when you have destination and dates. No parameters needed.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone();\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"update_chat_title\", status: \"start\");\n\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\t// Get trip context\n\t\tlet trip_context = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tstore_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.map(|ctx| ctx.trip_context.clone())\n\t\t\t\t.ok_or(\"Context not found\")?\n\t\t};\n\n\t\t// Check if we have enough info to make a title\n\t\tif trip_context.destination.is_none() {\n\t\t\treturn Ok(json!({\n\t\t\t\t\"updated\": false,\n\t\t\t\t\"reason\": \"No destination set yet\"\n\t\t\t})\n\t\t\t.to_string());\n\t\t}\n\n\t\t// Check current title - only update if it's \"New Chat\"\n\t\tlet current_title =\n\t\t\tsqlx::query!(r#\"SELECT title FROM chat_sessions WHERE id = $1\"#, chat_id)\n\t\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?\n\t\t\t\t.title;\n\n\t\tif current_title != \"New Chat\" {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"update_chat_title\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tcurrent_title = %current_title,\n\t\t\t\t\"Title already set, skipping update\"\n\t\t\t);\n\t\t\treturn Ok(json!({\n\t\t\t\t\"updated\": false,\n\t\t\t\t\"reason\": \"Title already set\",\n\t\t\t\t\"current_title\": current_title\n\t\t\t})\n\t\t\t.to_string());\n\t\t}\n\n\t\t// Build new title from trip context\n\t\tlet mut title_parts = Vec::new();\n\n\t\tif let Some(dest) = \u0026trip_context.destination {\n\t\t\ttitle_parts.push(dest.clone());\n\t\t}\n\n\t\t// Format dates if we have both\n\t\tif let (Some(start), Some(end)) = (\u0026trip_context.start_date, \u0026trip_context.end_date) {\n\t\t\t// Try to format as \"MMM DD-DD\" if same month\n\t\t\tif let (Ok(start_date), Ok(end_date)) = (\n\t\t\t\tchrono::NaiveDate::parse_from_str(start, \"%Y-%m-%d\"),\n\t\t\t\tchrono::NaiveDate::parse_from_str(end, \"%Y-%m-%d\"),\n\t\t\t) {\n\t\t\t\tif start_date.month() == end_date.month() {\n\t\t\t\t\ttitle_parts.push(format!(\n\t\t\t\t\t\t\"{} {}-{}\",\n\t\t\t\t\t\tstart_date.format(\"%b\"),\n\t\t\t\t\t\tstart_date.day(),\n\t\t\t\t\t\tend_date.day()\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\ttitle_parts.push(format!(\n\t\t\t\t\t\t\"{} - {}\",\n\t\t\t\t\t\tstart_date.format(\"%b %d\"),\n\t\t\t\t\t\tend_date.format(\"%b %d\")\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet new_title = if title_parts.is_empty() {\n\t\t\t\"New Trip\".to_string()\n\t\t} else {\n\t\t\ttitle_parts.join(\", \")\n\t\t};\n\n\t\t// Update the title\n\t\tsqlx::query!(\n\t\t\tr#\"UPDATE chat_sessions SET title = $1 WHERE id = $2\"#,\n\t\t\tnew_title,\n\t\t\tchat_id\n\t\t)\n\t\t.execute(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_chat_title\",\n\t\t\tchat_id = chat_id,\n\t\t\tnew_title = %new_title,\n\t\t\t\"Updated chat session title\"\n\t\t);\n\n\t\tlet result = json!({\n\t\t\t\"updated\": true,\n\t\t\t\"new_title\": new_title\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_chat_title\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"update_chat_title\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result.to_string(),\n\t\t)\n\t\t.await?;\n\n\t\tOk(result.to_string())\n\t}\n}\n\n/// Gets the tools used by the Task Agent to build planning context.\n/// These tools are focused on:\n/// - retrieving user profile\n/// - retrieving chat history/context\n/// - updating trip context incrementally\n/// - asking for clarification when information is missing\npub fn get_task_tools(\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![\n\t\tArc::new(ParseUserIntentTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RetrieveChatContextTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RetrieveUserProfileTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tArc::clone(\u0026user_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(UpdateTripContextTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(UpdateChatTitleTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(AskForClarificationTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","tsp.rs"],"content":"// tsp.rs - vibe coded so don't blame me for bugs\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Copy, Debug, Serialize, Deserialize)]\npub struct Pt\u003c'a\u003e {\n\tpub id: Option\u003c\u0026'a str\u003e,\n\tpub lat: f64,\n\tpub lng: f64,\n}\n\nfn dist(a: Pt, b: Pt) -\u003e f64 {\n\tlet dx = a.lat - b.lat;\n\tlet dy = a.lng - b.lng;\n\t(dx * dx + dy * dy).sqrt()\n}\n\n//\n// ---------------------------\n// Route Construction\n// ---------------------------\n//\n\nfn nearest_neighbor_cycle(points: \u0026[Pt], start: usize) -\u003e Vec\u003cusize\u003e {\n\tlet n = points.len();\n\tlet mut visited = vec![false; n];\n\tlet mut route = Vec::with_capacity(n + 1);\n\n\tlet mut current = start;\n\tvisited[current] = true;\n\troute.push(current);\n\n\tfor _ in 1..n {\n\t\tlet mut best = None;\n\t\tlet mut best_dist = f64::INFINITY;\n\t\tfor i in 0..n {\n\t\t\tif !visited[i] {\n\t\t\t\tlet d = dist(points[current], points[i]);\n\t\t\t\tif d \u003c best_dist {\n\t\t\t\t\tbest_dist = d;\n\t\t\t\t\tbest = Some(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet next = best.unwrap();\n\t\tvisited[next] = true;\n\t\troute.push(next);\n\t\tcurrent = next;\n\t}\n\n\t// Explicitly close the cycle by returning to start\n\troute.push(start);\n\n\troute\n}\n\nfn nearest_neighbor_path(points: \u0026[Pt], start: usize, end: usize) -\u003e Vec\u003cusize\u003e {\n\tlet n = points.len();\n\tlet mut visited = vec![false; n];\n\tlet mut route = Vec::with_capacity(n);\n\n\tvisited[start] = true;\n\t// Do NOT visit end early\n\tvisited[end] = false;\n\n\tlet mut current = start;\n\troute.push(start);\n\n\tfor _ in 0..n - 2 {\n\t\tlet mut best = None;\n\t\tlet mut best_dist = f64::INFINITY;\n\n\t\tfor i in 0..n {\n\t\t\tif i == end {\n\t\t\t\tcontinue; // don't pick end until last\n\t\t\t}\n\t\t\tif !visited[i] {\n\t\t\t\tlet d = dist(points[current], points[i]);\n\t\t\t\tif d \u003c best_dist {\n\t\t\t\t\tbest_dist = d;\n\t\t\t\t\tbest = Some(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet next = best.unwrap();\n\t\tvisited[next] = true;\n\t\troute.push(next);\n\t\tcurrent = next;\n\t}\n\n\t// Now put end last\n\troute.push(end);\n\n\troute\n}\n\n//\n// ---------------------------\n// 2-opt optimization\n// ---------------------------\n//\n\nfn two_opt_cycle(points: \u0026[Pt], route: \u0026mut Vec\u003cusize\u003e) {\n\tlet n = route.len();\n\tlet mut improved = true;\n\n\twhile improved {\n\t\timproved = false;\n\t\tfor i in 1..n - 2 {\n\t\t\tfor j in i + 1..n - 1 {\n\t\t\t\tlet a = route[i - 1];\n\t\t\t\tlet b = route[i];\n\t\t\t\tlet c = route[j];\n\t\t\t\tlet d = route[j + 1];\n\n\t\t\t\tlet before = dist(points[a], points[b]) + dist(points[c], points[d]);\n\t\t\t\tlet after = dist(points[a], points[c]) + dist(points[b], points[d]);\n\n\t\t\t\tif after \u003c before {\n\t\t\t\t\troute[i..=j].reverse();\n\t\t\t\t\timproved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn two_opt_path(points: \u0026[Pt], route: \u0026mut Vec\u003cusize\u003e) {\n\tlet n = route.len();\n\tlet mut improved = true;\n\n\t// route[0] and route[n-1] must not move\n\twhile improved {\n\t\timproved = false;\n\t\tfor i in 1..n - 3 {\n\t\t\tfor j in i + 1..n - 2 {\n\t\t\t\tlet a = route[i - 1];\n\t\t\t\tlet b = route[i];\n\t\t\t\tlet c = route[j];\n\t\t\t\tlet d = route[j + 1];\n\n\t\t\t\tlet before = dist(points[a], points[b]) + dist(points[c], points[d]);\n\t\t\t\tlet after = dist(points[a], points[c]) + dist(points[b], points[d]);\n\n\t\t\t\tif after \u003c before {\n\t\t\t\t\troute[i..=j].reverse();\n\t\t\t\t\timproved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//\n// ---------------------------\n// Public API\n// ---------------------------\n//\n\npub enum EndpointMode {\n\tCircle,\n\tPath,\n}\n\npub fn compute_route(points: \u0026[Pt], mode: EndpointMode) -\u003e Vec\u003cusize\u003e {\n\tmatch mode {\n\t\tEndpointMode::Circle =\u003e {\n\t\t\tlet mut route = nearest_neighbor_cycle(points, 0);\n\t\t\ttwo_opt_cycle(points, \u0026mut route);\n\t\t\troute\n\t\t}\n\t\tEndpointMode::Path =\u003e {\n\t\t\tlet mut route = nearest_neighbor_path(points, 0, points.len() - 1);\n\t\t\ttwo_opt_path(points, \u0026mut route);\n\t\t\troute\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","account.rs"],"content":"/*\n * src/controllers/account.rs\n *\n * File for Account Controller API Endpoints\n *\n * Purpose:\n *   Serve Account Related API Requests\n */\n\nuse argon2::{\n\tArgon2,\n\tpassword_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\nuse axum::{\n\tExtension, Json,\n\trouting::{get, post},\n};\n#[cfg(test)]\nuse tower_cookies::cookie::CookieJar;\n\nuse tower_cookies::{\n\tCookie, Cookies,\n\tcookie::{\n\t\tKey, SameSite,\n\t\ttime::{Duration, OffsetDateTime},\n\t},\n};\n\n#[cfg(test)]\nuse crate::global::TEST_COOKIE_EXP_SECONDS;\n\nuse sqlx::PgPool;\nuse tracing::debug;\nuse utoipa::OpenApi;\n\nuse crate::http_models::account::*;\nuse crate::middleware::{AuthUser, middleware_auth};\nuse crate::{\n\tcontrollers::AxumRouter,\n\terror::{ApiResult, AppError},\n\tsql_models::{BudgetBucket, RiskTolerence, account::AccountRow},\n\tswagger::SecurityAddon,\n};\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_signup,\n\t\tapi_login,\n\t\tapi_logout,\n\t\tapi_validate,\n\t\tapi_update,\n\t\tapi_current\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n    info(\n    \ttitle=\"Account Routes\",\n    \tdescription = \"API endpoints dealing with authentication and account info.\"\n    ),\n    tags((name=\"Account\"))\n)]\npub struct AccountApiDoc;\n\npub trait CookieStore {\n\tfn private_add(\u0026mut self, key: \u0026Key, cookie: Cookie\u003c'static\u003e);\n}\nimpl CookieStore for Cookies {\n\t#[inline(always)]\n\tfn private_add(\u0026mut self, key: \u0026Key, cookie: Cookie\u003c'static\u003e) {\n\t\tself.private(key).add(cookie)\n\t}\n}\n#[cfg(test)]\nimpl CookieStore for CookieJar {\n\t#[inline(always)]\n\tfn private_add(\u0026mut self, _key: \u0026Key, cookie: Cookie\u003c'static\u003e) {\n\t\tself.add(cookie)\n\t}\n}\n\n/// Creates and sets the cookie containing the hashed account id, expiration time, and other data.\n///\n/// Notes:\n/// - Token format is `user-\u003cid\u003e.\u003cexp\u003e.sign`, where `\u003cexp\u003e` is epoch seconds (UTC) ~3 days out.\n/// - Cookie name is `auth-token`; in development it uses `SameSite=Lax`, not `Secure`.\nfn set_cookie(account_id: i32, expired: bool, cookies: \u0026mut impl CookieStore, key: \u0026Key) {\n\t// Create token and set cookie as before\n\tlet domain = option_env!(\"DOMAIN\").unwrap_or(\"localhost\");\n\tlet app_env = option_env!(\"APP_ENV\").unwrap_or(\"development\");\n\tlet on_production = app_env == \"production\";\n\n\t// Create a token value (in a real app, this would be a JWT or similar)\n\t// Embed expiration epoch seconds inside the token for server-side validation\n\tlet (expires, max_age) = if expired {\n\t\t(OffsetDateTime::UNIX_EPOCH, Duration::days(0))\n\t} else {\n\t\t#[cfg(not(test))]\n\t\tlet age = Duration::days(3);\n\n\t\t// if tests start failing because the cookie expires too fast, just raise it by a little bit\n\t\t#[cfg(test)]\n\t\tlet age = Duration::seconds(TEST_COOKIE_EXP_SECONDS);\n\n\t\t(OffsetDateTime::now_utc() + age, age)\n\t};\n\tlet token_value = format!(\"user-{}.{}.sign\", account_id, expires.unix_timestamp());\n\n\tdebug!(\n\t\t\"INFO -\u003e\u003e Generated token: {}. Production is: {}\",\n\t\ttoken_value, on_production\n\t);\n\n\t// Build the cookie with enhanced security\n\t// Store encrypted (private) cookie so value is confidential and authenticated\n\tlet cookie = Cookie::build((\"auth-token\", token_value.clone()))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.expires(Some(expires))\n\t\t.max_age(max_age)\n\t\t.build();\n\n\t// encrypt/sign cookie (private cookie via CookieManagerLayer key)\n\tcookies.private_add(key, cookie);\n}\n\n/// Create a new user.\n///\n/// # Method\n/// `POST /api/account/signup`\n///\n/// # Request Body\n/// - `email`: A valid email address (string, required).\n/// - `first_name`: The user's first name (string, required).\n/// - 'last_name': The user's last name (string, required).\n/// - 'password': The user's password (string, required).\n///\n/// # Responses\n/// - `200 OK` - Signup successful\n/// - `400 BAD_REQUEST` - Validation failure (public error)\n/// - `409 CONFLICT` - Email already exists (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/signup\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///        \"email\": \"alice@example.com\",\n///        \"first_name\": \"alice\",\n///        \"last_name\": \"grace\",\n///        \"password\": \"password123.\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/signup\",\n\tsummary=\"Create a new account\",\n\tdescription=\"Inserts account details into db (if email isn't already taken), and returns with a cookie.\",\n\trequest_body(\n\t\tcontent=SignupRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Email must not already be taken. Password must be in plaintext.\",\n\t\texample=json!({\n\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\"first_name\": \"First\",\n\t\t\t\"last_name\": \"Last\",\n\t\t\t\"password\": \"Password_123\"\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Account successfully created\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=409, description=\"Email already in use\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n\ttag=\"Account\"\n)]\npub async fn api_signup\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(payload): Json\u003cSignupRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/signup 'api_signup' - Payload: {:?}\",\n\t\tpayload\n\t);\n\n\t// Validate input\n\tif let Err(validation_error) = payload.validate() {\n\t\treturn Err(AppError::Validation(validation_error));\n\t}\n\n\t// Check if user already exists\n\tlet existing_user_result =\n\t\tsqlx::query!(\"SELECT id FROM accounts WHERE email = $1\", payload.email)\n\t\t\t.fetch_optional(\u0026pool)\n\t\t\t.await;\n\n\tmatch existing_user_result {\n\t\tOk(Some(_)) =\u003e {\n\t\t\treturn Err(AppError::Conflict(\"email already exists\".to_string()));\n\t\t}\n\t\tErr(e) =\u003e {\n\t\t\treturn Err(AppError::from(e));\n\t\t}\n\t\tOk(None) =\u003e {\n\t\t\t// User doesn't exist, proceed with signup\n\t\t}\n\t}\n\n\t// Hash the password\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\tlet password_hash = argon2\n\t\t.hash_password(payload.password.as_bytes(), \u0026salt)\n\t\t.map_err(AppError::from)?\n\t\t.to_string();\n\n\t// Insert new user into database\n\tlet insert_result = sqlx::query!(\n\t\t\"INSERT INTO accounts (email, first_name, last_name, password)\n         VALUES ($1, $2, $3, $4)\n         RETURNING id\",\n\t\tpayload.email,\n\t\tpayload.first_name,\n\t\tpayload.last_name,\n\t\tpassword_hash\n\t)\n\t.fetch_one(\u0026pool)\n\t.await;\n\n\tmatch insert_result {\n\t\tOk(record) =\u003e {\n\t\t\tdebug!(\n\t\t\t\t\"INFO -\u003e\u003e /api/account/signup 'api_signup' - Created user with id: {}\",\n\t\t\t\trecord.id\n\t\t\t);\n\n\t\t\tset_cookie(record.id, false, cookies, \u0026key);\n\n\t\t\tOk(())\n\t\t}\n\t\tErr(e) =\u003e Err(AppError::from(e)),\n\t}\n}\n\n/// Attempt user login\n///\n/// # Method\n/// `POST /api/account/login`\n///\n/// # Request Body\n/// - `email`: A valid email address (string, required).\n/// - 'password': The user's password (string, required).\n///\n/// # Responses\n/// - `200 OK` - Login successful with private cookie set\n/// - `400 BAD_REQUEST` - Invalid credentials (public error)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/login\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///        \"email\": \"alice@example.com\",\n///        \"password\": \"password123.\"\n///       }'\n/// ```\n///\n/// Notes:\n/// - Token format is `user-\u003cid\u003e.\u003cexp\u003e.sign`, where `\u003cexp\u003e` is epoch seconds (UTC) ~3 days out.\n/// - Cookie name is `auth-token`; in development it uses `SameSite=Lax`, not `Secure`.\n#[utoipa::path(\n\tpost,\n\tpath=\"/login\",\n\tsummary=\"Attempt user login\",\n\tdescription=\"Attempts to login and return with a cookie.\",\n\trequest_body(\n\t\tcontent=LoginRequest,\n\t\tcontent_type=\"application/json\",\n\t\texample=json!({\n\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\"password\": \"Password_123\"\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Login succeeded\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n\ttag=\"Account\"\n)]\npub async fn api_login\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(payload): Json\u003cLoginRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/login 'api_login' - Payload: {:?}\",\n\t\tpayload\n\t);\n\n\t// Get user from database as Account\n\tlet user_result = sqlx::query_as!(\n\t\tAccountRow,\n\t\tr#\"\n        SELECT\n            id,\n            email,\n            password\n        FROM accounts\n        WHERE email = $1\n        \"#,\n\t\tpayload.email\n\t)\n\t.fetch_one(\u0026pool)\n\t.await;\n\n\tmatch user_result {\n\t\tOk(result) =\u003e {\n\t\t\t// Verify password\n\t\t\tlet parsed_hash = PasswordHash::new(\u0026result.password).map_err(AppError::from)?;\n\n\t\t\t// Attempt to match the password hashes\n\t\t\tif let Err(_) =\n\t\t\t\tArgon2::default().verify_password(payload.password.as_bytes(), \u0026parsed_hash)\n\t\t\t{\n\t\t\t\treturn Err(AppError::BadRequest(\"invalid credentials\".to_string()));\n\t\t\t}\n\n\t\t\tset_cookie(result.id, false, cookies, \u0026key);\n\n\t\t\treturn Ok(());\n\t\t}\n\t\tErr(_) =\u003e {\n\t\t\treturn Err(AppError::BadRequest(\"invalid credentials\".to_string()));\n\t\t}\n\t}\n}\n\n/// Returns whether the user has a valid auth token.\n/// Hit this route to validate the `auth-token` private cookie.\n///\n/// # Method\n/// `GET /api/account/validate`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - user has a valid auth token\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n#[utoipa::path(\n\tget,\n\tpath=\"/validate\",\n\tsummary=\"Whether the user has a valid auth-token\",\n\tdescription=\"Returns 200 if token is valid, or 401 if invalid or nonexistant.\",\n\tresponses(\n\t\t(status=200, description=\"User has a valid cookie\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_validate(Extension(user): Extension\u003cAuthUser\u003e) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/validate 'api_validate' - User ID: {}\",\n\t\tuser.id\n\t);\n\tOk(())\n}\n\n/// Get information about the user\n///\n/// # Method\n/// `GET /api/account/current`\n///\n/// # Responses\n/// - `200 OK` - with body: [CurrentResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/account/current\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/current\",\n\tsummary=\"Get account information\",\n\tdescription=\"Returns the user's non-sensitive account information.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"User's non-sensitive account information\",\n\t\t\tbody=CurrentResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\t\"first_name\": \"First\",\n\t\t\t\t\"last_name\": \"Last\",\n\t\t\t\t\"budget_preference\": \"MediumBudget\",\n\t\t\t\t\"risk_preference\": \"Adventurer\",\n\t\t\t\t\"food_allergies\": \"peanuts,vegetarian,pollen\",\n\t\t\t\t\"disabilities\": \"knee replacement\",\n\t\t\t\t\"profile_picture\": \"base64-txt\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_current(\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n) -\u003e ApiResult\u003cJson\u003cCurrentResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/current 'api_current' - User ID: {}\",\n\t\tuser.id\n\t);\n\t// Load current user's full account row\n\tlet account = sqlx::query_as!(\n\t\tCurrentResponse,\n\t\tr#\"\n        SELECT\n            email,\n            first_name,\n            last_name,\n            budget_preference as \"budget_preference: BudgetBucket\",\n            risk_preference as \"risk_preference: RiskTolerence\",\n            COALESCE(food_allergies, '') as \"food_allergies!: String\",\n            COALESCE(disabilities, '') as \"disabilities!: String\",\n\t\t\tCOALESCE(profile_picture, '') as \"profile_picture!: String\"\n        FROM accounts\n        WHERE id = $1\n        \"#,\n\t\tuser.id\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(Json(account))\n}\n\n/// Update information about the user\n///\n/// # Method\n/// `POST /api/account/update`\n///\n/// # Request Body\n/// - `email`: A valid email address (string).\n/// - 'first_name': The user's first name (string).\n/// - 'last_name': The user's last name (string).\n/// - 'password': The user's password (string).\n/// - 'budget_preference': The user's budget preference (string).\n/// - 'risk_preference': The user's risk preference (string).\n/// - 'food_allergies': The user's allergies (string).\n/// - 'disabilities': The user's disabilities (string).\n/// - 'profile_picture': The user's profile pic (string)\n///\n/// # Responses\n/// - `200 OK` - with body: [UpdateResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/update\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"email\": \"\",\n///         \"first_name\": \"\",\n///         \"last_name\": \"\",\n///         \"password\": \"\",\n///         \"budget_preference\": \"\",\n///         \"risk_preference\": \"\",\n///         \"food_allergies\": \"\",\n///         \"disabilities\": \"\",\n/// \t\t\"profile_picture\": \"\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/update\",\n\tsummary=\"Update information about the user\",\n\tdescription=\"Update account info with provided data.\",\n\trequest_body(\n\t\tcontent=UpdateRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Non-null fields will update that field. Null fields will not update that field.\",\n\t\texample=json!({\n\t\t\t\"budget_preference\": \"LowBudget\"\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Account info updated successfully\",\n\t\t\tbody=UpdateResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\t\"first_name\": \"First\",\n\t\t\t\t\"last_name\": \"last\",\n\t\t\t\t\"budget_preference\": \"LowBudget\",\n\t\t\t\t\"risk_preference\": \"Adventurer\",\n\t\t\t\t\"food_allergies\": \"peanuts,vegetarian,pollen\",\n\t\t\t\t\"disabilities\": \"knee replacement\",\n\t\t\t\t\"profile_picture\": \"base64-txt\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_update(\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tJson(payload): Json\u003cUpdateRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cUpdateResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/update 'api_update' - User ID: {} Payload: {:?}\",\n\t\tuser.id, payload\n\t);\n\n\t// If password is being updated, verify current password first\n\tif let Some(_) = \u0026payload.password {\n\t\tif let Some(current_pw) = \u0026payload.current_password {\n\t\t\t// Get current password hash from database\n\t\t\tlet account_row =\n\t\t\t\tsqlx::query!(r#\"SELECT password FROM accounts WHERE id = $1\"#, user.id)\n\t\t\t\t\t.fetch_one(\u0026pool)\n\t\t\t\t\t.await\n\t\t\t\t\t.map_err(AppError::from)?;\n\n\t\t\t// Verify current password\n\t\t\tlet parsed_hash = PasswordHash::new(\u0026account_row.password).map_err(AppError::from)?;\n\t\t\tif let Err(_) = Argon2::default().verify_password(current_pw.as_bytes(), \u0026parsed_hash) {\n\t\t\t\treturn Err(AppError::BadRequest(\n\t\t\t\t\t\"Current password is incorrect\".to_string(),\n\t\t\t\t));\n\t\t\t}\n\t\t} else {\n\t\t\treturn Err(AppError::BadRequest(\n\t\t\t\t\"Current password is required to change password\".to_string(),\n\t\t\t));\n\t\t}\n\t}\n\n\t// If password provided, hash it before update\n\tlet hashed_password: Option\u003cString\u003e = if let Some(pw) = \u0026payload.password {\n\t\tlet salt = SaltString::generate(\u0026mut OsRng);\n\t\tlet argon2 = Argon2::default();\n\t\tSome(\n\t\t\targon2\n\t\t\t\t.hash_password(pw.as_bytes(), \u0026salt)\n\t\t\t\t.map_err(AppError::from)?\n\t\t\t\t.to_string(),\n\t\t)\n\t} else {\n\t\tNone\n\t};\n\n\tlet account = sqlx::query_as!(\n\t\tUpdateResponse,\n\t\tr#\"\n        UPDATE accounts SET\n            email = COALESCE($1, email),\n            first_name = COALESCE($2, first_name),\n            last_name = COALESCE($3, last_name),\n            password = COALESCE($4, password),\n            budget_preference = COALESCE($5, budget_preference),\n            risk_preference = COALESCE($6, risk_preference),\n            food_allergies = COALESCE($7, food_allergies),\n            disabilities = COALESCE($8, disabilities),\n\t\t\tprofile_picture = COALESCE($9, profile_picture)\n\t\t\t\n        WHERE id = $10\n        RETURNING\n            email,\n            first_name,\n            last_name,\n            budget_preference as \"budget_preference: BudgetBucket\",\n            risk_preference as \"risk_preference: RiskTolerence\",\n            food_allergies,\n            disabilities,\n\t\t\tprofile_picture\n        \"#,\n\t\tpayload.email,\n\t\tpayload.first_name,\n\t\tpayload.last_name,\n\t\thashed_password,\n\t\tpayload.budget_preference as Option\u003cBudgetBucket\u003e,\n\t\tpayload.risk_preference as Option\u003cRiskTolerence\u003e,\n\t\tpayload.food_allergies,\n\t\tpayload.disabilities,\n\t\tpayload.profile_picture,\n\t\tuser.id\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(Json(account))\n}\n\n/// Logout by setting cookie to expired.\n///\n/// # Method\n/// `GET /api/account/logout`\n///\n/// # Responses\n/// - `200 OK` - with body: [UpdateResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/account/logout\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/logout\",\n\tsummary=\"Logout by returning with expired cookie\",\n\tdescription=\"Sets the HTTP-only cookie as expired, which deauthenticates the user.\",\n\tresponses(\n\t\t(status=200, description=\"Logged out successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_logout\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/logout 'api_logout' - User ID: {}\",\n\t\tuser.id\n\t);\n\tset_cookie(user.id, true, cookies, \u0026key);\n\tOk(())\n}\n\n/// Create the account routes with authentication middleware.\n///\n/// # Routes\n/// ## Protected Routes (require authentication)\n/// - `POST /update` - Update user account information\n/// - `GET /current` - Get current user's account details\n/// - `POST /validate` - Validate authentication token\n/// - `GET /logout` - Logout by making cookie expired\n///\n/// ## Public Routes (no authentication required)\n/// - `POST /signup` - Create a new user account\n/// - `POST /login` - Authenticate user and set auth cookie\n///\n/// # Middleware\n/// Protected routes are secured by `middleware_auth` which validates the `auth-token` cookie.\n/// Public routes (signup/login) are accessible without authentication.\npub fn account_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/update\", post(api_update))\n\t\t.route(\"/current\", get(api_current))\n\t\t.route(\"/validate\", get(api_validate))\n\t\t.route(\n\t\t\t\"/logout\",\n\t\t\tget(|mut c, k, u| async move { api_logout::\u003cCookies\u003e(\u0026mut c, k, u).await }),\n\t\t)\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n\t\t.route(\n\t\t\t\"/signup\",\n\t\t\tpost(|mut c, k, p, b| async move { api_signup::\u003cCookies\u003e(\u0026mut c, k, p, b).await }),\n\t\t)\n\t\t.route(\n\t\t\t\"/login\",\n\t\t\tpost(|mut c, k, p, b| async move { api_login::\u003cCookies\u003e(\u0026mut c, k, p, b).await }),\n\t\t)\n}\n","traces":[{"line":73,"address":[38289616,38289863],"length":1,"stats":{"Line":1}},{"line":74,"address":[38289737,38289644],"length":1,"stats":{"Line":2}},{"line":90,"address":[37826496,37829600,37832673,37829569,37829575,37832679],"length":1,"stats":{"Line":2}},{"line":92,"address":[37826561,37829665],"length":1,"stats":{"Line":2}},{"line":93,"address":[37826623,37829727],"length":1,"stats":{"Line":2}},{"line":94,"address":[37829765,37826661],"length":1,"stats":{"Line":2}},{"line":98,"address":[37829976,37830064,37829805,37826701,37826960,37826872],"length":1,"stats":{"Line":6}},{"line":99,"address":[37829978,37826874],"length":1,"stats":{"Line":1}},{"line":108,"address":[37829831,37826727],"length":1,"stats":{"Line":2}},{"line":110,"address":[37826992,37830096],"length":1,"stats":{"Line":2}},{"line":112,"address":[37827237,37830341,37830420,37830807,37827703,37827316],"length":1,"stats":{"Line":5}},{"line":119,"address":[37832111,37830770,37829259,37832363,37829007,37829173,37832528,37827666,37832277,37829424],"length":1,"stats":{"Line":10}},{"line":120,"address":[37829181,37832285,37829132,37832217,37829113,37829547,37832236,37832651],"length":1,"stats":{"Line":4}},{"line":122,"address":[37832387,37829283],"length":1,"stats":{"Line":2}},{"line":124,"address":[37832450,37832422,37829346,37829318,37829336,37832440],"length":1,"stats":{"Line":6}},{"line":125,"address":[37832442,37829338],"length":1,"stats":{"Line":0}},{"line":127,"address":[37829328,37832432],"length":1,"stats":{"Line":2}},{"line":129,"address":[37829377,37832481],"length":1,"stats":{"Line":2}},{"line":130,"address":[37832568,37829464],"length":1,"stats":{"Line":2}},{"line":134,"address":[37829518,37832622],"length":1,"stats":{"Line":2}},{"line":195,"address":[37836080,37835952],"length":1,"stats":{"Line":2}},{"line":201,"address":[37837219,37836667,37844571,37836813,37844717,37845123],"length":1,"stats":{"Line":5}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[37837187,37838470,37846374,37845091],"length":1,"stats":{"Line":4}},{"line":208,"address":[37838559,37846463],"length":1,"stats":{"Line":1}},{"line":212,"address":[37847555,37838755,37838825,37839373,37846659,37847277,37839428,37846729,37847142,37839651,37838693,37847332,37839238,37846597],"length":1,"stats":{"Line":6}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[37839312,37847216],"length":1,"stats":{"Line":2}},{"line":215,"address":[37847310,37847648,37839406,37836725,37839744,37839358,37844629,37847394,37839490,37847262],"length":1,"stats":{"Line":8}},{"line":217,"address":[37839889,37839766,37847793,37847670],"length":1,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[37839903,37841578,37849482,37847807],"length":1,"stats":{"Line":2}},{"line":221,"address":[37847714,37839810],"length":1,"stats":{"Line":0}},{"line":222,"address":[37839871,37841707,37849611,37847775],"length":1,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[37847849,37839945],"length":1,"stats":{"Line":2}},{"line":231,"address":[37847879,37839975],"length":1,"stats":{"Line":2}},{"line":232,"address":[37841573,37848045,37847905,37840207,37849477,37840141,37840001,37848111],"length":1,"stats":{"Line":4}},{"line":233,"address":[37840018,37847922],"length":1,"stats":{"Line":2}},{"line":234,"address":[37848022,37840175,37840118,37848079],"length":1,"stats":{"Line":2}},{"line":238,"address":[37850059,37841310,37840563,37840378,37842155,37840493,37848282,37848397,37848467,37841551,37841493,37849214,37849397,37849455],"length":1,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[37841381,37849285],"length":1,"stats":{"Line":2}},{"line":248,"address":[39033410,39032850],"length":1,"stats":{"Line":8}},{"line":250,"address":[37850121,37842217],"length":1,"stats":{"Line":2}},{"line":251,"address":[37850232,37842328],"length":1,"stats":{"Line":2}},{"line":252,"address":[37842791,37850246,37842342,37850695],"length":1,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[37842751,37850655],"length":1,"stats":{"Line":2}},{"line":259,"address":[37843946,37851850],"length":1,"stats":{"Line":2}},{"line":261,"address":[37850158,37842254,37851888,37843984],"length":1,"stats":{"Line":0}},{"line":317,"address":[37857680,37857808],"length":1,"stats":{"Line":2}},{"line":323,"address":[37862854,37858422,37863275,37858843,37858297,37862729],"length":1,"stats":{"Line":5}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[37860058,37858796,37860125,37860529,37860664,37863228,37864557,37864961,37865096,37860936,37860716,37864490,37865148,37865368],"length":1,"stats":{"Line":6}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[37865035,37860603],"length":1,"stats":{"Line":2}},{"line":342,"address":[37865210,37858355,37862787,37865081,37865129,37860649,37860697,37860778,37865496,37861064],"length":1,"stats":{"Line":8}},{"line":344,"address":[37861078,37865510],"length":1,"stats":{"Line":2}},{"line":345,"address":[37865581,37861149],"length":1,"stats":{"Line":2}},{"line":347,"address":[37861857,37865645,37865720,37866289,37861213,37861288],"length":1,"stats":{"Line":4}},{"line":350,"address":[37861515,37865947],"length":1,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[37861632,37866136,37866064,37861704],"length":1,"stats":{"Line":2}},{"line":356,"address":[37866103,37861671],"length":1,"stats":{"Line":1}},{"line":358,"address":[37866275,37861843],"length":1,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[37861115,37861971,37865547,37866403],"length":1,"stats":{"Line":2}},{"line":395,"address":[42242836,42242832],"length":1,"stats":{"Line":4}},{"line":396,"address":[37870306,37870202,37870774],"length":1,"stats":{"Line":2}},{"line":400,"address":[37870696],"length":1,"stats":{"Line":1}},{"line":449,"address":[42248448],"length":1,"stats":{"Line":1}},{"line":453,"address":[37872450,37872576,37872997],"length":1,"stats":{"Line":3}},{"line":458,"address":[37874202,37875154,37874851,37874673,37875230,37874805,37874269,37872950,37875094],"length":1,"stats":{"Line":4}},{"line":475,"address":[37874747],"length":1,"stats":{"Line":1}},{"line":476,"address":[39200544],"length":1,"stats":{"Line":4}},{"line":477,"address":[37875131,37875198],"length":1,"stats":{"Line":1}},{"line":479,"address":[37875334],"length":1,"stats":{"Line":1}},{"line":558,"address":[42256128],"length":1,"stats":{"Line":1}},{"line":563,"address":[37879400,37879826,37879254],"length":1,"stats":{"Line":3}},{"line":569,"address":[37879774],"length":1,"stats":{"Line":1}},{"line":570,"address":[37881237,37881389],"length":1,"stats":{"Line":2}},{"line":572,"address":[37885917,37882539,37882085,37882143,37882640,37881396,37881537,37882707,37881467,37881950],"length":1,"stats":{"Line":4}},{"line":574,"address":[37882024],"length":1,"stats":{"Line":1}},{"line":575,"address":[39198079],"length":1,"stats":{"Line":4}},{"line":576,"address":[37882675,37882617],"length":1,"stats":{"Line":1}},{"line":579,"address":[37885912,37882812,37882891],"length":1,"stats":{"Line":2}},{"line":580,"address":[37883136],"length":1,"stats":{"Line":1}},{"line":581,"address":[37883316],"length":1,"stats":{"Line":0}},{"line":582,"address":[37883267],"length":1,"stats":{"Line":0}},{"line":586,"address":[37882171],"length":1,"stats":{"Line":0}},{"line":587,"address":[37881433],"length":1,"stats":{"Line":0}},{"line":593,"address":[37883540,37883484,37881307],"length":1,"stats":{"Line":3}},{"line":594,"address":[37883508],"length":1,"stats":{"Line":1}},{"line":595,"address":[37883545],"length":1,"stats":{"Line":1}},{"line":597,"address":[37884241,37883747,37883681],"length":1,"stats":{"Line":1}},{"line":598,"address":[37883572],"length":1,"stats":{"Line":1}},{"line":599,"address":[37883715,37883658],"length":1,"stats":{"Line":1}},{"line":600,"address":[37883884],"length":1,"stats":{"Line":1}},{"line":603,"address":[37883523],"length":1,"stats":{"Line":1}},{"line":606,"address":[37884316,37885655,37885838,37884118,37884089,37886114,37886253,37885890,37883964,37884246,37886177],"length":1,"stats":{"Line":6}},{"line":635,"address":[37884068],"length":1,"stats":{"Line":1}},{"line":636,"address":[37884097],"length":1,"stats":{"Line":1}},{"line":642,"address":[37885726],"length":1,"stats":{"Line":1}},{"line":643,"address":[37879333,37885823,37885871,37885930,37886124],"length":1,"stats":{"Line":4}},{"line":644,"address":[37886154,37886221],"length":1,"stats":{"Line":1}},{"line":646,"address":[37886357],"length":1,"stats":{"Line":1}},{"line":680,"address":[37893584],"length":1,"stats":{"Line":1}},{"line":685,"address":[37893925,37894440,37894029],"length":1,"stats":{"Line":2}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[37894403],"length":1,"stats":{"Line":1}},{"line":690,"address":[37895619],"length":1,"stats":{"Line":1}},{"line":709,"address":[42226212,42225216,42226187],"length":1,"stats":{"Line":1}},{"line":710,"address":[42225404,42225615,42226046,42226116,42225989,42225350,42225672,42225223,42225749,42225481,42225538,42225875,42225806,42225912],"length":1,"stats":{"Line":14}},{"line":711,"address":[42225309,42226283,42225302,42225409,42225363],"length":1,"stats":{"Line":3}},{"line":712,"address":[42225494,42225433,42225543,42226271,42225440],"length":1,"stats":{"Line":3}},{"line":713,"address":[42225677,42225574,42225567,42226259,42225628],"length":1,"stats":{"Line":3}},{"line":716,"address":[37832704,37833359,37832816,37832859,37833162,37832752],"length":1,"stats":{"Line":5}},{"line":718,"address":[42225834,42225827,42225917,42226235,42225888],"length":1,"stats":{"Line":3}},{"line":721,"address":[37833488,37834065,37833616,37834272,37833924,37833659,37833543],"length":1,"stats":{"Line":5}},{"line":725,"address":[37834455,37834791,37834929,37834571,37835130,37834400,37834528],"length":1,"stats":{"Line":5}}],"covered":102,"coverable":129},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","chat.rs"],"content":"use axum::{\n\tExtension, Json,\n\textract::Path,\n\trouting::{delete, get, post},\n};\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse utoipa::OpenApi;\n\nuse crate::{\n\tagent::configs::orchestrator::AgentType,\n\tcontrollers::{AxumRouter, itinerary::insert_event_list},\n\terror::{ApiResult, AppError},\n\tglobal::MESSAGE_PAGE_LEN,\n\thttp_models::{\n\t\tchat_session::{\n\t\t\tChatsResponse, NewChatResponse, ProgressRequest, ProgressResponse, RenameRequest,\n\t\t},\n\t\tevent::Event,\n\t\titinerary::{EventDay, Itinerary},\n\t\tmessage::{\n\t\t\tMessage, MessagePageRequest, MessagePageResponse, SendMessageRequest,\n\t\t\tSendMessageResponse, UpdateMessageRequest,\n\t\t},\n\t},\n\tmiddleware::{AuthUser, middleware_auth},\n\tsql_models::{\n\t\tLlmProgress,\n\t\tmessage::{ChatSessionRow, MessageRow},\n\t},\n\tswagger::SecurityAddon,\n};\n\nuse langchain_rust::chain::Chain;\nuse langchain_rust::prompt_args;\nuse tracing::{debug, error, info};\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_chats,\n\t\tapi_new_chat,\n\t\tapi_message_page,\n\t\tapi_send_message,\n\t\tapi_update_message,\n\t\tapi_delete_chat,\n\t\tapi_rename,\n\t\tapi_progress\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity((\"set-cookie\"=[])),\n    info(\n    \ttitle=\"Chat Routes\",\n    \tdescription = \"API endpoints dealing with chatting and the home page.\"\n    ),\n    tags((name=\"Chat\"))\n)]\npub struct ChatApiDoc;\n\n/// Sends message and latest itinerary in chat session to llm, and waits for response.\n///\n/// When the bot replies, it's message and itinerary are inserted into the db.\n/// # Warning!\n/// Assumes the user's message has already been inserted into the db.\nasync fn send_message_to_llm(\n\ttext: \u0026str,\n\taccount_id: i32,\n\tchat_session_id: i32,\n\titinerary_id: Option\u003ci32\u003e,\n\tpool: \u0026PgPool,\n\tagent: \u0026AgentType,\n\tchat_session_id_atomic: \u0026std::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e,\n\tcontext_store: \u0026crate::agent::models::context::SharedContextStore,\n) -\u003e ApiResult\u003cMessage\u003e {\n\t// Give the LLM an itinerary for context\n\tlet itinerary_id = match itinerary_id {\n\t\tSome(id) =\u003e Some(id), //use the provided itinerary\n\t\tNone =\u003e {\n\t\t\t//use the latest itinerary from the chat session\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tSELECT m.itinerary_id\n\t\t\t\tFROM messages m\n\t\t\t\tINNER JOIN chat_sessions c\n\t\t\t\tON m.chat_session_id=c.id\n\t\t\t\tWHERE\n\t\t\t\t\tc.account_id=$1 AND\n\t\t\t\t\tc.id=$2 AND\n\t\t\t\t\tm.itinerary_id IS NOT NULL\n\t\t\t\tORDER BY m.timestamp DESC\n\t\t\t\tLIMIT 1;\n\t\t\t\t\"#,\n\t\t\t\taccount_id,\n\t\t\t\tchat_session_id\n\t\t\t)\n\t\t\t.fetch_optional(pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.map(|record| record.itinerary_id.unwrap())\n\t\t}\n\t};\n\tlet _context_itinerary = match itinerary_id {\n\t\tSome(id) =\u003e Some(\n\t\t\tcrate::controllers::itinerary::api_get_itinerary(\n\t\t\t\tExtension(AuthUser { id: account_id }),\n\t\t\t\taxum::extract::Path(id),\n\t\t\t\tExtension(pool.clone()),\n\t\t\t)\n\t\t\t.await?,\n\t\t),\n\t\tNone =\u003e None,\n\t};\n\n\t// Always invoke the agent (it will use MockLLM when DEPLOY_LLM != \"1\")\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\taccount_id = account_id,\n\t\t\"Invoking orchestrator agent\"\n\t);\n\tdebug!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tuser_input = text,\n\t\t\"Orchestrator agent input\"\n\t);\n\n\t// We no longer persist live agent context in the database; all dynamic context\n\t// lives in the in-memory SharedContextStore. These DB-based context logs are\n\t// intentionally removed to avoid confusion.\n\n\t// Initialize context with chat_session_id and user_id BEFORE agent runs\n\t// This prevents race conditions from global atomics\n\t// IMPORTANT: Only initialize if context doesn't exist - preserve existing trip_context!\n\t{\n\t\tuse crate::agent::models::context::{ContextData, TripContext};\n\t\tlet mut store_guard = context_store.write().await;\n\n\t\t// Only insert if this chat_session doesn't have context yet\n\t\tif !store_guard.contains_key(\u0026chat_session_id) {\n\t\t\tstore_guard.insert(\n\t\t\t\tchat_session_id,\n\t\t\t\tContextData {\n\t\t\t\t\tchat_session_id,\n\t\t\t\t\tuser_id: account_id,\n\t\t\t\t\tuser_profile: None,\n\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\ttrip_context: TripContext::default(),\n\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\tevents: vec![],\n\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\tconstraints: vec![],\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tchat_id = chat_session_id,\n\t\t\t\t\"Initialized new context for chat session\"\n\t\t\t);\n\t\t} else {\n\t\t\t// Context exists - just update user_id in case it changed\n\t\t\tif let Some(ctx) = store_guard.get_mut(\u0026chat_session_id) {\n\t\t\t\tctx.user_id = account_id;\n\t\t\t}\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tchat_id = chat_session_id,\n\t\t\t\t\"Reusing existing context for chat session\"\n\t\t\t);\n\t\t}\n\t}\n\n\t// Set the atomic so tools can look up the context\n\tuse std::sync::atomic::Ordering;\n\tchat_session_id_atomic.store(chat_session_id, Ordering::Relaxed);\n\n\t// Invoke the agent\n\tlet ai_text = {\n\t\tlet agent_guard = agent.lock().await;\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\tchat_session_id = chat_session_id,\n\t\t\tinput_text = text,\n\t\t\t\"Invoking orchestrator agent\"\n\t\t);\n\n\t\tagent_guard\n\t\t\t.invoke(prompt_args! {\n\t\t\t\t\"input\" =\u003e text,\n\t\t\t})\n\t\t\t.await\n\t\t\t.map_err(|e| {\n\t\t\t\terror!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\terror = %e,\n\t\t\t\t\terror_debug = ?e,\n\t\t\t\t\t\"Orchestrator agent error - full details\"\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\terror = %e,\n\t\t\t\t\t\"Orchestrator agent error\"\n\t\t\t\t);\n\t\t\t\tAppError::Internal(format!(\"AI agent error: {}\", e))\n\t\t\t})?\n\t};\n\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tresponse_length = ai_text.len(),\n\t\t\"Orchestrator agent completed\"\n\t);\n\tdebug!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tresponse = ai_text,\n\t\t\"Orchestrator agent output\"\n\t);\n\n\t// Context state AFTER agent invocation is now entirely in-memory as well.\n\t//\n\t// SAFETY GUARD: If the orchestrator ever returns a user-visible string\n\t// that still contains the internal \"Ready for research\" phrase, treat it\n\t// as a pipeline-ready signal instead of sending it to the user.\n\tif ai_text.contains(\"Ready for research\") {\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\tchat_session_id = chat_session_id,\n\t\t\t\"Detected 'Ready for research' sentinel in orchestrator output; refusing to return it directly to user\"\n\t\t);\n\n\t\t// Try to return the most recent non-user message instead (typically the\n\t\t// last clarification the user already saw). If none exists, fall\n\t\t// through and let normal handling occur.\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\tFROM messages\n\t\t\tWHERE chat_session_id = $1 AND is_user = FALSE\n\t\t\tORDER BY timestamp DESC\n\t\t\tLIMIT 1\n\t\t\t\"#,\n\t\t\tchat_session_id\n\t\t)\n\t\t.fetch_optional(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tif let Some(msg) = record {\n\t\t\treturn Ok(Message {\n\t\t\t\tid: msg.id,\n\t\t\t\tis_user: false,\n\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\ttext: msg.text,\n\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check if RespondToUserTool already inserted the message\n\t// Format: \"MESSAGE_INSERTED:\u003cmessage_id\u003e:\u003cmessage_text\u003e\"\n\tif ai_text.starts_with(\"MESSAGE_INSERTED:\") {\n\t\tlet parts: Vec\u003c\u0026str\u003e = ai_text.splitn(3, ':').collect();\n\t\tif parts.len() == 3 {\n\t\t\tif let Ok(message_id) = parts[1].parse::\u003ci32\u003e() {\n\t\t\t\t// Fetch the message that was already inserted by RespondToUserTool\n\t\t\t\tlet record = sqlx::query!(\n\t\t\t\t\tr#\"\n\t\t\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\t\t\tFROM messages\n\t\t\t\t\tWHERE id = $1 AND chat_session_id = $2\n\t\t\t\t\t\"#,\n\t\t\t\t\tmessage_id,\n\t\t\t\t\tchat_session_id\n\t\t\t\t)\n\t\t\t\t.fetch_optional(pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(AppError::from)?;\n\n\t\t\t\tif let Some(msg) = record {\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\t\tmessage_id = msg.id,\n\t\t\t\t\t\t\"Message already inserted by RespondToUserTool, returning it\"\n\t\t\t\t\t);\n\t\t\t\t\treturn Ok(Message {\n\t\t\t\t\t\tid: msg.id,\n\t\t\t\t\t\tis_user: false,\n\t\t\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\t\t\ttext: msg.text,\n\t\t\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the response is plain readable text (not JSON, not MESSAGE_INSERTED),\n\t// it's likely from ask_for_clarification tool which already inserted it\n\t// Fetch the most recent non-user message for this chat session\n\tif !ai_text.trim().starts_with('{')\n\t\t\u0026\u0026 !ai_text.trim().starts_with('[')\n\t\t\u0026\u0026 !ai_text.starts_with(\"MESSAGE_INSERTED:\")\n\t\t\u0026\u0026 !ai_text.starts_with(\"FINAL_ANSWER:\")\n\t{\n\t\t// This looks like plain readable text - tool already inserted it, so fetch it\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\tFROM messages\n\t\t\tWHERE chat_session_id = $1 AND is_user = FALSE\n\t\t\tORDER BY timestamp DESC\n\t\t\tLIMIT 1\n\t\t\t\"#,\n\t\t\tchat_session_id\n\t\t)\n\t\t.fetch_optional(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tif let Some(msg) = record {\n\t\t\t// Verify the text matches (tool just inserted it)\n\t\t\tif msg.text.trim() == ai_text.trim() {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\tmessage_id = msg.id,\n\t\t\t\t\t\"Found matching message inserted by tool, returning it\"\n\t\t\t\t);\n\t\t\t\treturn Ok(Message {\n\t\t\t\t\tid: msg.id,\n\t\t\t\t\tis_user: false,\n\t\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\t\ttext: msg.text,\n\t\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if we're using MockLLM\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tif use_mock {\n\t\t// MockLLM fallback: Create and insert a dummy itinerary\n\t\tlet mut ai_itinerary = Itinerary {\n\t\t\tid: 0,\n\t\t\tstart_date: NaiveDate::parse_from_str(\"2025-11-05\", \"%Y-%m-%d\").unwrap(),\n\t\t\tend_date: NaiveDate::parse_from_str(\"2025-11-06\", \"%Y-%m-%d\").unwrap(),\n\t\t\tevent_days: vec![\n\t\t\t\tEventDay {\n\t\t\t\t\tmorning_events: vec![Event {\n\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1114 Shannon Ln\")),\n\t\t\t\t\t\tpostal_code: Some(17013),\n\t\t\t\t\t\tcity: Some(String::from(\"Carlisle\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Hike\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"A beautiful stroll along a river in this cute small town.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Family Walking Path\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tafternoon_events: vec![Event {\n\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"200 E 42nd St\")),\n\t\t\t\t\t\tpostal_code: Some(10017),\n\t\t\t\t\t\tcity: Some(String::from(\"New York\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"World famous art museum with a focus on modern works, including Starry Starry Night by VanGough.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Museum of Modern Art- MoMA\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tevening_events: vec![Event {\n\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 S Broad St\")),\n\t\t\t\t\t\tpostal_code: Some(19107),\n\t\t\t\t\t\tcity: Some(String::from(\"Philadelphia\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Concert\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Music center which hosts local and national bands.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Jazz night at Broad Street\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tdate: NaiveDate::parse_from_str(\"2025-11-05\", \"%Y-%m-%d\").unwrap(),\n\t\t\t\t},\n\t\t\t\tEventDay {\n\t\t\t\t\tmorning_events: vec![Event {\n\t\t\t\t\t\tid: 5,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 Citizens Bank Way\")),\n\t\t\t\t\t\tpostal_code: Some(19148),\n\t\t\t\t\t\tcity: Some(String::from(\"Philadelphia\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Sports\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"A Phillies baseball game is a must-do for locals and visitors alike.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Phillies Baseball Game\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tafternoon_events: vec![Event {\n\t\t\t\t\t\tid: 7,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 Rue de la Seine\")),\n\t\t\t\t\t\tpostal_code: Some(0),\n\t\t\t\t\t\tcity: Some(String::from(\"Paris\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"France\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Explore the beautiful landmark of Paris.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Eiffel Tower\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tevening_events: vec![Event {\n\t\t\t\t\t\tid: 8,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"3 Rue de la Museu\")),\n\t\t\t\t\t\tpostal_code: Some(0),\n\t\t\t\t\t\tcity: Some(String::from(\"Paris\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"France\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Wander the halls of the world famous art museum.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"le Louvre\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tdate: NaiveDate::parse_from_str(\"2025-11-06\", \"%Y-%m-%d\").unwrap(),\n\t\t\t\t},\n\t\t\t],\n\t\t\tchat_session_id: None,\n\t\t\ttitle: String::from(\"World Tour 11/5-15 2025\"),\n\t\t\tunassigned_events: vec![],\n\t\t};\n\n\t\t// Insert generated itinerary into db\n\t\tlet inserted_itinerary_id = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title)\n\t\t\tVALUES ($1, FALSE, $2, $3, $4, FALSE, $5)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\taccount_id,\n\t\t\tai_itinerary.start_date,\n\t\t\tai_itinerary.end_date,\n\t\t\tchat_session_id,\n\t\t\tai_itinerary.title\n\t\t)\n\t\t.fetch_one(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.id;\n\n\t\tai_itinerary.id = inserted_itinerary_id;\n\n\t\t// Insert itinerary events\n\t\tinsert_event_list(ai_itinerary, pool).await?;\n\n\t\t// Insert bot message with itinerary\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, $2, FALSE, NOW(), $3)\n\t\t\tRETURNING id, timestamp;\n\t\t\t\"#,\n\t\t\tchat_session_id,\n\t\t\tinserted_itinerary_id,\n\t\t\tai_text.clone()\n\t\t)\n\t\t.fetch_one(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tlet (bot_message_id, timestamp) = (record.id, record.timestamp);\n\n\t\treturn Ok(Message {\n\t\t\tid: bot_message_id,\n\t\t\tis_user: false,\n\t\t\ttimestamp,\n\t\t\ttext: ai_text,\n\t\t\titinerary_id: Some(inserted_itinerary_id),\n\t\t});\n\t}\n\n\t// When using real LLM: The respond_to_user tool handles message insertion,\n\t// so we should never reach this point. If we do, insert a plain message without itinerary.\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\t\"Fallback: Inserting message without itinerary (real LLM path)\"\n\t);\n\n\tlet record = sqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\tRETURNING id, timestamp;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tai_text.clone()\n\t)\n\t.fetch_one(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet (bot_message_id, timestamp) = (record.id, record.timestamp);\n\n\tlet pool = pool.clone();\n\ttokio::spawn(async move {\n\t\t_ = sqlx::query!(\n\t\t\tr#\"UPDATE chat_sessions\n\t\tSET llm_progress=$1\n\t\tWHERE id=$2 AND account_id=$3;\"#,\n\t\t\tLlmProgress::Ready as _,\n\t\t\tchat_session_id,\n\t\t\taccount_id,\n\t\t)\n\t\t.execute(\u0026pool)\n\t\t.await;\n\t});\n\n\tOk(Message {\n\t\tid: bot_message_id,\n\t\tis_user: false,\n\t\ttimestamp,\n\t\ttext: ai_text,\n\t\titinerary_id: None,\n\t})\n}\n\n/// Fetch all the chat session ids belonging to the user to made the request\n///\n/// # Method\n/// `GET /api/chat/chats`\n///\n/// # Responses\n/// - `200 OK` - [ChatsResponse] - list of chat session ids\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/chat/chats\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/chats\",\n\tsummary=\"Fetch user's chat session IDs\",\n\tdescription=\"Fetches a list of all chat session IDs belonging to the user.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Successfully retrieved chat sessions\",\n\t\t\tbody=ChatsResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"chat_sessions\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"title\": \"Berlin, Germany\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 17,\n\t\t\t\t\t\t\"title\": \"Shanghai, China\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 41,\n\t\t\t\t\t\t\"title\": \"Miami, Florida, USA\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_chats(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cChatsResponse\u003e\u003e {\n\tOk(Json(ChatsResponse {\n\t\tchat_sessions: sqlx::query_as!(\n\t\t\tChatSessionRow,\n\t\t\tr#\"\n\t\t\tSELECT id, title from chat_sessions\n\t\t\tWHERE account_id=$1;\n\t\t\t\"#,\n\t\t\tuser.id\n\t\t)\n\t\t.fetch_all(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?,\n\t}))\n}\n\n/// Get a page of messages from this chat session belonging to the user who made the request\n///\n/// # Method\n/// `POST /api/chat/messagePage`\n///\n/// # Request Body\n/// - [MessagePageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [MessagePageResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// Fetch latest massages\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/messagePage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 3\n///       }'\n/// ```\n/// Fetch messages ending with specific message\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/messagePage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 3,\n///         \"message_id\": 6\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/messagePage\",\n\tsummary=\"Fetch a page of messages from a chat session\",\n\tdescription=\"If no message id is provided, this fetches the latest messages from the chat session. If a message id is provided, that message and messages preceeding it will be fetched.\",\n\trequest_body(\n\t\tcontent=MessagePageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Message id may be omitted to get the latest messages\",\n\t\texamples(\n\t\t\t(\"Latest Messages\"=(\n\t\t\t\tsummary=\"Fetch the latest messages from a chat session\",\n\t\t\t\tvalue=json!({\n\t\t\t\t\t\"chat_session_id\": 4\n\t\t\t\t})\n\t\t\t)),\n\t\t\t(\"Specific Messages\"=(\n\t\t\t\tsummary=\"Fetch a specific page of messages from a chat session\",\n\t\t\t\tvalue=json!({\n\t\t\t\t\t\"chat_session_id\": 4,\n\t\t\t\t\t\"message_id\": 4\n\t\t\t\t})\n\t\t\t))\n\t\t)\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Messages retrieved successfully\",\n\t\t\tbody=MessagePageResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texamples(\n\t\t\t\t(\"Latest Messages\"=(\n\t\t\t\t\tsummary=\"The latest messages from a chat session\",\n\t\t\t\t\tvalue=json!({\n\t\t\t\t\t\t\"message_page\": [\n\t\t\t\t\t\t\t{\"id\": 6, \"is_user\": true, \"timestamp\": \"2025-10-14 11-34-19\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 10, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-24\", \"text\": \"Bot reply\", \"itinerary_id\": 2},\n\t\t\t\t\t\t\t{\"id\": 12, \"is_user\": true, \"timestamp\": \"2025-10-14 11-34-42\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 22, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-56\", \"text\": \"Bot reply\", \"itinerary_id\": 5},\n\t\t\t\t\t\t\t{\"id\": 26, \"is_user\": true, \"timestamp\": \"2025-10-14 11-35-10\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 33, \"is_user\": false, \"timestamp\": \"2025-10-14 11-35-19\", \"text\": \"Bot reply\", \"itinerary_id\": 9},\n\t\t\t\t\t\t\t{\"id\": 39, \"is_user\": true, \"timestamp\": \"2025-10-14 11-35-31\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 44, \"is_user\": false, \"timestamp\": \"2025-10-14 11-35-54\", \"text\": \"Bot reply\", \"itinerary_id\": 14},\n\t\t\t\t\t\t\t{\"id\": 61, \"is_user\": true, \"timestamp\": \"2025-10-14 11-36-24\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 72, \"is_user\": false, \"timestamp\": \"2025-10-14 11-36-29\", \"text\": \"Bot reply\", \"itinerary_id\": 27}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"prev_message_id\": 4\n\t\t\t\t\t})\n\t\t\t\t)),\n\t\t\t\t(\"Specific Messages\"=(\n\t\t\t\t\tsummary=\"A specific page of messages from a chat session\",\n\t\t\t\t\tvalue=json!({\n\t\t\t\t\t\t\"message_page\": [\n\t\t\t\t\t\t\t{\"id\": 1, \"is_user\": true, \"timestamp\": \"2025-10-14 11-33-21\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 2, \"is_user\": false, \"timestamp\": \"2025-10-14 11-33-35\", \"text\": \"Bot reply\", \"itinerary_id\": 1},\n\t\t\t\t\t\t\t{\"id\": 3, \"is_user\": true, \"timestamp\": \"2025-10-14 11-33-45\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 4, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-01\", \"text\": \"Bot reply\", \"itinerary_id\": 1},\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"prev_message_id\": null\n\t\t\t\t\t})\n\t\t\t\t))\n\t\t\t)\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_message_page(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(MessagePageRequest {\n\t\tchat_session_id,\n\t\tmessage_id,\n\t}): Json\u003cMessagePageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cMessagePageResponse\u003e\u003e {\n\tlet mut message_page: Vec\u003cMessage\u003e = sqlx::query_as!(\n\t\tMessageRow,\n\t\tr#\"\n\t\tSELECT\n\t\t\tm.id,\n\t\t\tm.chat_session_id,\n\t\t\tm.itinerary_id,\n\t\t\tm.is_user,\n\t\t\tm.timestamp,\n\t\t\tm.text\n\t\tFROM messages m\n\t\tINNER JOIN chat_sessions c\n\t\tON m.chat_session_id=c.id\n\t\tWHERE\n\t\t\tc.id=$1 AND\n\t\t\tc.account_id=$2 AND\n\t\t\t(\n\t\t\t\t$3::int IS NULL OR\n\t\t\t\tm.timestamp \u003c= (SELECT timestamp FROM messages WHERE id=$3)\n\t\t\t)\n\t\tORDER BY m.timestamp DESC\n\t\tLIMIT $4 + 1;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id,\n\t\tmessage_id,\n\t\tMESSAGE_PAGE_LEN\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.into_iter()\n\t.rev()\n\t.map(|msg_row| Message {\n\t\tid: msg_row.id,\n\t\tis_user: msg_row.is_user,\n\t\ttimestamp: msg_row.timestamp,\n\t\ttext: msg_row.text,\n\t\titinerary_id: msg_row.itinerary_id,\n\t})\n\t.collect();\n\n\tlet prev_message_id = if message_page.len() == MESSAGE_PAGE_LEN as usize + 1 {\n\t\t// there might be a better way to do this, but it should work, and it's only O(MESSAGE_PAGE_LEN) time complexity\n\t\tSome(message_page.remove(0).id)\n\t} else {\n\t\tNone\n\t};\n\n\tOk(Json(MessagePageResponse {\n\t\tmessage_page,\n\t\tprev_message_id,\n\t}))\n}\n\n/// Update an existing message with new text, and get a message back from the LLM\n///\n/// # Method\n/// `POST /api/chat/updateMessage`\n///\n/// # Request Body\n/// - [UpdateMessageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [Message] - message from LLM\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided message id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/updateMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"message_id\": 3,\n///         \"new_text\": \"Updated message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/updateMessage\",\n\tsummary=\"Update the text of a message and wait for a reply from the LLM\",\n\tdescription=\"Updating a message deletes all proceeding messages, updates the text of the given message, and returns a response from the LLM.\",\n\trequest_body(\n\t\tcontent=UpdateMessageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Itinerary id is optional and is used to give context to the LLM.\",\n\t\texample=json!({\n\t\t\t\"message_id\": 41,\n\t\t\t\"new_text\": \"Updated message content\",\n\t\t\t\"itinerary_id\": 17\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Message updated, and LLM replied successfully\",\n\t\t\tbody=Message,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"id\": 43,\n\t\t\t\t\"is_user\": false,\n\t\t\t\t\"timestamp\": \"2025-10-14 11-38-52\",\n\t\t\t\t\"text\": \"Bot reply\",\n\t\t\t\t\"itinerary_id\": 19\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Message not found in this chat session for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_update_message(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(agent): Extension\u003cAgentType\u003e,\n\tExtension(chat_session_id_atomic): Extension\u003cstd::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e\u003e,\n\tExtension(context_store): Extension\u003ccrate::agent::models::context::SharedContextStore\u003e,\n\tJson(UpdateMessageRequest {\n\t\tmessage_id,\n\t\tnew_text,\n\t\titinerary_id,\n\t}): Json\u003cUpdateMessageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cMessage\u003e\u003e {\n\tif new_text.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\"Text cannot be empty\")));\n\t}\n\n\t// Get the message and verify ownership in one query\n\tlet message_info = sqlx::query!(\n\t\tr#\"\n\t\tSELECT m.chat_session_id, m.timestamp\n\t\tFROM messages m\n\t\tINNER JOIN chat_sessions c ON m.chat_session_id = c.id\n\t\tWHERE m.id = $1 AND c.account_id = $2 AND m.is_user = TRUE;\n\t\t\"#,\n\t\tmessage_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tlet chat_session_id = message_info.chat_session_id;\n\tlet message_timestamp = message_info.timestamp;\n\n\t// Delete future messages in this chat session only\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM messages\n\t\tWHERE chat_session_id = $1\n\t\t  AND timestamp \u003e $2\n\t\t  AND id != $3;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tmessage_timestamp,\n\t\tmessage_id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Update the user message\n\tsqlx::query!(\n\t\tr#\"\n\t\tUPDATE messages\n\t\tSET text = $1, timestamp = NOW()\n\t\tWHERE id = $2;\n\t\t\"#,\n\t\tnew_text,\n\t\tmessage_id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Call LLM and insert bot response\n\tlet bot_message = send_message_to_llm(\n\t\tnew_text.as_str(),\n\t\tuser.id,\n\t\tchat_session_id,\n\t\titinerary_id,\n\t\t\u0026pool,\n\t\t\u0026agent,\n\t\t\u0026chat_session_id_atomic,\n\t\t\u0026context_store,\n\t)\n\t.await?;\n\n\tOk(Json(bot_message))\n}\n\n/// Send a new message, and get a message back from the LLM\n///\n/// # Method\n/// `POST /api/chat/sendMessage`\n///\n/// # Request Body\n/// - [SendMessageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [SendMessageResponse] - contains message from LLM\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/sendMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 6,\n///         \"text\": \"New message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/sendMessage\",\n\tsummary=\"Send a message and wait for a reply from the LLM\",\n\tdescription=\"Ask the LLM to generate an itinerary and it should respond with one.\",\n\trequest_body(\n\t\tcontent=SendMessageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Itinerary id is optional and is used to give context to the LLM.\",\n\t\texample=json!({\n\t\t\t\"chat_session_id\": 12,\n\t\t\t\"text\": \"Make an itinerary\",\n\t\t\t\"itinerary_id\": 13\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Message sent, and LLM replied successfully\",\n\t\t\tbody=SendMessageResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"user_message_id\": 52,\n\t\t\t\t\"bot_message\": {\n\t\t\t\t\t\"id\": 53,\n\t\t\t\t\t\"is_user\": false,\n\t\t\t\t\t\"timestamp\": \"2025-10-14 11-39-10\",\n\t\t\t\t\t\"text\": \"Bot reply\",\n\t\t\t\t\t\"itinerary_id\": 14\n\t\t\t\t}\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_send_message(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(agent): Extension\u003cAgentType\u003e,\n\tExtension(chat_session_id_atomic): Extension\u003cstd::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e\u003e,\n\tExtension(context_store): Extension\u003ccrate::agent::models::context::SharedContextStore\u003e,\n\tJson(SendMessageRequest {\n\t\tchat_session_id,\n\t\ttext,\n\t\titinerary_id,\n\t}): Json\u003cSendMessageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cSendMessageResponse\u003e\u003e {\n\tif text.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\"Text cannot be empty\")));\n\t}\n\n\t// verify the given chat session belongs to this user\n\tsqlx::query!(\n\t\tr#\"\n\t\tSELECT id FROM chat_sessions\n\t\tWHERE id=$1 AND account_id=$2;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\t// insert user message into db\n\tlet user_message_id = sqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\tVALUES ($1, NULL, TRUE, NOW(), $2)\n\t\tRETURNING id;\n\t\t\"#,\n\t\tchat_session_id,\n\t\ttext\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.id;\n\n\t// call llm and insert bot response into db\n\tlet bot_message = send_message_to_llm(\n\t\ttext.as_str(),\n\t\tuser.id,\n\t\tchat_session_id,\n\t\titinerary_id,\n\t\t\u0026pool,\n\t\t\u0026agent,\n\t\t\u0026chat_session_id_atomic,\n\t\t\u0026context_store,\n\t)\n\t.await?;\n\n\tOk(Json(SendMessageResponse {\n\t\tuser_message_id,\n\t\tbot_message,\n\t}))\n}\n\n/// Get an empty chat session id belonging to this user, or create one if one doesn't exist\n///\n/// # Method\n/// `GET /api/chat/newChat`\n///\n/// # Responses\n/// - `200 OK` - with body: [NewChatResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/sendMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 6,\n///         \"text\": \"New message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/newChat\",\n\tsummary=\"Get the chat session id for an empty chat\",\n\tdescription=\"Creates a new empty chat session for this user if one doesn't already exist, and returns its chat session id.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"New chat session retrieved successfully\",\n\t\t\tbody=NewChatResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"chat_session_id\": 13\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_new_chat(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cNewChatResponse\u003e\u003e {\n\t// check to see if there's already an empty chat session before making a new one\n\tlet chat_sessions = sqlx::query!(\n\t\tr#\"\n\t\tSELECT c.id\n\t\tFROM chat_sessions c\n\t\tWHERE\n\t\t\tc.account_id=$1\n\t\t\tAND NOT EXISTS (\n\t\t\t\tSELECT 1\n\t\t\t\tFROM messages m\n\t\t\t\tWHERE m.chat_session_id=c.id\n\t\t\t);\n\t\t\"#,\n\t\tuser.id\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet chat_session_id = match chat_sessions.first() {\n\t\tSome(record) =\u003e record.id,\n\t\tNone =\u003e {\n\t\t\t// make a new chat session\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO chat_sessions (account_id, title)\n\t\t\t\tVALUES ($1, 'New Chat')\n\t\t\t\tRETURNING id\n\t\t\t\t\"#,\n\t\t\t\tuser.id\n\t\t\t)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.id\n\t\t}\n\t};\n\n\tOk(Json(NewChatResponse { chat_session_id }))\n}\n\n/// Delete the chat session with the given ID\n///\n/// # Method\n/// `DELETE /api/chat/:id`\n///\n/// # Responses\n/// - `200 OK` - chat session and associated messages and unsaved itineraries successfully deleted\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X DELETE http://localhost:3001/api/chat/7\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tdelete,\n\tpath=\"/{id}\",\n\tsummary=\"Delete the given chat session\",\n\tdescription=\"Deletes a chat session and its associated messages and unsaved, private itineraries if it belongs to the user making the request.\",\n\tresponses(\n\t\t(status=200, description=\"Chat session and associated messages and unsaved, private itineraries deleted successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be DELETE\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_delete_chat(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tPath(chat_session_id): Path\u003ci32\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// itineraries do not cascade, so we delete manually\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM itineraries\n\t\tWHERE\n\t\t\tchat_session_id=$1 AND\n\t\t\taccount_id=$2 AND\n\t\t\tis_public=FALSE AND\n\t\t\tsaved=FALSE;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// messages will cascade\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM chat_sessions\n\t\tWHERE id=$1 AND account_id=$2\n\t\tRETURNING id;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tOk(())\n}\n\n/// Rename a chat session\n///\n/// # Method\n/// `POST /api/chat/rename`\n///\n/// # Request Body\n/// - [RenameRequest]\n///\n/// # Responses\n/// - `200 OK`\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/rename\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"new_title\": \"Tokio, Japan (lmao)\",\n///         \"id\": 16\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/rename\",\n\tsummary=\"Rename a chat session\",\n\tdescription=\"Renames a chat session that belongs to this user with the given ID to the given title.\",\n\trequest_body(\n\t\tcontent=RenameRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Chat session ID must belong to the user who sent the request. New Title must not be empty string.\",\n\t\texample=json!({\n\t\t\t\"new_title\": \"Tokio, Japan (lmao)\",\n\t\t\t\"id\": 16\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Chat renamed successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_rename(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(RenameRequest { new_title, id }): Json\u003cRenameRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// no empty titles\n\tif new_title.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\n\t\t\t\"New title must not be empty\",\n\t\t)));\n\t}\n\n\t// verify chat session belongs to this user\n\tsqlx::query!(\n\t\tr#\"SELECT id from chat_sessions WHERE id=$1 AND account_id=$2\"#,\n\t\tid,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\t//change name\n\tsqlx::query!(\n\t\tr#\"UPDATE chat_sessions SET title=$1 WHERE id=$2\"#,\n\t\tnew_title,\n\t\tid\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(())\n}\n\n/// Fetches the progress of the llm pipeline for this chat session\n///\n/// # Method\n/// `POST /api/chat/progress`\n///\n/// # Request Body\n/// - [ProgressRequest]\n///\n/// # Responses\n/// - `200 OK` - [ProgressResponse] - status of the llm pipeline\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/progress\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 4\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/progress\",\n\tsummary=\"Get status of LLM pipeline\",\n\tdescription=\"Fetches the progress of the llm pipeline for this chat session.\",\n\trequest_body(\n\t\tcontent=ProgressRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Chat session ID must belong to the user who sent the request. New Title must not be empty string.\",\n\t\texample=json!({\n\t\t\t\"chat_session_id\": 4\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The status of the LLM pipeline for the quested chat session\",\n\t\t\tbody=ProgressResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"progress\": \"Ready\",\n\t\t\t\t\"title\": \"Possibly Updated Chat Title\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_progress(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(ProgressRequest { chat_session_id }): Json\u003cProgressRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cProgressResponse\u003e\u003e {\n\tlet row = sqlx::query!(\n\t\tr#\"SELECT llm_progress as \"llm_progress: LlmProgress\", title\n\t\tFROM chat_sessions\n\t\tWHERE account_id=$1 AND id=$2;\"#,\n\t\tuser.id,\n\t\tchat_session_id,\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\tOk(Json(ProgressResponse {\n\t\tprogress: row.llm_progress,\n\t\ttitle: row.title,\n\t}))\n}\n\n/// Create the chat routes with authentication middleware.\n///\n/// # Routes\n/// - `GET /chats` - Get metadata for all the user's chat sessions (protected)\n/// - `POST /messagePage` - Gets a page of messages in the session, ending with message_id or the latest message (protected)\n/// - `POST /updateMessage` - Updates a user's message and waits for a bot reply (protected)\n/// - `POST /sendMessage` - Sends a user's message and waits for a bot reply (protected)\n/// - `GET /newChat` - Gets a chat session id for an empty chat (protected)\n/// - `DELETE /:id` - Delete a chat session and associated messages (protected)\n/// - `POST /rename` - Renames the title of a chat session (protected)\n/// - `POST /progress` - Fetches the progress of the llm pipeline for this chat session (protected)\n///\n/// # Middleware\n/// All routes are protected by `middleware_auth` which validates the `auth-token` cookie.\npub fn chat_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/chats\", get(api_chats))\n\t\t.route(\"/messagePage\", post(api_message_page))\n\t\t.route(\"/updateMessage\", post(api_update_message))\n\t\t.route(\"/sendMessage\", post(api_send_message))\n\t\t.route(\"/newChat\", get(api_new_chat))\n\t\t.route(\"/{id}\", delete(api_delete_chat))\n\t\t.route(\"/rename\", post(api_rename))\n\t\t.route(\"/progress\", post(api_progress))\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n}\n","traces":[{"line":65,"address":[41974688],"length":1,"stats":{"Line":1}},{"line":76,"address":[42767759],"length":1,"stats":{"Line":1}},{"line":77,"address":[42768057],"length":1,"stats":{"Line":0}},{"line":80,"address":[42768935,42768165,42769411,42769507,42769243,42768990,42769767,42768235,42769344,42768756,42768102],"length":1,"stats":{"Line":5}},{"line":96,"address":[42768827],"length":1,"stats":{"Line":1}},{"line":97,"address":[39008994],"length":1,"stats":{"Line":4}},{"line":98,"address":[42769379,42769321],"length":1,"stats":{"Line":1}},{"line":99,"address":[39009274,39009246],"length":1,"stats":{"Line":3}},{"line":102,"address":[42769018],"length":1,"stats":{"Line":1}},{"line":104,"address":[42770203,42769712,42770001,42770127,42769674,42774785],"length":1,"stats":{"Line":4}},{"line":105,"address":[42769555],"length":1,"stats":{"Line":1}},{"line":107,"address":[42769568],"length":1,"stats":{"Line":1}},{"line":109,"address":[39009015],"length":1,"stats":{"Line":4}},{"line":111,"address":[42769599],"length":1,"stats":{"Line":1}},{"line":115,"address":[42769613,42770348,42770752],"length":1,"stats":{"Line":3}},{"line":121,"address":[42772518,42770714,42772921],"length":1,"stats":{"Line":3}},{"line":137,"address":[42774692,42772892,42767855,42774798],"length":1,"stats":{"Line":2}},{"line":140,"address":[42775116,42775045],"length":1,"stats":{"Line":2}},{"line":141,"address":[42775158,42776140],"length":1,"stats":{"Line":2}},{"line":142,"address":[42775220],"length":1,"stats":{"Line":1}},{"line":143,"address":[42775737],"length":1,"stats":{"Line":1}},{"line":145,"address":[42775207],"length":1,"stats":{"Line":1}},{"line":146,"address":[42775240],"length":1,"stats":{"Line":1}},{"line":147,"address":[42775248],"length":1,"stats":{"Line":1}},{"line":148,"address":[42775319],"length":1,"stats":{"Line":1}},{"line":149,"address":[42775367],"length":1,"stats":{"Line":1}},{"line":150,"address":[42775383],"length":1,"stats":{"Line":1}},{"line":151,"address":[42775442],"length":1,"stats":{"Line":1}},{"line":152,"address":[42775496],"length":1,"stats":{"Line":1}},{"line":153,"address":[42775512],"length":1,"stats":{"Line":1}},{"line":154,"address":[42775571],"length":1,"stats":{"Line":1}},{"line":155,"address":[42775623],"length":1,"stats":{"Line":1}},{"line":156,"address":[42775667],"length":1,"stats":{"Line":1}},{"line":160,"address":[42776162,42776588],"length":1,"stats":{"Line":2}},{"line":167,"address":[42778088,42775181],"length":1,"stats":{"Line":2}},{"line":168,"address":[42778181],"length":1,"stats":{"Line":1}},{"line":171,"address":[42778193],"length":1,"stats":{"Line":1}},{"line":181,"address":[42780066],"length":1,"stats":{"Line":1}},{"line":185,"address":[39009057],"length":1,"stats":{"Line":2}},{"line":187,"address":[42780516,42781004,42780598],"length":1,"stats":{"Line":3}},{"line":194,"address":[42783652,42783484,42780972,42783719,42783231],"length":1,"stats":{"Line":4}},{"line":195,"address":[42782809,42782883,42783279,42782759],"length":1,"stats":{"Line":1}},{"line":198,"address":[39009078],"length":1,"stats":{"Line":3}},{"line":199,"address":[42828240,42783606,42833251],"length":1,"stats":{"Line":1}},{"line":200,"address":[42828747,42828366,42828287],"length":1,"stats":{"Line":0}},{"line":207,"address":[42831332,42830956,42828716],"length":1,"stats":{"Line":0}},{"line":213,"address":[42831322,42833070],"length":1,"stats":{"Line":0}},{"line":217,"address":[42785896,42785192],"length":1,"stats":{"Line":0}},{"line":223,"address":[42786590,42784292,42786176],"length":1,"stats":{"Line":3}},{"line":235,"address":[42788365,42786550],"length":1,"stats":{"Line":2}},{"line":236,"address":[42788905,42788449],"length":1,"stats":{"Line":0}},{"line":245,"address":[42788858,42791452,42793234,42791275,42790356,42791376,42790972,42791027,42790840,42790426],"length":1,"stats":{"Line":0}},{"line":255,"address":[42790914],"length":1,"stats":{"Line":0}},{"line":256,"address":[39009103],"length":1,"stats":{"Line":0}},{"line":257,"address":[42791420,42791353],"length":1,"stats":{"Line":0}},{"line":259,"address":[42791511],"length":1,"stats":{"Line":0}},{"line":260,"address":[42791677],"length":1,"stats":{"Line":0}},{"line":261,"address":[42791578],"length":1,"stats":{"Line":0}},{"line":263,"address":[42791585],"length":1,"stats":{"Line":0}},{"line":264,"address":[42791615],"length":1,"stats":{"Line":0}},{"line":265,"address":[42791663],"length":1,"stats":{"Line":0}},{"line":272,"address":[42791852,42788416],"length":1,"stats":{"Line":2}},{"line":273,"address":[42791944],"length":1,"stats":{"Line":0}},{"line":274,"address":[42792062,42792147],"length":1,"stats":{"Line":0}},{"line":275,"address":[42792161,42792236,42793813],"length":1,"stats":{"Line":0}},{"line":277,"address":[42792398,42793515,42793157,42793414,42792353,42792468,42793212,42792993,42793591,42797562],"length":1,"stats":{"Line":0}},{"line":286,"address":[42793064],"length":1,"stats":{"Line":0}},{"line":287,"address":[39009124],"length":1,"stats":{"Line":0}},{"line":288,"address":[42793559,42793492],"length":1,"stats":{"Line":0}},{"line":290,"address":[42793684],"length":1,"stats":{"Line":0}},{"line":291,"address":[42794478,42793865,42793777],"length":1,"stats":{"Line":0}},{"line":297,"address":[42794333],"length":1,"stats":{"Line":0}},{"line":298,"address":[42794234],"length":1,"stats":{"Line":0}},{"line":300,"address":[42794241],"length":1,"stats":{"Line":0}},{"line":301,"address":[42794271],"length":1,"stats":{"Line":0}},{"line":302,"address":[42794319],"length":1,"stats":{"Line":0}},{"line":312,"address":[42791903,42796352,42798144],"length":1,"stats":{"Line":3}},{"line":313,"address":[42796435,42796515],"length":1,"stats":{"Line":2}},{"line":314,"address":[42796598],"length":1,"stats":{"Line":1}},{"line":315,"address":[42796699],"length":1,"stats":{"Line":1}},{"line":318,"address":[42796907,42796800,42797540,42797843,42797321,42797485,42797919,42824440,42796837,42797742],"length":1,"stats":{"Line":4}},{"line":328,"address":[42797392],"length":1,"stats":{"Line":1}},{"line":329,"address":[42767960,42797575,42797518,42797470,42797790],"length":1,"stats":{"Line":4}},{"line":330,"address":[42797887,42797820],"length":1,"stats":{"Line":1}},{"line":332,"address":[42798012],"length":1,"stats":{"Line":1}},{"line":334,"address":[42798113,42798205],"length":1,"stats":{"Line":2}},{"line":335,"address":[42798434,42798535,42799148],"length":1,"stats":{"Line":3}},{"line":341,"address":[42799003],"length":1,"stats":{"Line":1}},{"line":342,"address":[42798904],"length":1,"stats":{"Line":1}},{"line":344,"address":[42798911],"length":1,"stats":{"Line":1}},{"line":345,"address":[42798941],"length":1,"stats":{"Line":1}},{"line":346,"address":[42798989],"length":1,"stats":{"Line":1}},{"line":353,"address":[42800943,42796465],"length":1,"stats":{"Line":2}},{"line":355,"address":[42801085],"length":1,"stats":{"Line":1}},{"line":359,"address":[42801119,42804006],"length":1,"stats":{"Line":2}},{"line":360,"address":[42804075],"length":1,"stats":{"Line":1}},{"line":361,"address":[42822615,42824180,42823224,42813268,42824435,42822947,42823264,42822907,42823551,42804205,42804269,42811133,42818012,42823918,42824197,42824418,42823588,42823616,42823511,42823893,42822565,42806404],"length":1,"stats":{"Line":2}},{"line":448,"address":[42818310],"length":1,"stats":{"Line":1}},{"line":449,"address":[42818382],"length":1,"stats":{"Line":1}},{"line":453,"address":[42822015,42824718,42825065,42821960,42820771,42821828,42820982,42824785,42824617,42820912],"length":1,"stats":{"Line":4}},{"line":465,"address":[42821902],"length":1,"stats":{"Line":1}},{"line":466,"address":[42824665,42821993,42767981,42824453,42821945],"length":1,"stats":{"Line":4}},{"line":467,"address":[42824695,42824753],"length":1,"stats":{"Line":1}},{"line":470,"address":[42824846],"length":1,"stats":{"Line":1}},{"line":473,"address":[42825101,42768002,42824858,42826451],"length":1,"stats":{"Line":2}},{"line":476,"address":[42826628,42826796,42826377,42827187,42826729,42826209,42826429,42825511,42825426,42825534,42825615],"length":1,"stats":{"Line":5}},{"line":484,"address":[42825470],"length":1,"stats":{"Line":1}},{"line":486,"address":[42826319],"length":1,"stats":{"Line":1}},{"line":487,"address":[42826410,42826464,42826362,42768023,42826676],"length":1,"stats":{"Line":4}},{"line":488,"address":[42826764,42826706],"length":1,"stats":{"Line":1}},{"line":490,"address":[42826869],"length":1,"stats":{"Line":1}},{"line":492,"address":[42827045],"length":1,"stats":{"Line":1}},{"line":496,"address":[42826987],"length":1,"stats":{"Line":1}},{"line":497,"address":[42827039],"length":1,"stats":{"Line":1}},{"line":503,"address":[42801614,42801091,42801172],"length":1,"stats":{"Line":0}},{"line":509,"address":[42827602,42828143,42803183,42801546,42803876,42803934,42803708,42827434,42827535,42803073,42803096],"length":1,"stats":{"Line":0}},{"line":516,"address":[42801571],"length":1,"stats":{"Line":0}},{"line":518,"address":[42803818],"length":1,"stats":{"Line":0}},{"line":519,"address":[39009229],"length":1,"stats":{"Line":0}},{"line":520,"address":[42827512,42827570],"length":1,"stats":{"Line":0}},{"line":522,"address":[42827659],"length":1,"stats":{"Line":0}},{"line":524,"address":[42827781],"length":1,"stats":{"Line":0}},{"line":525,"address":[42827822,42833313,42833446,42834336,42834651,42833280],"length":1,"stats":{"Line":0}},{"line":526,"address":[42834271,42834510,42833366,42833548,42834314,42833486,42834134],"length":1,"stats":{"Line":0}},{"line":534,"address":[42834195],"length":1,"stats":{"Line":0}},{"line":535,"address":[42833473,42834373,42834298,42834259,42834603],"length":1,"stats":{"Line":0}},{"line":538,"address":[42827970],"length":1,"stats":{"Line":0}},{"line":542,"address":[42827933],"length":1,"stats":{"Line":0}},{"line":599,"address":[41989456],"length":1,"stats":{"Line":1}},{"line":603,"address":[42851936],"length":1,"stats":{"Line":1}},{"line":604,"address":[42850823,42850760,42851456,42851866,42851701,42851288,42851799,42851499,42850887],"length":1,"stats":{"Line":4}},{"line":612,"address":[42851356],"length":1,"stats":{"Line":1}},{"line":613,"address":[39191664],"length":1,"stats":{"Line":4}},{"line":614,"address":[42851834,42851776],"length":1,"stats":{"Line":1}},{"line":723,"address":[42015632],"length":1,"stats":{"Line":1}},{"line":731,"address":[42854814,42854453,42854881,42854284,42854716,42854499,42853542,42853448,42853606],"length":1,"stats":{"Line":4}},{"line":759,"address":[42854371],"length":1,"stats":{"Line":1}},{"line":760,"address":[42854764,42853529,42854438,42854561,42854483],"length":1,"stats":{"Line":4}},{"line":761,"address":[42854791,42854849],"length":1,"stats":{"Line":1}},{"line":764,"address":[42855635,42855568,42855008],"length":1,"stats":{"Line":3}},{"line":765,"address":[42855579],"length":1,"stats":{"Line":1}},{"line":766,"address":[42855583],"length":1,"stats":{"Line":1}},{"line":767,"address":[42855587],"length":1,"stats":{"Line":1}},{"line":768,"address":[42855603],"length":1,"stats":{"Line":1}},{"line":769,"address":[42855629],"length":1,"stats":{"Line":1}},{"line":773,"address":[42855046,42855098,42855166],"length":1,"stats":{"Line":3}},{"line":775,"address":[42855168,42855392],"length":1,"stats":{"Line":2}},{"line":777,"address":[42855155],"length":1,"stats":{"Line":1}},{"line":780,"address":[42855259],"length":1,"stats":{"Line":1}},{"line":781,"address":[42855213],"length":1,"stats":{"Line":1}},{"line":782,"address":[42855245],"length":1,"stats":{"Line":1}},{"line":850,"address":[42023168],"length":1,"stats":{"Line":1}},{"line":862,"address":[42859104,42858926],"length":1,"stats":{"Line":2}},{"line":863,"address":[42859181,42860020],"length":1,"stats":{"Line":2}},{"line":867,"address":[42860668,42861811,42859211,42859281,42860735,42859118,42860392,42859934,42859992,42860493,42860560,42859802],"length":1,"stats":{"Line":7}},{"line":877,"address":[42859876],"length":1,"stats":{"Line":1}},{"line":878,"address":[42859919,42860440,42860222,42858973,42859967],"length":1,"stats":{"Line":4}},{"line":879,"address":[42860470,42860528],"length":1,"stats":{"Line":1}},{"line":880,"address":[39007821,39007793],"length":1,"stats":{"Line":2}},{"line":882,"address":[42860792],"length":1,"stats":{"Line":1}},{"line":883,"address":[42860823],"length":1,"stats":{"Line":1}},{"line":886,"address":[42861789,42862097,42860992,42860922,42861628,42863017,42862164,42861996,42860869,42861737],"length":1,"stats":{"Line":4}},{"line":897,"address":[42861679],"length":1,"stats":{"Line":1}},{"line":898,"address":[42862044,42858994,42861829,42861722,42861770],"length":1,"stats":{"Line":4}},{"line":899,"address":[42862074,42862132],"length":1,"stats":{"Line":1}},{"line":902,"address":[42862275,42863365,42863197,42863633,42862995,42862834,42862943,42862221,42863298,42862339],"length":1,"stats":{"Line":4}},{"line":911,"address":[42862885],"length":1,"stats":{"Line":1}},{"line":912,"address":[39007542],"length":1,"stats":{"Line":4}},{"line":913,"address":[42863275,42863333],"length":1,"stats":{"Line":1}},{"line":917,"address":[42863422],"length":1,"stats":{"Line":1}},{"line":918,"address":[42863461],"length":1,"stats":{"Line":1}},{"line":919,"address":[42863468],"length":1,"stats":{"Line":1}},{"line":920,"address":[42863475],"length":1,"stats":{"Line":1}},{"line":921,"address":[42863489],"length":1,"stats":{"Line":1}},{"line":922,"address":[42863496],"length":1,"stats":{"Line":1}},{"line":923,"address":[42863503],"length":1,"stats":{"Line":1}},{"line":924,"address":[42863510],"length":1,"stats":{"Line":1}},{"line":926,"address":[39007563],"length":1,"stats":{"Line":4}},{"line":928,"address":[42864088],"length":1,"stats":{"Line":1}},{"line":998,"address":[42031472],"length":1,"stats":{"Line":1}},{"line":1010,"address":[42867814,42867971],"length":1,"stats":{"Line":2}},{"line":1011,"address":[42868048,42868884],"length":1,"stats":{"Line":2}},{"line":1015,"address":[42868801,42869253,42869421,42868078,42868856,42869533,42868669,42869600,42868148,42869354,42867985,42870475],"length":1,"stats":{"Line":7}},{"line":1023,"address":[42868743],"length":1,"stats":{"Line":1}},{"line":1024,"address":[42868786,42869301,42869086,42867861,42868834],"length":1,"stats":{"Line":4}},{"line":1025,"address":[42869389,42869331],"length":1,"stats":{"Line":1}},{"line":1026,"address":[42869482,42869568],"length":1,"stats":{"Line":2}},{"line":1029,"address":[42870269,42870453,42870828,42869655,42871100,42870401,42870761,42869710,42869774,42870660],"length":1,"stats":{"Line":4}},{"line":1038,"address":[42870343],"length":1,"stats":{"Line":1}},{"line":1039,"address":[39204305],"length":1,"stats":{"Line":4}},{"line":1040,"address":[42870738,42870796],"length":1,"stats":{"Line":1}},{"line":1045,"address":[42870889],"length":1,"stats":{"Line":1}},{"line":1046,"address":[42870928],"length":1,"stats":{"Line":1}},{"line":1047,"address":[42870935],"length":1,"stats":{"Line":1}},{"line":1048,"address":[42870942],"length":1,"stats":{"Line":1}},{"line":1049,"address":[42870956],"length":1,"stats":{"Line":1}},{"line":1050,"address":[42870963],"length":1,"stats":{"Line":1}},{"line":1051,"address":[42870970],"length":1,"stats":{"Line":1}},{"line":1052,"address":[42870977],"length":1,"stats":{"Line":1}},{"line":1054,"address":[39204326],"length":1,"stats":{"Line":4}},{"line":1056,"address":[42871561],"length":1,"stats":{"Line":1}},{"line":1057,"address":[42871555],"length":1,"stats":{"Line":1}},{"line":1107,"address":[42035616],"length":1,"stats":{"Line":1}},{"line":1112,"address":[42875217,42874807,42874261,42874406,42874975,42874342,42875018,42875382,42875315,42876378],"length":1,"stats":{"Line":4}},{"line":1126,"address":[42874875],"length":1,"stats":{"Line":1}},{"line":1127,"address":[39195048],"length":1,"stats":{"Line":4}},{"line":1128,"address":[42875292,42875350],"length":1,"stats":{"Line":1}},{"line":1130,"address":[42875483,42875551],"length":1,"stats":{"Line":2}},{"line":1131,"address":[42875607],"length":1,"stats":{"Line":1}},{"line":1134,"address":[42876140,42876712,42875674,42876645,42875738,42875642,42876547,42876266,42876311],"length":1,"stats":{"Line":4}},{"line":1142,"address":[42876211],"length":1,"stats":{"Line":1}},{"line":1143,"address":[42874329,42876293,42876595,42876408,42876254],"length":1,"stats":{"Line":4}},{"line":1144,"address":[42876622,42876680],"length":1,"stats":{"Line":1}},{"line":1145,"address":[42876766],"length":1,"stats":{"Line":1}},{"line":1149,"address":[42876338],"length":1,"stats":{"Line":1}},{"line":1186,"address":[42038880],"length":1,"stats":{"Line":1}},{"line":1192,"address":[42879183,42878547,42879226,42879038,42879431,42879529,42879596,42878483,42880451,42878394],"length":1,"stats":{"Line":4}},{"line":1204,"address":[42879083],"length":1,"stats":{"Line":1}},{"line":1205,"address":[39202776],"length":1,"stats":{"Line":4}},{"line":1206,"address":[42879564,42879506],"length":1,"stats":{"Line":1}},{"line":1209,"address":[42880903,42880626,42879766,42880387,42880970,42881173,42880791,42879650,42879702,42880261,42880429,42880724],"length":1,"stats":{"Line":5}},{"line":1218,"address":[42880332],"length":1,"stats":{"Line":1}},{"line":1219,"address":[42880674,42880481,42880375,42880414,42878470],"length":1,"stats":{"Line":4}},{"line":1220,"address":[42880701,42880759],"length":1,"stats":{"Line":1}},{"line":1221,"address":[39202922,39202894],"length":1,"stats":{"Line":1}},{"line":1223,"address":[42881022],"length":1,"stats":{"Line":1}},{"line":1276,"address":[42043680],"length":1,"stats":{"Line":1}},{"line":1282,"address":[42883077,42882956],"length":1,"stats":{"Line":2}},{"line":1283,"address":[42883937,42883143],"length":1,"stats":{"Line":2}},{"line":1289,"address":[42883173,42883860,42883909,42884438,42883237,42884273,42884550,42884617,42885459,42884371,42883091,42883728],"length":1,"stats":{"Line":5}},{"line":1294,"address":[42883802],"length":1,"stats":{"Line":1}},{"line":1295,"address":[39192908],"length":1,"stats":{"Line":4}},{"line":1296,"address":[42884348,42884406],"length":1,"stats":{"Line":1}},{"line":1297,"address":[42884585,42884499],"length":1,"stats":{"Line":1}},{"line":1300,"address":[42885283,42885628,42885437,42885392,42885793,42885726,42884724,42884672,42884788,42886075],"length":1,"stats":{"Line":4}},{"line":1305,"address":[42885334],"length":1,"stats":{"Line":1}},{"line":1306,"address":[42885477,42885676,42885422,42885377,42883012],"length":1,"stats":{"Line":4}},{"line":1307,"address":[42885703,42885761],"length":1,"stats":{"Line":1}},{"line":1309,"address":[42885850],"length":1,"stats":{"Line":1}},{"line":1369,"address":[42050192],"length":1,"stats":{"Line":1}},{"line":1374,"address":[42887985,42889040,42888644,42888476,42888987,42888687,42889561,42889161,42889208,42887921,42889539,42887850,42888889],"length":1,"stats":{"Line":7}},{"line":1381,"address":[42888544],"length":1,"stats":{"Line":1}},{"line":1382,"address":[39195328],"length":1,"stats":{"Line":4}},{"line":1383,"address":[42889008,42888964],"length":1,"stats":{"Line":1}},{"line":1384,"address":[39195375,39195421],"length":1,"stats":{"Line":2}},{"line":1385,"address":[42889314],"length":1,"stats":{"Line":1}},{"line":1386,"address":[42889275],"length":1,"stats":{"Line":1}},{"line":1387,"address":[42889282],"length":1,"stats":{"Line":1}},{"line":1405,"address":[41976138,41974832,41976113],"length":1,"stats":{"Line":1}},{"line":1406,"address":[41974988,41975462,41975864,41975941,41975048,41975539,41975405,41975730,41976060,41975807,41975596,41975188,41974839,41975673,41975998,41975328,41975128,41975268],"length":1,"stats":{"Line":18}},{"line":1407,"address":[41974947,41975004,41976242,41974940,41975056],"length":1,"stats":{"Line":3}},{"line":1408,"address":[41975080,41976227,41975196,41975144,41975087],"length":1,"stats":{"Line":3}},{"line":1409,"address":[41976212,41975333,41975227,41975220,41975284],"length":1,"stats":{"Line":3}},{"line":1410,"address":[41975418,41975467,41976197,41975364,41975357],"length":1,"stats":{"Line":3}},{"line":1411,"address":[41975491,41975601,41975498,41976185,41975552],"length":1,"stats":{"Line":3}},{"line":1412,"address":[41975735,41975632,41975686,41975625,41976173],"length":1,"stats":{"Line":3}},{"line":1413,"address":[41975820,41975759,41975869,41976161,41975766],"length":1,"stats":{"Line":3}},{"line":1414,"address":[41975954,41976149,41975893,41976003,41975900],"length":1,"stats":{"Line":3}},{"line":1415,"address":[41976073,41976026,41976131,41976019],"length":1,"stats":{"Line":2}}],"covered":215,"coverable":259},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","itinerary.rs"],"content":"/*\n * src/controllers/itinerary.rs\n *\n * File for Itinerary Controller API Endpoints\n *\n * Purpose:\n *   Serve Itinerary Related API Requests\n */\n\nuse axum::routing::{delete, post};\nuse axum::{Extension, Json, extract::Path, routing::get};\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse tracing::debug;\nuse utoipa::OpenApi;\n\nuse crate::controllers::AxumRouter;\nuse crate::error::{ApiResult, AppError};\nuse crate::global::EVENT_SEARCH_RESULT_LEN;\nuse crate::http_models::event::{\n\tEvent, SearchEventRequest, SearchEventResponse, UserEventRequest, UserEventResponse,\n};\nuse crate::http_models::itinerary::*;\nuse crate::middleware::{AuthUser, middleware_auth};\nuse crate::sql_models::event_list::EventListJoinRow;\nuse crate::sql_models::itinerary::ItineraryRow;\nuse crate::sql_models::{Period, TimeOfDay};\nuse crate::swagger::SecurityAddon;\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_get_itinerary,\n\t\tapi_saved_itineraries,\n\t\tapi_save,\n\t\tapi_unsave,\n\t\tapi_user_event,\n\t\tapi_search_event,\n\t\tapi_delete_user_event\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity((\"set-cookie\"=[])),\n    info(\n    \ttitle=\"Itinerary Routes\",\n    \tdescription = \"API endpoints dealing with managing and viewing itineraries.\"\n    ),\n    tags((name=\"Itinerary\"))\n)]\npub struct ItineraryApiDoc;\n\n/// Returns the [EventDay]s associated with this itinerary\n/// Returns only the days that exist in event_list (including empty days with NULL event_id)\nasync fn itinerary_events(\n\titinerary_id: i32,\n\t_start_date: NaiveDate,\n\t_end_date: NaiveDate,\n\tpool: \u0026PgPool,\n) -\u003e ApiResult\u003cVec\u003cEventDay\u003e\u003e {\n\t// First, get all dates that have entries (including NULL event_id for empty days)\n\tlet all_dates: Vec\u003cNaiveDate\u003e = sqlx::query_scalar!(\n\t\tr#\"\n\t\tSELECT DISTINCT date\n\t\tFROM event_list\n\t\tWHERE itinerary_id = $1\n\t\tORDER BY date\n\t\t\"#,\n\t\titinerary_id\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Now get all events (excluding placeholders with NULL event_id)\n\tlet event_list: Vec\u003cEventListJoinRow\u003e = sqlx::query_as!(\n\t\tEventListJoinRow,\n\t\tr#\"\n\t\tSELECT\n\t\t\te.id,\n\t\t\tel.time_of_day as \"time_of_day: TimeOfDay\",\n\t\t\tel.date,\n\t\t\te.street_address,\n\t\t\te.postal_code,\n\t\t\te.city,\n\t\t\te.country,\n\t\t\te.lat,\n\t\t\te.lng,\n\t\t\te.event_type,\n\t\t\te.event_description,\n\t\t\te.event_name,\n\t\t\te.user_created,\n\t\t\te.hard_start,\n\t\t\te.hard_end,\n\t\t\te.timezone,\n\t\t\te.place_id,\n\t\t\te.wheelchair_accessible_parking,\n\t\t\te.wheelchair_accessible_entrance,\n\t\t\te.wheelchair_accessible_restroom,\n\t\t\te.wheelchair_accessible_seating,\n\t\t\te.serves_vegetarian_food,\n\t\t\te.price_level,\n\t\t\te.utc_offset_minutes,\n\t\t\te.website_uri,\n\t\t\te.types,\n\t\t\te.photo_name,\n\t\t\te.photo_width,\n\t\t\te.photo_height,\n\t\t\te.photo_author,\n\t\t\te.photo_author_uri,\n\t\t\te.photo_author_photo_uri,\n\t\t\te.weekday_descriptions,\n\t\t\te.secondary_hours_type,\n\t\t\te.next_open_time,\n\t\t\te.next_close_time,\n\t\t\te.open_now,\n\t\t\te.periods as \"periods: Vec\u003cPeriod\u003e\",\n\t\t\te.special_days,\n\t\t\tel.block_index\n\t\tFROM event_list el\n\t\tJOIN events e ON e.id = el.event_id\n\t\tWHERE el.itinerary_id = $1 AND el.event_id IS NOT NULL\n\t\tORDER BY el.date, el.time_of_day\n\t\t\"#,\n\t\titinerary_id\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Create a map of date -\u003e events for quick lookup\n\tuse std::collections::HashMap;\n\tlet mut events_by_date: HashMap\u003cNaiveDate, Vec\u003c\u0026EventListJoinRow\u003e\u003e = HashMap::new();\n\tfor event in event_list.iter() {\n\t\tevents_by_date.entry(event.date).or_default().push(event);\n\t}\n\n\t// Create EventDay for each date that exists in event_list\n\tlet mut event_days = Vec::new();\n\n\tfor date in all_dates {\n\t\tlet mut morning_events = Vec::new();\n\t\tlet mut afternoon_events = Vec::new();\n\t\tlet mut evening_events = Vec::new();\n\n\t\t// If there are events for this date, populate them\n\t\tif let Some(day_events) = events_by_date.get(\u0026date) {\n\t\t\tfor event in day_events {\n\t\t\t\tmatch event.time_of_day {\n\t\t\t\t\tTimeOfDay::Morning =\u003e morning_events.push((*event).into()),\n\t\t\t\t\tTimeOfDay::Afternoon =\u003e afternoon_events.push((*event).into()),\n\t\t\t\t\tTimeOfDay::Evening =\u003e evening_events.push((*event).into()),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#[cfg(not(tarpaulin_include))]\n\t\tfn sort(a: \u0026Event, b: \u0026Event) -\u003e std::cmp::Ordering {\n\t\t\ta.block_index\n\t\t\t\t.unwrap_or(i32::MAX)\n\t\t\t\t.cmp(\u0026b.block_index.unwrap_or(i32::MAX))\n\t\t}\n\t\tmorning_events.sort_by(sort);\n\t\tafternoon_events.sort_by(sort);\n\t\tevening_events.sort_by(sort);\n\n\t\tevent_days.push(EventDay {\n\t\t\tmorning_events,\n\t\t\tafternoon_events,\n\t\t\tevening_events,\n\t\t\tdate,\n\t\t});\n\t}\n\n\tOk(event_days)\n}\n\n/// Returns the unassigned events for this itinerary\nasync fn unassigned_events(event_ids: \u0026[i32], pool: \u0026PgPool) -\u003e ApiResult\u003cVec\u003cEvent\u003e\u003e {\n\tif event_ids.is_empty() {\n\t\treturn Ok(Vec::new());\n\t}\n\n\tlet events = sqlx::query_as!(\n\t\tEvent,\n\t\tr#\"\n\t\tSELECT\n\t\t\tid,\n\t\t\tstreet_address,\n\t\t\tpostal_code,\n\t\t\tcity,\n\t\t\tcountry,\n\t\t\tlat,\n\t\t\tlng,\n\t\t\tevent_type,\n\t\t\tevent_description,\n\t\t\tevent_name,\n\t\t\tuser_created,\n\t\t\thard_start,\n\t\t\thard_end,\n\t\t\ttimezone,\n\t\t\tplace_id,\n\t\t\twheelchair_accessible_parking,\n\t\t\twheelchair_accessible_entrance,\n\t\t\twheelchair_accessible_restroom,\n\t\t\twheelchair_accessible_seating,\n\t\t\tserves_vegetarian_food,\n\t\t\tprice_level,\n\t\t\tutc_offset_minutes,\n\t\t\twebsite_uri,\n\t\t\ttypes,\n\t\t\tphoto_name,\n\t\t\tphoto_width,\n\t\t\tphoto_height,\n\t\t\tphoto_author,\n\t\t\tphoto_author_uri,\n\t\t\tphoto_author_photo_uri,\n\t\t\tweekday_descriptions,\n\t\t\tsecondary_hours_type,\n\t\t\tnext_open_time,\n\t\t\tnext_close_time,\n\t\t\topen_now,\n\t\t\tperiods as \"periods: Vec\u003cPeriod\u003e\",\n\t\t\tspecial_days,\n\t\t\tNULL::int AS block_index\n\t\tFROM events\n\t\tWHERE id = ANY($1)\n\t\t\"#,\n\t\tevent_ids\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(events)\n}\n\n/// Inserts the events associated with this itinerary into the `event_list` table.\n/// Assumes the itinerary was already inserted into `itineraries` table.\n/// Also inserts placeholder entries (event_id = NULL) for empty days to preserve them.\npub async fn insert_event_list(itinerary: Itinerary, pool: \u0026PgPool) -\u003e ApiResult\u003c()\u003e {\n\tlet mut cap = 0;\n\tfor day in itinerary.event_days.iter() {\n\t\tcap += day.morning_events.len();\n\t\tcap += day.afternoon_events.len();\n\t\tcap += day.evening_events.len();\n\t\t// Add 1 for empty days (we'll insert a placeholder)\n\t\tif day.morning_events.is_empty()\n\t\t\t\u0026\u0026 day.afternoon_events.is_empty()\n\t\t\t\u0026\u0026 day.evening_events.is_empty()\n\t\t{\n\t\t\tcap += 1;\n\t\t}\n\t}\n\n\tlet mut times = Vec::with_capacity(cap);\n\tlet mut dates = Vec::with_capacity(cap);\n\tlet mut events: Vec\u003cOption\u003ci32\u003e\u003e = Vec::with_capacity(cap);\n\tlet mut indices: Vec\u003cOption\u003ci32\u003e\u003e = Vec::with_capacity(cap);\n\n\tfor day in itinerary.event_days.into_iter() {\n\t\tlet morning_len = day.morning_events.len();\n\t\tlet afternoon_len = day.afternoon_events.len();\n\t\tlet evening_len = day.evening_events.len();\n\t\tlet is_empty_day = morning_len == 0 \u0026\u0026 afternoon_len == 0 \u0026\u0026 evening_len == 0;\n\n\t\tif is_empty_day {\n\t\t\t// Insert a placeholder entry with NULL event_id to preserve the empty day\n\t\t\ttimes.push(TimeOfDay::Morning);\n\t\t\tdates.push(day.date);\n\t\t\tevents.push(None);\n\t\t\tindices.push(None);\n\t\t} else {\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Morning, morning_len));\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Afternoon, afternoon_len));\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Evening, evening_len));\n\n\t\t\tdates.extend(std::iter::repeat_n(\n\t\t\t\tday.date,\n\t\t\t\tmorning_len + afternoon_len + evening_len,\n\t\t\t));\n\n\t\t\tevents.extend(day.morning_events.iter().map(|event| Some(event.id)));\n\t\t\tevents.extend(day.afternoon_events.iter().map(|event| Some(event.id)));\n\t\t\tevents.extend(day.evening_events.iter().map(|event| Some(event.id)));\n\n\t\t\tindices.extend(\n\t\t\t\tday.morning_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t\tindices.extend(\n\t\t\t\tday.afternoon_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t\tindices.extend(\n\t\t\t\tday.evening_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t}\n\t}\n\n\tsqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO event_list (itinerary_id, event_id, time_of_day, date, block_index)\n\t\tSELECT $1, events, times, dates, indices\n\t\tFROM UNNEST($2::int4[], $3::time_of_day[], $4::date[], $5::int4[]) as u(events, times, dates, indices);\n\t\t\"#,\n\t\titinerary.id,\n\t\tevents.as_slice() as \u0026[Option\u003ci32\u003e],\n\t\ttimes.as_slice() as \u0026[TimeOfDay],\n\t\tdates.as_slice(),\n\t\tindices.as_slice() as \u0026[Option\u003ci32\u003e],\n\t)\n\t.execute(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(())\n}\n\n/// Get all saved itineraries for the authenticated user.\n///\n/// # Method\n/// `GET /api/itinerary/saved`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - JSON body `{ \"itineraries\": [Itinerary] }` containing user's saved itineraries with eventlist\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/itinerary/saved\n///   -H \"Cookie: auth-token=...\"\n/// ```\n///\n#[utoipa::path(\n\tget,\n\tpath=\"/saved\",\n\tsummary=\"Fetch all the saved itineraries from this user\",\n\tdescription=\"Fetches all the itineraries from this user that are marked as saved.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"An array of itineraries\",\n\t\t\tbody=SavedResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_saved_itineraries(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cSavedResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/itinerary/saved 'api_saved_itineraries' - User ID: {}\",\n\t\tuser.id\n\t);\n\n\t// Fetch all itineraries for the user\n\tlet itineraries: Vec\u003cItineraryRow\u003e = sqlx::query_as!(\n\t\tItineraryRow,\n\t\tr#\"SELECT\n        \tid,\n         \taccount_id,\n          \tstart_date,\n           \tend_date,\n            chat_session_id,\n            title,\n            unassigned_event_ids\n        FROM itineraries WHERE account_id=$1 AND saved=TRUE\"#,\n\t\tuser.id\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet mut res = Vec::with_capacity(itineraries.len());\n\tfor itinerary in itineraries.into_iter() {\n\t\tlet unassigned_ids = itinerary.unassigned_event_ids.unwrap_or_default();\n\t\tres.push(Itinerary {\n\t\t\tid: itinerary.id,\n\t\t\tstart_date: itinerary.start_date,\n\t\t\tend_date: itinerary.end_date,\n\t\t\tevent_days: itinerary_events(\n\t\t\t\titinerary.id,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\t\u0026pool,\n\t\t\t)\n\t\t\t.await?,\n\t\t\tchat_session_id: itinerary.chat_session_id,\n\t\t\ttitle: itinerary.title,\n\t\t\tunassigned_events: unassigned_events(\u0026unassigned_ids, \u0026pool).await?,\n\t\t});\n\t}\n\n\tOk(Json(SavedResponse { itineraries: res }))\n}\n\n/// Get a single saved itinerary either from the user or a public one\n///\n/// # Method\n/// `GET /api/itinerary/{id}`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - JSON body `{ \"itinerary\": Itinerary }` containing itinerary metadata\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - When itinerary doesn't exist or doesn't belong to user\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/itinerary/123\n///   -H \"Cookie: auth-token=...\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/saved/{id}\",\n\tsummary=\"Fetch a specific itinerary\",\n\tdescription=\"Fetches the specified itinerary if it belongs to this user or is public.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The desired itinerary\",\n\t\t\tbody=Itinerary,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Itinerary not found\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_get_itinerary(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tPath(itinerary_id): Path\u003ci32\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cItinerary\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/itinerary/{} 'api_get_itinerary' - User ID: {}\",\n\t\titinerary_id, user.id\n\t);\n\n\t// Fetch the itinerary - from user or public\n\tlet itinerary: ItineraryRow = sqlx::query_as!(\n\t\tItineraryRow,\n\t\tr#\"SELECT\n        \tid,\n         \taccount_id,\n          \tstart_date,\n           \tend_date,\n            chat_session_id,\n            title,\n            unassigned_event_ids\n        FROM itineraries WHERE id = $1 AND (account_id = $2 OR is_public=TRUE)\"#,\n\t\titinerary_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tlet unassigned_ids = itinerary.unassigned_event_ids.unwrap_or_default();\n\tOk(Json(Itinerary {\n\t\tid: itinerary.id,\n\t\tstart_date: itinerary.start_date,\n\t\tend_date: itinerary.end_date,\n\t\tevent_days: itinerary_events(\n\t\t\titinerary_id,\n\t\t\titinerary.start_date,\n\t\t\titinerary.end_date,\n\t\t\t\u0026pool,\n\t\t)\n\t\t.await?,\n\t\tchat_session_id: itinerary.chat_session_id,\n\t\ttitle: itinerary.title,\n\t\tunassigned_events: unassigned_events(\u0026unassigned_ids, \u0026pool).await?,\n\t}))\n}\n\n/// Update an existing or save a new itinerary for the user\n///\n/// # Method\n/// `POST /api/itinerary/save`\n///\n/// # Request Body\n/// - [Itinerary]\n///\n/// # Responses\n/// - `200 OK` - with body: [SaveResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/save\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"id\": 3,\n///         \"start_date\": \"2025-07-15\",\n///         \"end_date\": \"2025-07-21\",\n///         \"event_days\": [\n///           {\n///             \"morning_events\": [],\n///             \"afternoon_events\": [\n///               {\n///                 \"id\": 4,\n///                 \"street_address\": \"3399 North Rd\",\n///                 \"postal_code\": 12601,\n///                 \"city\": \"Poughkeepsie\",\n///                 \"event_type\": \"Park\",\n///                 \"event_description\": \"Take a tour of Marist University\",\n///                 \"event_name\": \"Marist University\"\n///               }\n///             ],\n///             \"evening_events\": [],\n///             \"date\": \"2025-07-21\"\n///           }\n///         ],\n///         \"chat_session_id\": 4,\n///         \"title\": \"Poughkeepsie 7/15-21 2025\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/save\",\n\tsummary=\"Save a new or update an existing itinerary\",\n\tdescription=\"If the itinerary id is already saved for this user, it's updated with the provided values. Otherwise a new one is created.\",\n\trequest_body(\n\t\tcontent=Itinerary,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"The itinerary to save for the user.\",\n\t\t//TODO example\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The id of the itinerary that was just saved. It may be the same as the id passed in the request.\",\n\t\t\tbody=SaveResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_save(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(itinerary): Json\u003cItinerary\u003e,\n) -\u003e ApiResult\u003cJson\u003cSaveResponse\u003e\u003e {\n\t// check if itinerary id already exists for this user\n\tlet id_opt = sqlx::query!(\n\t\tr#\"SELECT id FROM itineraries WHERE id=$1 AND account_id=$2\"#,\n\t\titinerary.id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.map(|record| record.id);\n\n\t// Extract unassigned event IDs\n\tlet unassigned_event_ids: Vec\u003ci32\u003e = itinerary.unassigned_events.iter().map(|e| e.id).collect();\n\n\t// if it doesn't exist, insert a new one\n\tlet id = match id_opt {\n\t\tSome(id) =\u003e {\n\t\t\t// UPDATE existing itinerary and set saved=TRUE\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tUPDATE itineraries\n\t\t\t\tSET start_date = $1, end_date = $2, title = $3, chat_session_id = $4, saved = TRUE, unassigned_event_ids = $7\n\t\t\t\tWHERE id = $5 AND account_id = $6;\n\t\t\t\t\"#,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\titinerary.title,\n\t\t\t\titinerary.chat_session_id,\n\t\t\t\tid,\n\t\t\t\tuser.id,\n\t\t\t\t\u0026unassigned_event_ids\n\t\t\t)\n\t\t\t.execute(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?;\n\n\t\t\tid\n\t\t}\n\t\tNone =\u003e {\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title, unassigned_event_ids)\n\t\t\t\tVALUES ($1, FALSE, $2, $3, $4, TRUE, $5, $6)\n\t\t\t\tRETURNING id;\n\t\t\t\t\"#,\n\t\t\t\tuser.id,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\titinerary.chat_session_id,\n\t\t\t\titinerary.title,\n\t\t\t\t\u0026unassigned_event_ids\n\t\t\t)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.id\n\t\t}\n\t};\n\n\t// delete event_list for this itinerary and make a new one\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM event_list\n\t\tWHERE itinerary_id=$1;\n\t\t\"#,\n\t\tid\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tinsert_event_list(itinerary, \u0026pool).await?;\n\n\tOk(Json(SaveResponse { id }))\n}\n\n/// Unsave an existing itinerary for the user\n///\n/// # Method\n/// `POST /api/itinerary/unsave`\n///\n/// # Request Body\n/// - [UnsaveRequest]\n///\n/// # Responses\n/// - `200 OK` - Successfully unsaved itinerary for this user\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - Itinerary not found or doesn't belong to user (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/unsave\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"id\": 3\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/unsave\",\n\tsummary=\"Unsave an existing itinerary\",\n\tdescription=\"Sets the saved field to false for the given itinerary. Verifies the itinerary belongs to the user.\",\n\trequest_body(\n\t\tcontent=UnsaveRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"The itinerary id to unsave.\"\n\t),\n\tresponses(\n\t\t(status=200, description=\"Successfully unsaved itinerary\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Itinerary not found or doesn't belong to user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_unsave(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(UnsaveRequest { id }): Json\u003cUnsaveRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// Update the itinerary to set saved=FALSE\n\tsqlx::query!(\n\t\tr#\"\n\t\tUPDATE itineraries\n\t\tSET saved = FALSE\n\t\tWHERE id = $1 AND account_id = $2\n\t\tRETURNING id;\n\t\t\"#,\n\t\tid,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tOk(())\n}\n\n/// Insert or update a user-created custom event\n///\n/// # Method\n/// `POST /api/itinerary/userEvent`\n///\n/// # Request Body\n/// - [UserEventRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [UserEventResponse] - event id that was just inserted or updated\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided event id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/userEvent\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"event_name\": \"Custom Event\",\n///\t        \"event_description\": \"I want to do something and it's easier to make a custom event than to tell the LLM exactly how I want it.\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/userEvent\",\n\tsummary=\"Insert or update a user-created custom event\",\n\tdescription=\"Insert a new or updates an existing user-created event with the values passed in the request, returning the event id.\",\n\trequest_body(\n\t\tcontent=UserEventRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"If id is provided, the event will be updated, otherwise it is inserted. The event name is required.\",\n\t\texample=json!({\n\t\t\t\"event_name\": \"Custom Event\",\n\t\t\t\"event_description\": \"I want to do something and it's easier to make a custom event than to tell the LLM exactly how I want it.\"\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Contains the id of the event that was just inserted or updated.\",\n\t\t\tbody=UserEventResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"id\": 43\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"User-event not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_user_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(event): Json\u003cUserEventRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cUserEventResponse\u003e\u003e {\n\tif event.event_name.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\n\t\t\t\"Event name must not be empty\",\n\t\t)));\n\t}\n\tlet id = if let Some(id) = event.id {\n\t\tsqlx::query!(\n\t\t\tr#\"\n\t\t\tUPDATE events\n\t\t\tSET\n\t\t\t\tstreet_address    = $1,\n\t\t\t\tpostal_code       = $2,\n\t\t\t\tcity              = $3,\n\t\t\t\tcountry           = $4,\n\t\t\t\tevent_type        = $5,\n\t\t\t\tevent_description = $6,\n\t\t\t\tevent_name        = $7,\n\t\t\t\thard_start        = $8,\n\t\t\t\thard_end          = $9,\n\t\t\t\ttimezone          = $10,\n\t\t\t\tphoto_name        = $11\n\t\t\tWHERE id=$12 AND user_created=TRUE AND account_id=$13\n\t\t\tRETURNING id\n\t\t\t\"#,\n\t\t\tevent.street_address,\n\t\t\tevent.postal_code,\n\t\t\tevent.city,\n\t\t\tevent.country,\n\t\t\tevent.event_type,\n\t\t\tevent.event_description,\n\t\t\tevent.event_name,\n\t\t\tevent.hard_start,\n\t\t\tevent.hard_end,\n\t\t\tevent.timezone,\n\t\t\tevent.photo_name,\n\t\t\tid,\n\t\t\tuser.id,\n\t\t)\n\t\t.fetch_optional(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.ok_or(AppError::NotFound)?;\n\t\tid\n\t} else {\n\t\tsqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO events(\n\t\t\t\tstreet_address, postal_code, city, country,\n\t\t\t\tevent_type, event_description, event_name,\n\t\t\t\tuser_created, account_id, hard_start, hard_end,\n\t\t\t\ttimezone, photo_name\n\t\t\t)\n\t\t\tVALUES($1, $2, $3, $4, $5, $6, $7, TRUE, $8, $9, $10, $11, $12)\n\t\t\tRETURNING id\n\t\t\t\"#,\n\t\t\tevent.street_address,\n\t\t\tevent.postal_code,\n\t\t\tevent.city,\n\t\t\tevent.country,\n\t\t\tevent.event_type,\n\t\t\tevent.event_description,\n\t\t\tevent.event_name,\n\t\t\tuser.id,\n\t\t\tevent.hard_start,\n\t\t\tevent.hard_end,\n\t\t\tevent.timezone,\n\t\t\tevent.photo_name,\n\t\t)\n\t\t.fetch_one(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.id\n\t};\n\tOk(Json(UserEventResponse { id }))\n}\n\n/// Searches for events that match the filter and returns a list of possible events\n///\n/// # Method\n/// `POST /api/itinerary/searchEvent`\n///\n/// # Request Body\n/// - [SearchEventRequest]\n///   - Example filters:\n///     - `event_name`: Partial name of the event (case-insensitive)\n///     - `city`: Partial city name\n///     - `event_type`: Type of event\n///     - `hard_start_after`: ISO 8601 timestamp to filter events starting after this time\n///     - `hard_start_before`: ISO 8601 timestamp to filter events starting before this time\n///\n/// # Responses\n/// - `200 OK` - with body: [SearchEventResponse] - the best matching events for the query\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Example Request\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/searchEvent \\\n///   -H \"Content-Type: application/json\" \\\n///   -d '{\n///         \"event_name\": \"Music Festival\",\n///         \"city\": \"New York\",\n///         \"event_type\": \"Concert\",\n///         \"hard_start_after\": \"2025-11-01T00:00:00\",\n///         \"hard_start_before\": \"2025-11-30T23:59:59\"\n///       }'\n/// ```\n///\n/// # Example Response\n/// ```json\n/// {\n///   \"events\": [\n///     {\n///       \"id\": 1,\n///       \"street_address\": \"123 Main St\",\n///       \"postal_code\": 10001,\n///       \"city\": \"New York\",\n///       \"event_type\": \"Concert\",\n///       \"event_description\": \"Annual music festival in the park\",\n///       \"event_name\": \"NY Music Festival\",\n///       \"user_created\": false,\n///       \"account_id\": 2,\n///       \"hard_start\": \"2025-11-15T18:00:00\",\n///       \"hard_end\": \"2025-11-15T23:00:00\",\n///       \"timezone\": \"America/New_York\"\n///     },\n///     {\n///       \"id\": 2,\n///       \"street_address\": \"456 Broadway\",\n///       \"postal_code\": 10002,\n///       \"city\": \"New York\",\n///       \"event_type\": \"Concert\",\n///       \"event_description\": \"Indie music showcase\",\n///       \"event_name\": \"Indie Night\",\n///       \"user_created\": true,\n///       \"account_id\": 3,\n///       \"hard_start\": \"2025-11-20T19:00:00\",\n///       \"hard_end\": \"2025-11-20T22:00:00\",\n///       \"timezone\": \"America/New_York\"\n///     }\n///   ]\n/// }\n/// ```\n#[utoipa::path(\n    post,\n    path=\"/searchEvent\",\n    summary=\"Search for events with the given filters and return a list of the best matching events\",\n    description=\"Returns a limited number of events that best match the filters provided in the request.\",\n    request_body(\n        content=SearchEventRequest,\n        content_type=\"application/json\",\n        description=\"Uses the filters, if provided, to search for the best matching events.\",\n        example=json!({\n            \"event_name\": \"Music Festival\",\n            \"city\": \"New York\",\n            \"event_type\": \"Concert\",\n            \"hard_start_after\": \"2025-11-01T00:00:00\",\n            \"hard_start_before\": \"2025-11-30T23:59:59\",\n            \"timezone\": \"America/New_York\"\n        })\n    ),\n    responses(\n        (\n            status=200,\n            description=\"A list of the best matching events for the given filters.\",\n            body=SearchEventResponse,\n            content_type=\"application/json\",\n            example=json!({\n                \"events\": [\n                    {\n                        \"id\": 1,\n                        \"street_address\": \"123 Main St\",\n                        \"postal_code\": 10001,\n                        \"city\": \"New York\",\n                        \"event_type\": \"Concert\",\n                        \"event_description\": \"Annual music festival in the park\",\n                        \"event_name\": \"NY Music Festival\",\n                        \"user_created\": false,\n                        \"account_id\": 2,\n                        \"hard_start\": \"2025-11-15T18:00:00\",\n                        \"hard_end\": \"2025-11-15T23:00:00\",\n                        \"timezone\": \"America/New_York\"\n                    },\n                    {\n                        \"id\": 2,\n                        \"street_address\": \"456 Broadway\",\n                        \"postal_code\": 10002,\n                        \"city\": \"New York\",\n                        \"event_type\": \"Concert\",\n                        \"event_description\": \"Indie music showcase\",\n                        \"event_name\": \"Indie Night\",\n                        \"user_created\": true,\n                        \"account_id\": 3,\n                        \"hard_start\": \"2025-11-20T19:00:00\",\n                        \"hard_end\": \"2025-11-20T22:00:00\",\n                        \"timezone\": \"America/New_York\"\n                    }\n                ]\n            })\n        ),\n        (status=400, description=\"Bad Request\"),\n        (status=401, description=\"User has an invalid cookie/no cookie\"),\n        (status=405, description=\"Method Not Allowed - Must be POST\"),\n        (status=408, description=\"Request Timed Out\"),\n        (status=500, description=\"Internal Server Error\")\n    ),\n    security((\"set-cookie\"=[])),\n    tag=\"Itinerary\"\n)]\npub async fn api_search_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(query): Json\u003cSearchEventRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cSearchEventResponse\u003e\u003e {\n\tlet mut qb = sqlx::QueryBuilder::new(\n\t\t\"SELECT *, NULL::int as block_index FROM events WHERE (user_created=FALSE OR account_id=\",\n\t);\n\tqb.push_bind(user.id).push(\")\");\n\t// Dynamically add filters if present\n\tif let Some(id) = query.id {\n\t\tqb.push(\" AND id = \").push_bind(id);\n\t}\n\tif let Some(street_address) = query.street_address {\n\t\tqb.push(\" AND street_address ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", street_address));\n\t}\n\tif let Some(postal_code) = query.postal_code {\n\t\tqb.push(\" AND postal_code = \").push_bind(postal_code);\n\t}\n\tif let Some(city) = query.city {\n\t\tqb.push(\" AND city ILIKE \").push_bind(format!(\"%{}%\", city));\n\t}\n\tif let Some(country) = query.country {\n\t\tqb.push(\" AND country ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", country));\n\t}\n\tif let Some(event_type) = query.event_type {\n\t\tqb.push(\" AND event_type ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_type));\n\t}\n\tif let Some(event_description) = query.event_description {\n\t\tqb.push(\" AND event_description ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_description));\n\t}\n\tif let Some(event_name) = query.event_name {\n\t\tqb.push(\" AND event_name ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_name));\n\t}\n\tif let Some(hard_start_before) = query.hard_start_before {\n\t\tqb.push(\" AND hard_start \u003c \").push_bind(hard_start_before);\n\t}\n\tif let Some(hard_start_after) = query.hard_start_after {\n\t\tqb.push(\" AND hard_start \u003e \").push_bind(hard_start_after);\n\t}\n\tif let Some(hard_end_before) = query.hard_end_before {\n\t\tqb.push(\" AND hard_end \u003c \").push_bind(hard_end_before);\n\t}\n\tif let Some(hard_end_after) = query.hard_end_after {\n\t\tqb.push(\" AND hard_end \u003e \").push_bind(hard_end_after);\n\t}\n\tif let Some(timezone) = query.timezone {\n\t\tqb.push(\" AND timezone ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", timezone));\n\t}\n\tqb.push(\" ORDER BY hard_start ASC LIMIT \")\n\t\t.push_bind(EVENT_SEARCH_RESULT_LEN);\n\tOk(Json(SearchEventResponse {\n\t\tevents: qb.build_query_as().fetch_all(\u0026pool).await?,\n\t}))\n}\n\n/// Deletes a user-created event from the db\n///\n/// # Method\n/// `DELETE /api/itinerary/userEvent/:id`\n///\n/// # Responses\n/// - `200 OK` - User-created event deleted successfully\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `404 NOT_FOUND` - User-created event was not found or does not belong to this user (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Example Request\n/// ```bash\n/// curl -X DELETE http://localhost:3001/api/itinerary/userEvent/:14 \\\n///   -H \"Content-Type: application/json\" \\\n/// ```\n#[utoipa::path(\n    delete,\n    path=\"/userEvent/{id}\",\n    summary=\"Deletes a user-event from the DB\",\n    description=\"Deletes the user-created event from the DB using the provided event ID. Event must have been created by this user.\",\n    responses(\n        (status=200, description=\"User-created event successfully deleted\"),\n        (status=400, description=\"Bad Request\"),\n        (status=401, description=\"User has an invalid cookie/no cookie\"),\n        (status=404, description=\"User-event not found or does not belong to this user\"),\n        (status=405, description=\"Method Not Allowed - Must be POST\"),\n        (status=408, description=\"Request Timed Out\"),\n        (status=500, description=\"Internal Server Error\")\n    ),\n    security((\"set-cookie\"=[])),\n    tag=\"Itinerary\"\n)]\npub async fn api_delete_user_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tPath(event_id): Path\u003ci32\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM events\n\t\tWHERE\n\t\t\tid=$1 AND\n\t\t\taccount_id=$2 AND\n\t\t\tuser_created=TRUE\n\t\tRETURNING id;\n\t\t\"#,\n\t\tevent_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\tOk(())\n}\n\n/// Create the itinerary routes with authentication middleware.\n///\n/// # Routes\n/// - `GET /saved` - Get user's saved itineraries (protected)\n/// - `POST /save` - Inserts into or updates the user's itinerary in the db (protected)\n/// - `GET /{id}` - Get single itinerary metadata (protected)\n/// - `POST /userEvent` - Insert or update a user-created custom event (protected)\n/// - `POST /searchEvent` - queries the DB for an event that matches the provided filters (protected)\n/// - `DELETE /userEvent/{id}` - Deletes the user-created event from the db (protected)\n///\n/// # Middleware\n/// All routes are protected by `middleware_auth` which validates the `auth-token` cookie.\npub fn itinerary_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/saved\", get(api_saved_itineraries))\n\t\t.route(\"/save\", post(api_save))\n\t\t.route(\"/unsave\", post(api_unsave))\n\t\t.route(\"/{id}\", get(api_get_itinerary))\n\t\t.route(\"/userEvent\", post(api_user_event))\n\t\t.route(\"/searchEvent\", post(api_search_event))\n\t\t.route(\"/userEvent/{id}\", delete(api_delete_user_event))\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n}\n","traces":[{"line":53,"address":[42050400],"length":1,"stats":{"Line":1}},{"line":60,"address":[42544592,42543757,42543600,42544690,42545621,42544326,42544757,42543687,42544375,42544170],"length":1,"stats":{"Line":4}},{"line":69,"address":[42544218],"length":1,"stats":{"Line":1}},{"line":70,"address":[42544640,42544437,42543653,42544311,42544356],"length":1,"stats":{"Line":4}},{"line":71,"address":[42544667,42544725],"length":1,"stats":{"Line":1}},{"line":74,"address":[42544858,42545803,42544893,42545599,42545377,42545550,42545901,42544963,42545968],"length":1,"stats":{"Line":4}},{"line":125,"address":[42545448],"length":1,"stats":{"Line":1}},{"line":126,"address":[39014385],"length":1,"stats":{"Line":4}},{"line":127,"address":[42545878,42545936],"length":1,"stats":{"Line":1}},{"line":131,"address":[42546073],"length":1,"stats":{"Line":1}},{"line":132,"address":[42546128,42546204],"length":1,"stats":{"Line":2}},{"line":133,"address":[42548091,42546389],"length":1,"stats":{"Line":2}},{"line":137,"address":[42546429],"length":1,"stats":{"Line":1}},{"line":139,"address":[42546662,42548024,42546444,42546535],"length":1,"stats":{"Line":4}},{"line":140,"address":[42546718],"length":1,"stats":{"Line":1}},{"line":141,"address":[42546979],"length":1,"stats":{"Line":1}},{"line":142,"address":[42547048],"length":1,"stats":{"Line":1}},{"line":145,"address":[42547196,42547117],"length":1,"stats":{"Line":2}},{"line":146,"address":[42547306,42547251],"length":1,"stats":{"Line":2}},{"line":147,"address":[42547407],"length":1,"stats":{"Line":1}},{"line":148,"address":[42547449,42547534],"length":1,"stats":{"Line":2}},{"line":149,"address":[42547569,42547479],"length":1,"stats":{"Line":2}},{"line":150,"address":[42547509,42547604],"length":1,"stats":{"Line":2}},{"line":160,"address":[42547276,42547649],"length":1,"stats":{"Line":2}},{"line":161,"address":[42547664],"length":1,"stats":{"Line":1}},{"line":162,"address":[42547706],"length":1,"stats":{"Line":1}},{"line":164,"address":[42547860],"length":1,"stats":{"Line":1}},{"line":165,"address":[42547740],"length":1,"stats":{"Line":1}},{"line":166,"address":[42547780],"length":1,"stats":{"Line":1}},{"line":167,"address":[42547820],"length":1,"stats":{"Line":1}},{"line":172,"address":[42546743],"length":1,"stats":{"Line":1}},{"line":176,"address":[42050578,42050560],"length":1,"stats":{"Line":4}},{"line":177,"address":[42548438,42548328],"length":1,"stats":{"Line":2}},{"line":178,"address":[42549149,42548486],"length":1,"stats":{"Line":2}},{"line":181,"address":[42548954,42548496,42549545,42549606,42549450,42549121,42549746,42548553,42548449,42549076],"length":1,"stats":{"Line":0}},{"line":228,"address":[42549041],"length":1,"stats":{"Line":0}},{"line":229,"address":[39016409],"length":1,"stats":{"Line":0}},{"line":230,"address":[42549525,42549577],"length":1,"stats":{"Line":0}},{"line":232,"address":[42549681],"length":1,"stats":{"Line":0}},{"line":238,"address":[42549815,42550047,42555024,42549760,42552570,42555644],"length":1,"stats":{"Line":4}},{"line":239,"address":[42550012],"length":1,"stats":{"Line":1}},{"line":240,"address":[42550024,42550154],"length":1,"stats":{"Line":2}},{"line":241,"address":[42550342,42554702,42554647],"length":1,"stats":{"Line":2}},{"line":242,"address":[42554686,42554783,42554728],"length":1,"stats":{"Line":2}},{"line":243,"address":[42554859,42554767,42554809],"length":1,"stats":{"Line":2}},{"line":245,"address":[42554998,42554848,42554884],"length":1,"stats":{"Line":2}},{"line":246,"address":[42554901],"length":1,"stats":{"Line":0}},{"line":247,"address":[42554937],"length":1,"stats":{"Line":0}},{"line":249,"address":[42554965,42555003],"length":1,"stats":{"Line":0}},{"line":253,"address":[42550368],"length":1,"stats":{"Line":1}},{"line":254,"address":[42550405],"length":1,"stats":{"Line":1}},{"line":255,"address":[42550493],"length":1,"stats":{"Line":1}},{"line":256,"address":[42550578],"length":1,"stats":{"Line":1}},{"line":258,"address":[42550907,42550773,42554463,42550659],"length":1,"stats":{"Line":4}},{"line":259,"address":[42551060,42552625],"length":1,"stats":{"Line":2}},{"line":260,"address":[42552633],"length":1,"stats":{"Line":1}},{"line":261,"address":[42552672],"length":1,"stats":{"Line":1}},{"line":262,"address":[42552719],"length":1,"stats":{"Line":1}},{"line":264,"address":[42552773],"length":1,"stats":{"Line":1}},{"line":266,"address":[42552845],"length":1,"stats":{"Line":0}},{"line":267,"address":[42554213],"length":1,"stats":{"Line":0}},{"line":268,"address":[42554253],"length":1,"stats":{"Line":0}},{"line":269,"address":[42554284],"length":1,"stats":{"Line":0}},{"line":271,"address":[42552799,42552894],"length":1,"stats":{"Line":2}},{"line":272,"address":[42552927],"length":1,"stats":{"Line":1}},{"line":273,"address":[42553024],"length":1,"stats":{"Line":1}},{"line":275,"address":[42553244,42553310,42553129],"length":1,"stats":{"Line":3}},{"line":276,"address":[42553144],"length":1,"stats":{"Line":1}},{"line":277,"address":[42553266,42553158],"length":1,"stats":{"Line":1}},{"line":280,"address":[42553332,42556074,42556064],"length":1,"stats":{"Line":3}},{"line":281,"address":[42553501,42556096,42556106],"length":1,"stats":{"Line":3}},{"line":282,"address":[42556128,42556138,42553670],"length":1,"stats":{"Line":3}},{"line":284,"address":[42553803,42553905],"length":1,"stats":{"Line":2}},{"line":285,"address":[42553814],"length":1,"stats":{"Line":1}},{"line":286,"address":[42553870],"length":1,"stats":{"Line":1}},{"line":287,"address":[42556160,42553893,42556180],"length":1,"stats":{"Line":3}},{"line":289,"address":[42554037,42553935],"length":1,"stats":{"Line":2}},{"line":290,"address":[42553946],"length":1,"stats":{"Line":1}},{"line":291,"address":[42554002],"length":1,"stats":{"Line":1}},{"line":292,"address":[42556224,42554025,42556244],"length":1,"stats":{"Line":3}},{"line":294,"address":[42554169,42554067],"length":1,"stats":{"Line":2}},{"line":295,"address":[42554078],"length":1,"stats":{"Line":1}},{"line":296,"address":[42554134],"length":1,"stats":{"Line":1}},{"line":297,"address":[42554157,42556288,42556308],"length":1,"stats":{"Line":3}},{"line":302,"address":[42551204,42552385,42551547,42552548,42551376,42555320,42555219,42551290,42552490,42555387,42551454,42551477,42551101],"length":1,"stats":{"Line":8}},{"line":309,"address":[42551126],"length":1,"stats":{"Line":1}},{"line":310,"address":[42551212],"length":1,"stats":{"Line":1}},{"line":311,"address":[42551298],"length":1,"stats":{"Line":1}},{"line":312,"address":[42551384],"length":1,"stats":{"Line":1}},{"line":314,"address":[42552452],"length":1,"stats":{"Line":1}},{"line":315,"address":[39015888],"length":1,"stats":{"Line":4}},{"line":316,"address":[42555355,42555297],"length":1,"stats":{"Line":1}},{"line":318,"address":[42555444],"length":1,"stats":{"Line":1}},{"line":363,"address":[42060496],"length":1,"stats":{"Line":1}},{"line":367,"address":[42585242,42584647,42584821],"length":1,"stats":{"Line":3}},{"line":373,"address":[42585195,42586526,42586930,42587544,42587376,42587477,42587156,42587976,42586459,42587104],"length":1,"stats":{"Line":4}},{"line":386,"address":[42587001],"length":1,"stats":{"Line":1}},{"line":387,"address":[39023055],"length":1,"stats":{"Line":4}},{"line":388,"address":[42587454,42587512],"length":1,"stats":{"Line":1}},{"line":390,"address":[42587737,42587664],"length":1,"stats":{"Line":2}},{"line":391,"address":[42587766,42587889,42588804,42588857],"length":1,"stats":{"Line":3}},{"line":392,"address":[42588957],"length":1,"stats":{"Line":0}},{"line":393,"address":[42589342,42588481],"length":1,"stats":{"Line":0}},{"line":394,"address":[42589358],"length":1,"stats":{"Line":0}},{"line":395,"address":[42589372],"length":1,"stats":{"Line":0}},{"line":396,"address":[42589386],"length":1,"stats":{"Line":0}},{"line":397,"address":[42589810,42589436,42589661,42589474,42589715,42590245],"length":1,"stats":{"Line":0}},{"line":398,"address":[42589400],"length":1,"stats":{"Line":0}},{"line":399,"address":[42589407],"length":1,"stats":{"Line":0}},{"line":400,"address":[42589414],"length":1,"stats":{"Line":0}},{"line":401,"address":[42589421],"length":1,"stats":{"Line":0}},{"line":403,"address":[42584729,42589459,42589499,42589693,42589512,42589780,42588022],"length":1,"stats":{"Line":0}},{"line":404,"address":[42589911],"length":1,"stats":{"Line":0}},{"line":405,"address":[42589935],"length":1,"stats":{"Line":0}},{"line":406,"address":[42584750,42588052,42588341,42588079,42590064,42590150,42589967],"length":1,"stats":{"Line":0}},{"line":410,"address":[42589035],"length":1,"stats":{"Line":1}},{"line":456,"address":[42064752],"length":1,"stats":{"Line":1}},{"line":461,"address":[42593640,42593469,42594085],"length":1,"stats":{"Line":3}},{"line":467,"address":[42596479,42596201,42596253,42597476,42594014,42595523,42597434,42596023,42595456,42596612,42596860,42596936,42596688],"length":1,"stats":{"Line":7}},{"line":481,"address":[42596094],"length":1,"stats":{"Line":1}},{"line":482,"address":[39015180],"length":1,"stats":{"Line":4}},{"line":483,"address":[42596589,42596656],"length":1,"stats":{"Line":1}},{"line":484,"address":[42596801,42596904],"length":1,"stats":{"Line":2}},{"line":486,"address":[42597130],"length":1,"stats":{"Line":1}},{"line":487,"address":[42598675],"length":1,"stats":{"Line":1}},{"line":488,"address":[42597236],"length":1,"stats":{"Line":1}},{"line":489,"address":[42597247],"length":1,"stats":{"Line":1}},{"line":490,"address":[42597258],"length":1,"stats":{"Line":1}},{"line":491,"address":[42597296,42597641,42598231,42597790,42597382,42597695],"length":1,"stats":{"Line":4}},{"line":492,"address":[42597269],"length":1,"stats":{"Line":1}},{"line":493,"address":[42597276],"length":1,"stats":{"Line":1}},{"line":494,"address":[42597280],"length":1,"stats":{"Line":1}},{"line":495,"address":[42597284],"length":1,"stats":{"Line":1}},{"line":497,"address":[42597486,42597673,42593551,42597760,42597415,42597367],"length":1,"stats":{"Line":4}},{"line":498,"address":[42597891],"length":1,"stats":{"Line":1}},{"line":499,"address":[42597909],"length":1,"stats":{"Line":1}},{"line":500,"address":[42593572,42598114,42598267,42598535,42598031,42597937],"length":1,"stats":{"Line":4}},{"line":576,"address":[42069600],"length":1,"stats":{"Line":1}},{"line":582,"address":[42603068,42602998,42604212,42604145,42604044,42607473,42603766,42604316,42603589,42603821,42602822],"length":1,"stats":{"Line":5}},{"line":587,"address":[42603660],"length":1,"stats":{"Line":1}},{"line":588,"address":[42604092,42603751,42602901,42603799,42603883],"length":1,"stats":{"Line":4}},{"line":589,"address":[42604180,42604122],"length":1,"stats":{"Line":1}},{"line":590,"address":[39198699,39198671],"length":1,"stats":{"Line":3}},{"line":593,"address":[42610330,42610320,42604330],"length":1,"stats":{"Line":1}},{"line":596,"address":[42604476],"length":1,"stats":{"Line":1}},{"line":597,"address":[42604503],"length":1,"stats":{"Line":1}},{"line":599,"address":[42607768,42604534,42604694,42607399,42606198,42607290,42606268,42607835,42607451,42607946,42607667],"length":1,"stats":{"Line":5}},{"line":611,"address":[42604672],"length":1,"stats":{"Line":1}},{"line":613,"address":[42607341],"length":1,"stats":{"Line":1}},{"line":614,"address":[39198516],"length":1,"stats":{"Line":4}},{"line":615,"address":[42607803,42607745],"length":1,"stats":{"Line":1}},{"line":617,"address":[42607889],"length":1,"stats":{"Line":1}},{"line":620,"address":[42608247,42604973,42605938,42606118,42608146,42606176,42608314,42604903,42609029,42604728,42604880],"length":1,"stats":{"Line":5}},{"line":631,"address":[42604858],"length":1,"stats":{"Line":1}},{"line":633,"address":[42606009],"length":1,"stats":{"Line":1}},{"line":634,"address":[42602943,42608194,42606103,42607985,42606151],"length":1,"stats":{"Line":4}},{"line":635,"address":[42608224,42608282],"length":1,"stats":{"Line":1}},{"line":636,"address":[42608375],"length":1,"stats":{"Line":1}},{"line":641,"address":[42608444,42609301,42608955,42607909,42609629,42609200,42609007,42608846,42608380,42609368],"length":1,"stats":{"Line":4}},{"line":648,"address":[42608897],"length":1,"stats":{"Line":1}},{"line":649,"address":[42608940,42608988,42609042,42602964,42609248],"length":1,"stats":{"Line":4}},{"line":650,"address":[42609278,42609336],"length":1,"stats":{"Line":1}},{"line":652,"address":[39198579],"length":1,"stats":{"Line":2}},{"line":654,"address":[42609961],"length":1,"stats":{"Line":1}},{"line":702,"address":[42073744],"length":1,"stats":{"Line":1}},{"line":708,"address":[42616074,42616145,42617113,42616911,42617211,42616868,42617278,42616209,42617387,42617645,42616700,42617445,42617667],"length":1,"stats":{"Line":7}},{"line":718,"address":[42616768],"length":1,"stats":{"Line":1}},{"line":719,"address":[39203040],"length":1,"stats":{"Line":4}},{"line":720,"address":[42617188,42617246],"length":1,"stats":{"Line":1}},{"line":721,"address":[39203133,39203087],"length":1,"stats":{"Line":2}},{"line":723,"address":[42617494],"length":1,"stats":{"Line":1}},{"line":784,"address":[42080240],"length":1,"stats":{"Line":1}},{"line":789,"address":[42618919,42619051],"length":1,"stats":{"Line":2}},{"line":790,"address":[42619084,42623663],"length":1,"stats":{"Line":0}},{"line":794,"address":[42619065,42619122,42624867],"length":1,"stats":{"Line":3}},{"line":795,"address":[42624354,42619890,42621759,42624108,42624175,42621817,42624287,42619170,42619820,42624470,42621624,42624007],"length":1,"stats":{"Line":5}},{"line":827,"address":[42621698],"length":1,"stats":{"Line":1}},{"line":828,"address":[42621744,42621792,42623846,42618963,42624055],"length":1,"stats":{"Line":4}},{"line":829,"address":[42624085,42624143],"length":1,"stats":{"Line":1}},{"line":830,"address":[42624236,42624322],"length":1,"stats":{"Line":1}},{"line":831,"address":[42624406],"length":1,"stats":{"Line":1}},{"line":833,"address":[42624746,42623452,42619494,42624813,42624645,42621845,42623641,42623587,42625082,42621915],"length":1,"stats":{"Line":4}},{"line":857,"address":[42623526],"length":1,"stats":{"Line":1}},{"line":858,"address":[42623572,42624488,42623620,42618984,42624693],"length":1,"stats":{"Line":4}},{"line":859,"address":[42624781,42624723],"length":1,"stats":{"Line":1}},{"line":862,"address":[42624427],"length":1,"stats":{"Line":1}},{"line":999,"address":[42093968],"length":1,"stats":{"Line":1}},{"line":1007,"address":[42634000,42633915],"length":1,"stats":{"Line":2}},{"line":1009,"address":[42634031],"length":1,"stats":{"Line":1}},{"line":1010,"address":[42634070,42634166],"length":1,"stats":{"Line":2}},{"line":1012,"address":[42634116,42634187],"length":1,"stats":{"Line":2}},{"line":1013,"address":[42634224],"length":1,"stats":{"Line":1}},{"line":1014,"address":[42634334],"length":1,"stats":{"Line":1}},{"line":1016,"address":[42634267,42634517],"length":1,"stats":{"Line":2}},{"line":1017,"address":[42634624,42634534],"length":1,"stats":{"Line":2}},{"line":1019,"address":[42634645,42634577],"length":1,"stats":{"Line":2}},{"line":1020,"address":[42634814,42634682],"length":1,"stats":{"Line":2}},{"line":1022,"address":[42634991,42634725],"length":1,"stats":{"Line":2}},{"line":1023,"address":[42635028],"length":1,"stats":{"Line":1}},{"line":1024,"address":[42635160],"length":1,"stats":{"Line":1}},{"line":1026,"address":[42635071,42635337],"length":1,"stats":{"Line":2}},{"line":1027,"address":[42635374],"length":1,"stats":{"Line":1}},{"line":1028,"address":[42635506],"length":1,"stats":{"Line":1}},{"line":1030,"address":[42635417,42635683],"length":1,"stats":{"Line":2}},{"line":1031,"address":[42635720],"length":1,"stats":{"Line":1}},{"line":1032,"address":[42635852],"length":1,"stats":{"Line":1}},{"line":1034,"address":[42636029,42635763],"length":1,"stats":{"Line":2}},{"line":1035,"address":[42636066],"length":1,"stats":{"Line":1}},{"line":1036,"address":[42636188],"length":1,"stats":{"Line":1}},{"line":1038,"address":[42636109,42636365],"length":1,"stats":{"Line":2}},{"line":1039,"address":[42636469,42636393],"length":1,"stats":{"Line":2}},{"line":1041,"address":[42636436,42636524],"length":1,"stats":{"Line":2}},{"line":1042,"address":[42636552,42636628],"length":1,"stats":{"Line":2}},{"line":1044,"address":[42636595,42636683],"length":1,"stats":{"Line":2}},{"line":1045,"address":[42636711,42636787],"length":1,"stats":{"Line":2}},{"line":1047,"address":[42636842,42636754],"length":1,"stats":{"Line":2}},{"line":1048,"address":[42636959,42636870],"length":1,"stats":{"Line":2}},{"line":1050,"address":[42637014,42636913],"length":1,"stats":{"Line":2}},{"line":1051,"address":[42637051],"length":1,"stats":{"Line":1}},{"line":1052,"address":[42637176],"length":1,"stats":{"Line":1}},{"line":1054,"address":[42637094],"length":1,"stats":{"Line":1}},{"line":1055,"address":[42637350],"length":1,"stats":{"Line":1}},{"line":1056,"address":[42637950],"length":1,"stats":{"Line":1}},{"line":1057,"address":[39013271],"length":1,"stats":{"Line":2}},{"line":1095,"address":[42097104],"length":1,"stats":{"Line":1}},{"line":1100,"address":[42640020,42640363,42639226,42639361,42640797,42640819,42640063,42640265,42639852,42640539,42639297,42640430,42640597],"length":1,"stats":{"Line":5}},{"line":1112,"address":[42639920],"length":1,"stats":{"Line":1}},{"line":1113,"address":[39022816],"length":1,"stats":{"Line":4}},{"line":1114,"address":[42640398,42640340],"length":1,"stats":{"Line":1}},{"line":1115,"address":[39022909,39022863],"length":1,"stats":{"Line":1}},{"line":1116,"address":[42640646],"length":1,"stats":{"Line":1}},{"line":1131,"address":[42050688,42051815,42051840],"length":1,"stats":{"Line":1}},{"line":1132,"address":[42051030,42051762,42050896,42050695,42050836,42051241,42051107,42051643,42051164,42051298,42051700,42051566,42051432,42050973,42051509,42051375],"length":1,"stats":{"Line":16}},{"line":1133,"address":[42050795,42050901,42051926,42050852,42050788],"length":1,"stats":{"Line":3}},{"line":1134,"address":[42050986,42051035,42050932,42050925,42051911],"length":1,"stats":{"Line":3}},{"line":1135,"address":[42051059,42051169,42051066,42051120,42051899],"length":1,"stats":{"Line":3}},{"line":1136,"address":[42051303,42051200,42051887,42051254,42051193],"length":1,"stats":{"Line":3}},{"line":1137,"address":[42051388,42051327,42051437,42051334,42051875],"length":1,"stats":{"Line":3}},{"line":1138,"address":[42051461,42051468,42051571,42051522,42051863],"length":1,"stats":{"Line":3}},{"line":1139,"address":[42051595,42051656,42051705,42051602,42051851],"length":1,"stats":{"Line":3}},{"line":1140,"address":[42051833,42051775,42051728,42051721],"length":1,"stats":{"Line":2}}],"covered":214,"coverable":241},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","mod.rs"],"content":"pub mod account;\npub mod chat;\npub mod itinerary;\n\n/// A regular [axum::Router] in test and release builds, or [utoipa_axum::router::OpenApiRouter] in non-test or dev builds\n#[cfg(any(test, not(debug_assertions)))]\npub type AxumRouter = axum::Router;\n/// A regular [axum::Router] in test and release builds, or [utoipa_axum::router::OpenApiRouter] in non-test or dev builds\n#[cfg(all(not(test), debug_assertions))]\npub type AxumRouter = utoipa_axum::router::OpenApiRouter;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","db.rs"],"content":"// src/db/pool.rs\nuse sqlx::{PgPool, postgres::PgPoolOptions};\nuse std::env;\n// Pgpool- A pool of PostgreSQL connections\n// PgPoolOptions - The \"configuration options\" for creating a pool (the max number of connections).\n\npub async fn create_pool() -\u003e PgPool {\n\t// Retrieve the database URL from an environment variable\n\tlet database_url = env::var(\"DATABASE_URL\")\n\t\t//\"Panic\" if no url is found\n\t\t.expect(\"DATABASE_URL must be set in .env or environment\");\n\n\t// Creates a connection pool with up to 5 connections\n\tPgPoolOptions::new()\n\t\t.max_connections(5)\n\t\t.connect(\u0026database_url)\n\t\t.await\n\t\t.expect(\"Failed to create database pool\")\n}\n","traces":[{"line":7,"address":[38159616,38159664,38160224,38159793,38159748],"length":1,"stats":{"Line":5}},{"line":9,"address":[38159712],"length":1,"stats":{"Line":1}},{"line":14,"address":[38160038,38159871,38160409,38160151],"length":1,"stats":{"Line":4}},{"line":16,"address":[38160195,38159970,38160046,38159890,38159987],"length":1,"stats":{"Line":2}},{"line":17,"address":[38160175,38160261,38160081,38159775,38160457],"length":1,"stats":{"Line":4}}],"covered":5,"coverable":5},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","error.rs"],"content":"use axum::http::StatusCode;\nuse axum::response::{IntoResponse, Response};\nuse std::fmt;\nuse tracing::error;\n\n// Unified API result type\n#[cfg(not(tarpaulin_include))]\npub type ApiResult\u003cT\u003e = std::result::Result\u003cT, AppError\u003e;\n\n// Single unified error for the API\n#[derive(Debug)]\n#[cfg(not(tarpaulin_include))]\npub enum AppError {\n\tValidation(String),\n\tBadRequest(String),\n\tUnauthorized,\n\tNotFound,\n\tConflict(String),\n\tInternal(String),\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl AppError {\n\tpub fn status_code(\u0026self) -\u003e StatusCode {\n\t\tmatch self {\n\t\t\tAppError::Validation(_) =\u003e StatusCode::BAD_REQUEST,\n\t\t\tAppError::BadRequest(_) =\u003e StatusCode::BAD_REQUEST,\n\t\t\tAppError::Unauthorized =\u003e StatusCode::UNAUTHORIZED,\n\t\t\tAppError::NotFound =\u003e StatusCode::NOT_FOUND,\n\t\t\tAppError::Conflict(_) =\u003e StatusCode::CONFLICT,\n\t\t\tAppError::Internal(_) =\u003e StatusCode::INTERNAL_SERVER_ERROR,\n\t\t}\n\t}\n\n\tpub fn log(\u0026self) {\n\t\tmatch self {\n\t\t\tAppError::Validation(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"validation\", message = %m)\n\t\t\t}\n\t\t\tAppError::BadRequest(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"bad_request\", message = %m)\n\t\t\t}\n\t\t\tAppError::Unauthorized =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"unauthorized\")\n\t\t\t}\n\t\t\tAppError::NotFound =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"not_found\")\n\t\t\t}\n\t\t\tAppError::Conflict(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"conflict\", message = %m)\n\t\t\t}\n\t\t\tAppError::Internal(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"internal\", message = %m)\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl fmt::Display for AppError {\n\tfn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tAppError::Validation(m) =\u003e write!(f, \"validation error: {m}\"),\n\t\t\tAppError::BadRequest(m) =\u003e write!(f, \"bad request: {m}\"),\n\t\t\tAppError::Unauthorized =\u003e write!(f, \"unauthorized\"),\n\t\t\tAppError::NotFound =\u003e write!(f, \"not found\"),\n\t\t\tAppError::Conflict(m) =\u003e write!(f, \"conflict: {m}\"),\n\t\t\tAppError::Internal(m) =\u003e write!(f, \"internal error: {m}\"),\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl std::error::Error for AppError {}\n\n// Convert common error types into unified Internal errors\n#[cfg(not(tarpaulin_include))]\nimpl From\u003csqlx::Error\u003e for AppError {\n\tfn from(e: sqlx::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"db error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cargon2::password_hash::Error\u003e for AppError {\n\tfn from(e: argon2::password_hash::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"password hash error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cserde_json::Error\u003e for AppError {\n\tfn from(e: serde_json::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"json error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cstd::env::VarError\u003e for AppError {\n\tfn from(e: std::env::VarError) -\u003e Self {\n\t\tAppError::Internal(format!(\"env error: {e:?}\"))\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl IntoResponse for AppError {\n\tfn into_response(self) -\u003e Response {\n\t\t// Always log; return only status code\n\t\tself.log();\n\t\tself.status_code().into_response()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","global.rs"],"content":"pub const LOG_DIR: \u0026str = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/logs\");\npub const CRASH_LOG: \u0026str = \"crash.log\";\npub const LATEST_LOG: \u0026str = \"latest.log\";\npub const TOOLS_LOG: \u0026str = \"tools.log\";\npub const DIST_DIR: \u0026str = \"frontend/dist\";\npub const MESSAGE_PAGE_LEN: i32 = 10;\npub const EVENT_SEARCH_RESULT_LEN: i32 = 10;\npub const GOOGLE_MAPS_API_KEY: \u0026str = \"GOOGLE_MAPS_PRIVATE_API_KEY\";\n\n#[cfg(test)]\npub const TEST_COOKIE_EXP_SECONDS: i64 = 60;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","account.rs"],"content":"/*\n * src/models/account.rs\n *\n * File for Account table models and related payload/response types\n *\n * Purpose:\n *   Strongly-typed models for the `accounts` table\n */\n\nuse crate::sql_models::{BudgetBucket, RiskTolerence};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\n/// Request payload for POST `/api/account/login`.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct LoginRequest {\n\t/// Account email\n\tpub email: String,\n\t/// Plaintext password submitted by the user\n\tpub password: String,\n}\n\n/// Request payload for POST `/api/account/signup`.\n/// Validated server-side before insert.\n#[derive(Debug, Deserialize, Clone, ToSchema)]\npub struct SignupRequest {\n\t/// Account email\n\tpub email: String,\n\tpub first_name: String,\n\tpub last_name: String,\n\t/// Plaintext password submitted by the user\n\tpub password: String,\n}\n\n/// Request payload for POST `/api/account/update`.\n/// - Only `Some` fields are updated.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UpdateRequest {\n\t/// Optional new email\n\tpub email: Option\u003cString\u003e,\n\t/// Optional new first name\n\tpub first_name: Option\u003cString\u003e,\n\t/// Optional new last name\n\tpub last_name: Option\u003cString\u003e,\n\t/// Optional new plaintext password\n\tpub password: Option\u003cString\u003e,\n\t/// Current password (required if password is being updated)\n\tpub current_password: Option\u003cString\u003e,\n\t/// Optional new budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional new risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional new food and allergies preferences\n\t/// * String is a comma-separated list of preferences\n\tpub food_allergies: Option\u003cString\u003e,\n\t/// Optional new disabilites\n\t/// * String is a comma-separated list of preferences\n\tpub disabilities: Option\u003cString\u003e,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\n/// API route response for POST `/api/account/update`.\n/// - Contains full updated account profile for convenience.\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct UpdateResponse {\n\t/// Current email\n\tpub email: String,\n\t/// Current first name\n\tpub first_name: String,\n\t/// Current last name\n\tpub last_name: String,\n\t/// Optional budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional food and allergies preferences\n\t/// * String is a comma-separated list of preferences\n\tpub food_allergies: String,\n\t/// Optional disabilites\n\t/// * String is a comma-separated list of preferences\n\tpub disabilities: String,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\n/// API route response for GET `/api/account/current`.\n/// - Safe-to-return account profile for current user\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct CurrentResponse {\n\t/// Email\n\tpub email: String,\n\t/// First name\n\tpub first_name: String,\n\t/// Last name\n\tpub last_name: String,\n\t/// Optional budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional food and allergies preferences\n\t/// should this have option encoded...\n\tpub food_allergies: String,\n\t/// Optional food and allergies preferences\n\t/// should this have option encoded...\n\tpub disabilities: String,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\nimpl SignupRequest {\n\t/// Validate email format using regex.\n\t/// Validate email format using regex\n\tpub fn validate_email(email: \u0026str) -\u003e bool {\n\t\tlet email_regex = Regex::new(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\").unwrap();\n\t\temail_regex.is_match(email)\n\t}\n\n\t/// Validate password strength\n\t/// - Minimum 8 characters\n\t/// - Maximum 128 characters\n\t/// - At least one uppercase letter\n\t/// - At least one lowercase letter\n\t/// - At least one number\n\t/// - Only ASCII characters allowed (for security and compatibility)\n\tpub fn validate_password(password: \u0026str) -\u003e Result\u003c(), String\u003e {\n\t\tif password.len() \u003c 8 {\n\t\t\treturn Err(\"Password must be at least 8 characters long\".to_string());\n\t\t}\n\n\t\tif password.len() \u003e 128 {\n\t\t\treturn Err(\"Password must be 128 characters or less\".to_string());\n\t\t}\n\n\t\t// Only allow ASCII characters (prevents potential encoding issues)\n\t\tif !password.is_ascii() {\n\t\t\treturn Err(\"Password must contain only ASCII characters\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_uppercase()) {\n\t\t\treturn Err(\"Password must contain at least one uppercase letter\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_lowercase()) {\n\t\t\treturn Err(\"Password must contain at least one lowercase letter\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_numeric()) {\n\t\t\treturn Err(\"Password must contain at least one number\".to_string());\n\t\t}\n\n\t\tOk(())\n\t}\n\n\t/// Validate the entire signup payload\n\tpub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n\t\t// Validate email (trim before checking)\n\t\tlet email_trimmed = self.email.trim();\n\t\tif email_trimmed.is_empty() {\n\t\t\treturn Err(\"Email is required\".to_string());\n\t\t}\n\n\t\tif !Self::validate_email(email_trimmed) {\n\t\t\treturn Err(\"Invalid email format\".to_string());\n\t\t}\n\n\t\t// Validate first name (trim before checking)\n\t\tlet first_name_trimmed = self.first_name.trim();\n\t\tif first_name_trimmed.is_empty() {\n\t\t\treturn Err(\"First name is required\".to_string());\n\t\t}\n\n\t\tif first_name_trimmed.len() \u003e 50 {\n\t\t\treturn Err(\"First name must be 50 characters or less\".to_string());\n\t\t}\n\n\t\t// Validate last name (trim before checking)\n\t\tlet last_name_trimmed = self.last_name.trim();\n\t\tif last_name_trimmed.is_empty() {\n\t\t\treturn Err(\"Last name is required\".to_string());\n\t\t}\n\n\t\tif last_name_trimmed.len() \u003e 50 {\n\t\t\treturn Err(\"Last name must be 50 characters or less\".to_string());\n\t\t}\n\n\t\t// Validate password\n\t\tSelf::validate_password(\u0026self.password)?;\n\n\t\tOk(())\n\t}\n}\n","traces":[{"line":115,"address":[41013757,41013584,41013763],"length":1,"stats":{"Line":1}},{"line":116,"address":[41013611],"length":1,"stats":{"Line":1}},{"line":117,"address":[41013686],"length":1,"stats":{"Line":1}},{"line":127,"address":[41013776],"length":1,"stats":{"Line":1}},{"line":128,"address":[41013835],"length":1,"stats":{"Line":1}},{"line":129,"address":[41013871],"length":1,"stats":{"Line":1}},{"line":132,"address":[41013856],"length":1,"stats":{"Line":1}},{"line":133,"address":[41013951],"length":1,"stats":{"Line":1}},{"line":137,"address":[41013940],"length":1,"stats":{"Line":1}},{"line":138,"address":[41014007],"length":1,"stats":{"Line":1}},{"line":141,"address":[37418384,37418408],"length":1,"stats":{"Line":3}},{"line":142,"address":[41014117],"length":1,"stats":{"Line":1}},{"line":145,"address":[37418432,37418456],"length":1,"stats":{"Line":3}},{"line":146,"address":[41014233],"length":1,"stats":{"Line":1}},{"line":149,"address":[37418504,37418480],"length":1,"stats":{"Line":3}},{"line":150,"address":[41014352],"length":1,"stats":{"Line":1}},{"line":153,"address":[41014428],"length":1,"stats":{"Line":1}},{"line":157,"address":[41014448],"length":1,"stats":{"Line":1}},{"line":159,"address":[41014486],"length":1,"stats":{"Line":1}},{"line":160,"address":[41014534],"length":1,"stats":{"Line":1}},{"line":161,"address":[41014564],"length":1,"stats":{"Line":1}},{"line":164,"address":[41014553],"length":1,"stats":{"Line":1}},{"line":165,"address":[41014620],"length":1,"stats":{"Line":1}},{"line":169,"address":[41014681],"length":1,"stats":{"Line":1}},{"line":170,"address":[41014733],"length":1,"stats":{"Line":1}},{"line":171,"address":[41014784],"length":1,"stats":{"Line":1}},{"line":174,"address":[41014767],"length":1,"stats":{"Line":1}},{"line":175,"address":[41014920],"length":1,"stats":{"Line":1}},{"line":179,"address":[41014857],"length":1,"stats":{"Line":1}},{"line":180,"address":[41014909],"length":1,"stats":{"Line":1}},{"line":181,"address":[41015018],"length":1,"stats":{"Line":1}},{"line":184,"address":[41015001],"length":1,"stats":{"Line":1}},{"line":185,"address":[41015183],"length":1,"stats":{"Line":1}},{"line":189,"address":[41015259,41015094],"length":1,"stats":{"Line":2}},{"line":191,"address":[41015338],"length":1,"stats":{"Line":1}}],"covered":35,"coverable":35},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","chat_session.rs"],"content":"use serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::sql_models::{LlmProgress, message::ChatSessionRow};\n\n/// Response model from the `/api/chat/chats` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct ChatsResponse {\n\t/// chat session ids belonging to the user who made the request\n\tpub chat_sessions: Vec\u003cChatSessionRow\u003e,\n}\n\n/// Response model from the `/api/chat/newChat` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct NewChatResponse {\n\t/// this chat session is guaranteed to not have any messages in it\n\tpub chat_session_id: i32,\n}\n\n/// Request model for the `/api/chat/rename` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct RenameRequest {\n\tpub new_title: String,\n\tpub id: i32,\n}\n\n/// Request model for the `/api/chat/progress` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct ProgressRequest {\n\tpub chat_session_id: i32,\n}\n\n/// Response model from the `/api/chat/progress` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct ProgressResponse {\n\tpub progress: LlmProgress,\n\tpub title: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","event.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse google_maps::places_new::Place;\nuse num_traits::ToPrimitive;\nuse once_cell::sync::Lazy;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::sql_models::{Period, event_list::EventListJoinRow};\n\n/// A single event without context from an itinerary\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow, ToSchema, Default)]\npub struct Event {\n\t/// Primary key\n\tpub id: i32,\n\tpub event_name: String,\n\tpub event_description: Option\u003cString\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub user_created: bool,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub place_id: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub website_uri: Option\u003cString\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n\tpub photo_width: Option\u003ci32\u003e,\n\tpub photo_height: Option\u003ci32\u003e,\n\tpub photo_author: Option\u003cString\u003e,\n\tpub photo_author_uri: Option\u003cString\u003e,\n\tpub photo_author_photo_uri: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n\nimpl From\u003c\u0026EventListJoinRow\u003e for Event {\n\t#[cfg(not(tarpaulin_include))]\n\tfn from(value: \u0026EventListJoinRow) -\u003e Self {\n\t\tSelf {\n\t\t\tid: value.id,\n\t\t\tevent_name: value.event_name.clone(),\n\t\t\tevent_description: value.event_description.clone(),\n\t\t\tstreet_address: value.street_address.clone(),\n\t\t\tcity: value.city.clone(),\n\t\t\tcountry: value.country.clone(),\n\t\t\tpostal_code: value.postal_code,\n\t\t\tlat: value.lat.clone(),\n\t\t\tlng: value.lng.clone(),\n\t\t\tevent_type: value.event_type.clone(),\n\t\t\tuser_created: value.user_created.clone(),\n\t\t\thard_start: value.hard_start.clone(),\n\t\t\thard_end: value.hard_end.clone(),\n\t\t\ttimezone: value.timezone.clone(),\n\t\t\tplace_id: value.place_id.clone(),\n\t\t\twheelchair_accessible_parking: value.wheelchair_accessible_parking.clone(),\n\t\t\twheelchair_accessible_entrance: value.wheelchair_accessible_entrance.clone(),\n\t\t\twheelchair_accessible_restroom: value.wheelchair_accessible_restroom.clone(),\n\t\t\twheelchair_accessible_seating: value.wheelchair_accessible_seating.clone(),\n\t\t\tserves_vegetarian_food: value.serves_vegetarian_food.clone(),\n\t\t\tprice_level: value.price_level.clone(),\n\t\t\tutc_offset_minutes: value.utc_offset_minutes.clone(),\n\t\t\twebsite_uri: value.website_uri.clone(),\n\t\t\ttypes: value.types.clone(),\n\t\t\tphoto_name: value.photo_name.clone(),\n\t\t\tphoto_width: value.photo_width.clone(),\n\t\t\tphoto_height: value.photo_height.clone(),\n\t\t\tphoto_author: value.photo_author.clone(),\n\t\t\tphoto_author_uri: value.photo_author_uri.clone(),\n\t\t\tphoto_author_photo_uri: value.photo_author_photo_uri.clone(),\n\t\t\tweekday_descriptions: value.weekday_descriptions.clone(),\n\t\t\tsecondary_hours_type: value.secondary_hours_type.clone(),\n\t\t\tnext_open_time: value.next_open_time.clone(),\n\t\t\tnext_close_time: value.next_close_time.clone(),\n\t\t\topen_now: value.open_now.clone(),\n\t\t\tperiods: value.periods.clone(),\n\t\t\tspecial_days: value.special_days.clone(),\n\t\t\tblock_index: value.block_index,\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\npub static REGEX_ST_ADDR: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"street-address\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_LOCALITY: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"locality\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_COUNTRY: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"country-name\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_POST_CODE: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"postal-code\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n\n#[cfg(not(tarpaulin_include))]\nimpl From\u003c\u0026Place\u003e for Event {\n\tfn from(value: \u0026Place) -\u003e Self {\n\t\t#[inline]\n\t\tfn extract(input: \u0026str, re: \u0026Regex) -\u003e Option\u003cString\u003e {\n\t\t\tre.captures(input)\n\t\t\t\t.and_then(|caps| caps.get(1))\n\t\t\t\t.map(|m| m.as_str().to_string())\n\t\t}\n\t\tlet empty = String::new();\n\t\tlet input = value.adr_format_address.as_ref().unwrap_or(\u0026empty).as_str();\n\t\tlet street_address = extract(input, \u0026REGEX_ST_ADDR);\n\t\tlet city = extract(input, \u0026REGEX_LOCALITY);\n\t\tlet country = extract(input, \u0026REGEX_COUNTRY);\n\t\tlet postal_code = extract(input, \u0026REGEX_POST_CODE)\n\t\t\t.map(|p| p.parse().ok())\n\t\t\t.unwrap_or(None);\n\t\tSelf {\n\t\t\tid: -1,\n\t\t\tevent_name: value\n\t\t\t\t.display_name\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|n| n.to_string())\n\t\t\t\t.unwrap_or(\"Unnamed Event\".to_string()),\n\t\t\tevent_description: value.editorial_summary.as_ref().map(|n| n.to_string()),\n\t\t\tstreet_address,\n\t\t\tcity,\n\t\t\tcountry,\n\t\t\tpostal_code,\n\t\t\tlat: value.location.map(|l| l.latitude.to_f64()).unwrap_or(None),\n\t\t\tlng: value.location.map(|l| l.longitude.to_f64()).unwrap_or(None),\n\t\t\tevent_type: value.primary_type.map(|t| t.to_string()),\n\t\t\tuser_created: false,\n\t\t\thard_start: None,\n\t\t\thard_end: None,\n\t\t\ttimezone: None,\n\t\t\tplace_id: value.id.clone(),\n\t\t\twheelchair_accessible_parking: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_parking)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_entrance: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_entrance)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_restroom: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_restroom)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_seating: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_seating)\n\t\t\t\t.unwrap_or(None),\n\t\t\tserves_vegetarian_food: value.serves_vegetarian_food,\n\t\t\tprice_level: value.price_level.map(|p| p as i32),\n\t\t\tutc_offset_minutes: value.utc_offset_minutes,\n\t\t\twebsite_uri: value.website_uri.as_ref().map(|w| w.to_string()),\n\t\t\ttypes: Some(\n\t\t\t\tvalue\n\t\t\t\t\t.types\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|t| t.to_string())\n\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t.join(\",\"),\n\t\t\t),\n\t\t\tphoto_name: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].name.clone())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_width: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].width_px as i32)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_height: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].height_px as i32)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author: if value.has_photos() \u0026\u0026 !value.photos[0].author_attributions.is_empty() {\n\t\t\t\tvalue.photos[0].author_attributions[0].display_name.clone()\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author_uri: if value.has_photos()\n\t\t\t\t\u0026\u0026 !value.photos[0].author_attributions.is_empty()\n\t\t\t{\n\t\t\t\tvalue.photos[0].author_attributions[0]\n\t\t\t\t\t.uri\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map(|u| u.to_string())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author_photo_uri: if value.has_photos()\n\t\t\t\t\u0026\u0026 !value.photos[0].author_attributions.is_empty()\n\t\t\t{\n\t\t\t\tvalue.photos[0].author_attributions[0]\n\t\t\t\t\t.photo_uri\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map(|u| u.to_string())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tweekday_descriptions: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.weekday_descriptions.join(\"\\n\")),\n\t\t\tsecondary_hours_type: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.secondary_hours_type.map(|s| s as i32))\n\t\t\t\t.unwrap_or(None),\n\t\t\tnext_open_time: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.next_open_time.map(|t| {\n\t\t\t\t\t\tchrono::DateTime::parse_from_rfc3339(t.to_string().as_str())\n\t\t\t\t\t\t\t.map(|d| d.naive_utc())\n\t\t\t\t\t\t\t.ok()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(None),\n\t\t\tnext_close_time: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.next_close_time.map(|t| {\n\t\t\t\t\t\tchrono::DateTime::parse_from_rfc3339(t.to_string().as_str())\n\t\t\t\t\t\t\t.map(|d| d.naive_utc())\n\t\t\t\t\t\t\t.ok()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(None),\n\t\t\topen_now: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.open_now)\n\t\t\t\t.unwrap_or(None),\n\t\t\tperiods: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.periods\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|p| Period {\n\t\t\t\t\t\t\topen_date: p\n\t\t\t\t\t\t\t\t.open\n\t\t\t\t\t\t\t\t.date\n\t\t\t\t\t\t\t\t.map(|d| {\n\t\t\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\t\t\td.year() as i32,\n\t\t\t\t\t\t\t\t\t\td.month() as u32,\n\t\t\t\t\t\t\t\t\t\td.day() as u32,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.unwrap_or(None),\n\t\t\t\t\t\t\topen_truncated: p.open.truncated,\n\t\t\t\t\t\t\topen_day: p.open.day as i32,\n\t\t\t\t\t\t\topen_hour: p.open.hour,\n\t\t\t\t\t\t\topen_minute: p.open.minute,\n\t\t\t\t\t\t\tclose_date: p\n\t\t\t\t\t\t\t\t.close\n\t\t\t\t\t\t\t\t.as_ref()\n\t\t\t\t\t\t\t\t.map(|p| {\n\t\t\t\t\t\t\t\t\tp.date.map(|d| {\n\t\t\t\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\t\t\t\td.year() as i32,\n\t\t\t\t\t\t\t\t\t\t\td.month() as u32,\n\t\t\t\t\t\t\t\t\t\t\td.day() as u32,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.unwrap_or(None)\n\t\t\t\t\t\t\t\t.unwrap_or(None),\n\t\t\t\t\t\t\tclose_truncated: p.close.as_ref().map(|p| p.truncated).unwrap_or(None),\n\t\t\t\t\t\t\tclose_day: p.close.as_ref().map(|p| p.day as i32),\n\t\t\t\t\t\t\tclose_hour: p.close.as_ref().map(|p| p.hour),\n\t\t\t\t\t\t\tclose_minute: p.close.as_ref().map(|p| p.minute),\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect()\n\t\t\t\t})\n\t\t\t\t.unwrap_or(Vec::new()),\n\t\t\tspecial_days: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.special_days\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|d| {\n\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\td.year()? as i32,\n\t\t\t\t\t\t\t\td.month()? as u32,\n\t\t\t\t\t\t\t\td.day()? as u32,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(Vec::new()),\n\t\t\tblock_index: None,\n\t\t}\n\t}\n}\n\n/// A user-created event. It must have a name, and all other fields are optional.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UserEventRequest {\n\t/// If id is provided, it updates the user-event with that id. Otherwise it creates the event.\n\tpub id: Option\u003ci32\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub event_description: Option\u003cString\u003e,\n\tpub event_name: String,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct UserEventResponse {\n\tpub id: i32,\n}\n\n/// A set of query filters to search for an event in the DB.\n///\n/// ## Example\n/// If event_name is provided, it will query the DB with something like this:\n/// ```sql\n/// SELECT * FROM events\n/// WHERE name LIKE $1\n/// LIMIT 10;\n/// ```\n#[derive(Debug, Deserialize, ToSchema, Default, Clone)]\npub struct SearchEventRequest {\n\t/// Search where id=...\n\tpub id: Option\u003ci32\u003e,\n\t/// Search where street_address like ...\n\tpub street_address: Option\u003cString\u003e,\n\t/// Search where postal_code=...\n\tpub postal_code: Option\u003ci32\u003e,\n\t/// Search where city like ...\n\tpub city: Option\u003cString\u003e,\n\t/// Search where countr like ...\n\tpub country: Option\u003cString\u003e,\n\t/// Search where event_type like ...\n\tpub event_type: Option\u003cString\u003e,\n\t/// Search where event_description like ...\n\tpub event_description: Option\u003cString\u003e,\n\t/// Search where event_name like ...\n\tpub event_name: Option\u003cString\u003e,\n\t/// Search where hard_start \u003c ...\n\tpub hard_start_before: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_start \u003e ...\n\tpub hard_start_after: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_end \u003c ...\n\tpub hard_end_before: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_end \u003e ...\n\tpub hard_end_after: Option\u003cNaiveDateTime\u003e,\n\t/// Search where timezone like ...\n\tpub timezone: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SearchEventResponse {\n\tpub events: Vec\u003cEvent\u003e,\n}\n","traces":[{"line":106,"address":[37454000,37454018],"length":1,"stats":{"Line":0}},{"line":109,"address":[37454098,37454080],"length":1,"stats":{"Line":0}},{"line":112,"address":[37454160,37454178],"length":1,"stats":{"Line":0}},{"line":115,"address":[37454240,37454258],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","itinerary.rs"],"content":"/*\n * src/models/itinerary.rs\n *\n * File for Itinerary table models and related responses\n *\n * Purpose:\n *   Strongly-typed models for the `itineraries` response DTOs\n *   used by itinerary routes.\n */\n\nuse chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::http_models::event::Event;\n\n/// A complete itinerary with event details\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct Itinerary {\n\t/// Primary key\n\tpub id: i32,\n\t/// UTC date that the first event may take place (%Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// UTC date that the last event may take place (%Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// List of days containing events for that day\n\t/// * Days are guaranteed to be sorted in chronological order\n\tpub event_days: Vec\u003cEventDay\u003e,\n\t/// Possible associated chat session for easy editing on frontend\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Events that are not assigned to any specific time slot\n\tpub unassigned_events: Vec\u003cEvent\u003e,\n}\n\n/// A single day of events in an itinerary\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct EventDay {\n\t/// All the events taking place in the morning\n\tpub morning_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the afternoon\n\tpub afternoon_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the evening\n\tpub evening_events: Vec\u003cEvent\u003e,\n\t/// The date of this day within the range of itinerary start and end dates (Destination's local timezone - %Y-%m-%d)\n\tpub date: NaiveDate,\n}\n\n/// API route response for GET `/api/itinerary/saved`\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct SavedResponse {\n\t/// List of saved itineraries for the user.\n\tpub itineraries: Vec\u003cItinerary\u003e,\n}\n\n/// Response model from `/api/itinerary/save` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SaveResponse {\n\t/// id of the itinerary that was just saved\n\t/// * May be the same as the itinerary id passed in the request\n\tpub id: i32,\n}\n\n/// Request model from /api/itinerary/unsave\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UnsaveRequest {\n\t/// itinerary id to unsave\n\tpub id: i32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","message.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\n/// A message in a chat session\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct Message {\n\t/// Primary key\n\tpub id: i32,\n\t/// Whether the message was sent by a user or generated by the LLM\n\tpub is_user: bool,\n\t/// UTC timestamp this message was sent (%Y-%m-%d %H:%M:%S)\n\tpub timestamp: NaiveDateTime,\n\t/// Content of this message\n\tpub text: String,\n\t/// Possible itinerary associated with this message\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/messagePage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct MessagePageRequest {\n\t/// chat session to fetch page from\n\tpub chat_session_id: i32,\n\t/// Possible message id to represent the end of the page\n\t/// * If Some, it will fetch this message and consecutive previous messages in chronological order\n\t/// * If None, it will fetch the latest consecutive messages from the chat session in chronological order\n\tpub message_id: Option\u003ci32\u003e,\n}\n\n/// Response model for `/api/chat/messagePage` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct MessagePageResponse {\n\t/// A page of messages guaranteed to be sorted in chronological order\n\tpub message_page: Vec\u003cMessage\u003e,\n\t/// The id of the message that comes chronologically before the first message in message_page, if it exists\n\tpub prev_message_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/updateMessage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct UpdateMessageRequest {\n\t/// ID of the message to update. This message must belong to a chat session which belongs to the user who made the request\n\tpub message_id: i32,\n\t/// The text to replace the old content with\n\tpub new_text: String,\n\t/// A possible itinerary to give context to the LLM\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/sendMessage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct SendMessageRequest {\n\t/// The chat session to send this message in. It must belong to the user making the request.\n\tpub chat_session_id: i32,\n\t/// The content of the message\n\tpub text: String,\n\t/// A possible itinerary to give context to the LLM\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Response model for `/api/chat/sendMessage` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SendMessageResponse {\n\t/// The newly-created id of the message you just sent\n\tpub user_message_id: i32,\n\t/// The response message from the LLM\n\tpub bot_message: Message,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","mod.rs"],"content":"pub mod account;\npub mod chat_session;\npub mod event;\npub mod itinerary;\npub mod message;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","log.rs"],"content":"use {\n\tcrate::global::*,\n\tstd::{\n\t\tfs::{self, File},\n\t\tio::{BufWriter, Write},\n\t\tpath::Path,\n\t\tsync::{Once, OnceLock},\n\t},\n\ttracing::error,\n\ttracing_appender::{non_blocking::NonBlocking, rolling},\n\ttracing_subscriber::{\n\t\tEnvFilter, Layer, fmt::time::SystemTime, layer::SubscriberExt, util::SubscriberInitExt,\n\t},\n};\n\nstatic INIT_LOG: Once = Once::new();\nstatic mut LOG_WRITER: OnceLock\u003cNonBlocking\u003e = OnceLock::new();\nstatic mut TOOLS_LOG_WRITER: OnceLock\u003cNonBlocking\u003e = OnceLock::new();\n\n/// When the program panics, the backtrace is outputted to `logs/crash.log`.\npub fn init_panic_handler() {\n\tunsafe {\n\t\t// Safety\n\t\t//\n\t\t// Always safe on Windows.\n\t\t//\n\t\t// Other platforms: risk of race condition in multi-threaded environment.\n\t\t// We are not reading/writing this environment variable from multiple threads, so we're good.\n\t\tstd::env::set_var(\"RUST_BACKTRACE\", \"full\");\n\t}\n\tstd::panic::set_hook(Box::new(move |panic_info| {\n\t\tconst WRITE_ERR: \u0026str = \"Could not write to crash log\";\n\t\terror!(\"{}\", panic_info);\n\t\tprintln!(\"{}\", panic_info);\n\n\t\tfs::create_dir_all(LOG_DIR).expect(\"Could create crash log\");\n\t\tlet file = File::create(Path::new(LOG_DIR).join(CRASH_LOG))\n\t\t\t.expect(\"Could not create crash log file\");\n\t\tlet backtrace = std::backtrace::Backtrace::capture();\n\t\tlet mut writer = BufWriter::new(file);\n\n\t\twriteln!(writer, \"Time: {}\", chrono::Local::now()).expect(WRITE_ERR);\n\t\twriteln!(writer, \"{panic_info}\").expect(WRITE_ERR);\n\t\twriteln!(writer, \"stack backtrace:\\n{backtrace}\").expect(WRITE_ERR);\n\t\twriteln!(writer, \"Process finished with exit code 101\").expect(WRITE_ERR);\n\t\twriter.flush().expect(WRITE_ERR);\n\t}));\n}\n\n/// Creates a tracing registry and adds a layer to it. Layer outputs to `logs/latest.log`.\n///\n/// See `.env` variable `RUST_LOG` for layer filter. These variables should be loaded into the environment for the filter to work.\n/// See [dotenvy].\npub fn init_logger() {\n\tINIT_LOG.call_once(|| {\n\t\t// Remove old logs\n\t\t_ = fs::remove_file(Path::new(LOG_DIR).join(LATEST_LOG));\n\t\t_ = fs::remove_file(Path::new(LOG_DIR).join(TOOLS_LOG));\n\n\t\t// Setup main log writer\n\t\tlet (log_writer, log_guard) =\n\t\t\ttracing_appender::non_blocking(rolling::never(LOG_DIR, LATEST_LOG));\n\t\tlet latest_log_layer = tracing_subscriber::fmt::layer()\n\t\t\t.with_timer(SystemTime)\n\t\t\t.with_ansi(false)\n\t\t\t.log_internal_errors(true)\n\t\t\t.with_target(true)\n\t\t\t.with_file(true)\n\t\t\t.with_line_number(true)\n\t\t\t.with_level(true)\n\t\t\t.with_thread_names(true)\n\t\t\t.with_thread_ids(true)\n\t\t\t.pretty()\n\t\t\t.with_writer(log_writer.clone())\n\t\t\t.with_filter(EnvFilter::from_default_env());\n\n\t\t// Setup tools log writer (only captures tool_trace target)\n\t\tlet (tools_log_writer, tools_guard) =\n\t\t\ttracing_appender::non_blocking(rolling::never(LOG_DIR, TOOLS_LOG));\n\t\tlet tools_log_layer = tracing_subscriber::fmt::layer()\n\t\t\t.with_timer(SystemTime)\n\t\t\t.with_ansi(false)\n\t\t\t.log_internal_errors(false)\n\t\t\t.with_target(false)\n\t\t\t.with_file(false)\n\t\t\t.with_line_number(false)\n\t\t\t.with_level(false)\n\t\t\t.with_thread_names(false)\n\t\t\t.with_thread_ids(false)\n\t\t\t.compact()\n\t\t\t.with_writer(tools_log_writer.clone())\n\t\t\t.with_filter(EnvFilter::new(\"tool_trace=info\"));\n\n\t\ttracing_subscriber::registry()\n\t\t\t.with(latest_log_layer)\n\t\t\t.with(tools_log_layer)\n\t\t\t.init();\n\n\t\t#[allow(static_mut_refs)]\n\t\tunsafe {\n\t\t\t_ = LOG_WRITER.set(log_writer);\n\t\t\t_ = TOOLS_LOG_WRITER.set(tools_log_writer);\n\t\t}\n\n\t\t// Guards have to have a static lifetime.\n\t\t// We can just let the OS clean it up for us when the process is killed.\n\t\tBox::leak(Box::new(log_guard));\n\t\tBox::leak(Box::new(tools_guard));\n\t})\n}\n\n#[allow(unused)]\npub fn log_writer() -\u003e \u0026'static mut NonBlocking {\n\t#[allow(static_mut_refs)]\n\tunsafe {\n\t\tLOG_WRITER.get_mut().expect(\"Logger not initialized\")\n\t}\n}\n\n/// Macro for logging tool calls to tools.log with a simple stack trace format\n/// Usage: tool_trace!(agent: \"orchestrator\", tool: \"route_task\", status: \"start\", details: \"task_type=research\")\n#[macro_export]\nmacro_rules! tool_trace {\n\t(agent: $agent:expr, tool: $tool:expr, status: $status:expr) =\u003e {\n\t\ttracing::info!(\n\t\t\ttarget: \"tool_trace\",\n\t\t\t\"[{}] {} | {}\",\n\t\t\t$agent,\n\t\t\t$tool,\n\t\t\t$status\n\t\t);\n\t};\n\t(agent: $agent:expr, tool: $tool:expr, status: $status:expr, details: $details:expr) =\u003e {\n\t\ttracing::info!(\n\t\t\ttarget: \"tool_trace\",\n\t\t\t\"[{}] {} | {} | {}\",\n\t\t\t$agent,\n\t\t\t$tool,\n\t\t\t$status,\n\t\t\t$details\n\t\t);\n\t};\n}\n","traces":[{"line":21,"address":[42946784],"length":1,"stats":{"Line":1}},{"line":29,"address":[42946785],"length":1,"stats":{"Line":1}},{"line":31,"address":[38902048,38904351,38904357],"length":1,"stats":{"Line":2}},{"line":33,"address":[38902984,38902071],"length":1,"stats":{"Line":1}},{"line":34,"address":[38902708],"length":1,"stats":{"Line":1}},{"line":36,"address":[38902780],"length":1,"stats":{"Line":1}},{"line":37,"address":[38902848],"length":1,"stats":{"Line":1}},{"line":38,"address":[38902923],"length":1,"stats":{"Line":1}},{"line":39,"address":[38902962],"length":1,"stats":{"Line":1}},{"line":40,"address":[38903624],"length":1,"stats":{"Line":1}},{"line":42,"address":[38903767,38903695],"length":1,"stats":{"Line":2}},{"line":43,"address":[38903903],"length":1,"stats":{"Line":1}},{"line":44,"address":[38904039],"length":1,"stats":{"Line":1}},{"line":45,"address":[38904159],"length":1,"stats":{"Line":1}},{"line":46,"address":[38904256],"length":1,"stats":{"Line":1}},{"line":54,"address":[42946848],"length":1,"stats":{"Line":1}},{"line":55,"address":[38906878,38904400,38907025],"length":1,"stats":{"Line":2}},{"line":57,"address":[38904467],"length":1,"stats":{"Line":1}},{"line":58,"address":[38904684],"length":1,"stats":{"Line":1}},{"line":61,"address":[38904816],"length":1,"stats":{"Line":1}},{"line":62,"address":[38904793],"length":1,"stats":{"Line":1}},{"line":63,"address":[38905377,38904936],"length":1,"stats":{"Line":2}},{"line":64,"address":[38905000],"length":1,"stats":{"Line":1}},{"line":65,"address":[38905025],"length":1,"stats":{"Line":1}},{"line":66,"address":[38905032],"length":1,"stats":{"Line":1}},{"line":67,"address":[38905085],"length":1,"stats":{"Line":1}},{"line":68,"address":[38905113],"length":1,"stats":{"Line":1}},{"line":69,"address":[38905141],"length":1,"stats":{"Line":1}},{"line":70,"address":[38905169],"length":1,"stats":{"Line":1}},{"line":71,"address":[38905197],"length":1,"stats":{"Line":1}},{"line":72,"address":[38905225],"length":1,"stats":{"Line":1}},{"line":73,"address":[38905248],"length":1,"stats":{"Line":1}},{"line":74,"address":[38905271],"length":1,"stats":{"Line":1}},{"line":75,"address":[38905336,38906984,38905317,38905409],"length":1,"stats":{"Line":2}},{"line":78,"address":[38905536],"length":1,"stats":{"Line":1}},{"line":79,"address":[38905432,38905529],"length":1,"stats":{"Line":2}},{"line":80,"address":[38906080,38905656],"length":1,"stats":{"Line":2}},{"line":81,"address":[38905720],"length":1,"stats":{"Line":1}},{"line":82,"address":[38905745],"length":1,"stats":{"Line":1}},{"line":83,"address":[38905770],"length":1,"stats":{"Line":1}},{"line":84,"address":[38905795],"length":1,"stats":{"Line":1}},{"line":85,"address":[38905820],"length":1,"stats":{"Line":1}},{"line":86,"address":[38905845],"length":1,"stats":{"Line":1}},{"line":87,"address":[38905870],"length":1,"stats":{"Line":1}},{"line":88,"address":[38905895],"length":1,"stats":{"Line":1}},{"line":89,"address":[38905920],"length":1,"stats":{"Line":1}},{"line":90,"address":[38905943],"length":1,"stats":{"Line":1}},{"line":91,"address":[38905966],"length":1,"stats":{"Line":1}},{"line":92,"address":[38906112,38906012,38906039,38906892],"length":1,"stats":{"Line":2}},{"line":94,"address":[38906135],"length":1,"stats":{"Line":1}},{"line":95,"address":[38906195],"length":1,"stats":{"Line":1}},{"line":96,"address":[38906266],"length":1,"stats":{"Line":1}},{"line":97,"address":[38906345],"length":1,"stats":{"Line":1}},{"line":101,"address":[38906352],"length":1,"stats":{"Line":1}},{"line":102,"address":[38906474],"length":1,"stats":{"Line":1}},{"line":107,"address":[38906596],"length":1,"stats":{"Line":1}},{"line":108,"address":[38906700],"length":1,"stats":{"Line":1}},{"line":113,"address":[42946880],"length":1,"stats":{"Line":1}},{"line":116,"address":[42946881,42946946],"length":1,"stats":{"Line":1}},{"line":125,"address":[39712897,39970472,39804265,39734227,39855528,39712493,39921816,39970555,39763705,39733820,39921733,39712410,39763301,39922223,39855935,39970962,39855445,39803778,39733737,39763218,39803861],"length":1,"stats":{"Line":0}},{"line":134,"address":[40370390,40299805,40352831,40291455,40300463,40378429,40301173,40372393,40301618,40303056,40357848,40298622,40304831,40379209,40377990,40305521,40304022,40356867,40302398,40371672,40370829,40290730,40299025,40296582,40355764,40379867,40289883,40303588,40289425,40355361],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":61},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","main.rs"],"content":"#![allow(unexpected_cfgs)]\n\nmod controllers;\nmod db;\nmod http_models;\nmod log;\nmod middleware;\nmod sql_models;\n\n#[cfg(not(tarpaulin_include))]\nmod agent;\n#[cfg(not(tarpaulin_include))]\nmod error;\n#[cfg(not(tarpaulin_include))]\nmod global;\n#[cfg(not(tarpaulin_include))]\nmod swagger;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::controllers::AxumRouter;\nuse crate::global::*;\nuse crate::http_models::event::{REGEX_COUNTRY, REGEX_LOCALITY, REGEX_POST_CODE, REGEX_ST_ADDR};\nuse axum::{Extension, routing::get_service};\nuse http::{Method, header::HeaderValue};\nuse std::env;\nuse std::net::SocketAddr;\nuse std::path::Path;\nuse std::str::FromStr;\nuse tower_cookies::CookieManagerLayer;\nuse tower_cookies::cookie::Key;\nuse tower_http::{\n\tcors::CorsLayer,\n\tservices::{ServeDir, ServeFile},\n};\n\n#[tokio::main]\nasync fn main() -\u003e std::result::Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\t#[cfg(not(tarpaulin_include))]\n\t{\n\t\t// Load our evironment variables\n\t\tdotenvy::dotenv().ok();\n\t\tlog::init_panic_handler();\n\t\tlog::init_logger();\n\n\t\t// Read and store loaded environment variables\n\t\tlet api_base_url = env::var(\"API_BASE_URL\").expect(\"API_BASE_URL must be set\");\n\t\tlet front_end_url = env::var(\"FRONTEND_URL\").expect(\"FRONTEND_URL must be set\");\n\t\tlet bind_address = env::var(\"BIND_ADDRESS\").expect(\"BIND_ADDRESS must be set\");\n\n\t\t// Initialize the database pool connection\n\t\tlet pool = db::create_pool().await;\n\n\t\t// compile regexes ahead of time\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_ST_ADDR);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_LOCALITY);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_POST_CODE);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_COUNTRY);\n\n\t\t// Initialize the AI agent\n\t\t// The agent will use MockLLM when DEPLOY_LLM != \"1\", so creation should always succeed\n\t\tlet (agent, chat_session_id, user_id, context_store) =\n\t\t\tagent::configs::orchestrator::create_orchestrator_agent(pool.clone())\n\t\t\t\t.expect(\"Failed to create orchestrator agent\");\n\n\t\t/*\n\t\t/ Configure CORS\n\t\t/ CORS is needed when a frontend (running on one domain or port)\n\t\t/ wants to send HTTP requests to a backend running on another domain or port.\n\t\t/ This is needed for the frontend to send requests to the backend.\n\t\t/ We allow all origins, methods, and headers currently, but this should be changed later for security.\n\t\t/ TODO: Ensure we have all the right values below, may need to constrict the requests we accept\n\t\t*/\n\t\tlet cors = CorsLayer::new()\n\t\t\t.allow_origin(\n\t\t\t\tfront_end_url\n\t\t\t\t\t.parse::\u003cHeaderValue\u003e()\n\t\t\t\t\t.expect(\"Invalid frontend_url format\"),\n\t\t\t)\n\t\t\t.allow_credentials(true)\n\t\t\t.allow_methods([Method::GET, Method::POST, Method::DELETE])\n\t\t\t.allow_headers([\n\t\t\t\thttp::header::CONTENT_TYPE,\n\t\t\t\thttp::header::ACCEPT,\n\t\t\t\thttp::header::AUTHORIZATION,\n\t\t\t\thttp::header::HeaderName::from_static(\"x-requested-with\"),\n\t\t\t]);\n\n\t\t// Use an encryption/signing key for private cookies\n\t\tlet cookie_key = Key::generate();\n\n\t\t// API routes with CORS middleware\n\t\tlet api_routes = AxumRouter::new()\n\t\t\t.nest(\"/account\", controllers::account::account_routes())\n\t\t\t.nest(\"/itinerary\", controllers::itinerary::itinerary_routes())\n\t\t\t.nest(\"/chat\", controllers::chat::chat_routes());\n\t\t// TODO: nest other routes...\n\n\t\tlet api_routes = AxumRouter::new().nest(\"/api\", api_routes);\n\n\t\t#[cfg(all(not(test), debug_assertions))]\n\t\tlet api_routes = crate::swagger::merge_swagger(api_routes);\n\n\t\t// Build the main router\n\t\tlet app = axum::Router::new()\n\t\t\t.merge(api_routes)\n\t\t\t// Static files served from /dist.\n\t\t\t// Fallback must be index.html since react handles routing on front end\n\t\t\t.fallback_service(get_service(\n\t\t\t\tServeDir::new(DIST_DIR)\n\t\t\t\t\t.fallback(ServeFile::new(Path::new(DIST_DIR).join(\"index.html\"))),\n\t\t\t))\n\t\t\t.layer(Extension(pool.clone()))\n\t\t\t.layer(Extension(cookie_key.clone()))\n\t\t\t.layer(Extension(std::sync::Arc::new(tokio::sync::Mutex::new(\n\t\t\t\tagent,\n\t\t\t))))\n\t\t\t.layer(Extension(chat_session_id))\n\t\t\t.layer(Extension(user_id))\n\t\t\t.layer(Extension(context_store))\n\t\t\t.layer(CookieManagerLayer::new())\n\t\t\t.layer(cors);\n\n\t\t/*\n\t\t/ Bind the router to a specific port\n\t\t/ We use the SocketAddr struct to bind the router to the port\n\t\t/ We use the 0.0.0.0 address to bind the router to localhost\n\t\t/ We will bind to port 3001 for now\n\t\t*/\n\t\tlet addr = SocketAddr::from_str(\u0026bind_address).expect(\"Invalid BIND_ADDRESS format\");\n\t\tprintln!(\"Server starting on {}\", api_base_url);\n\n\t\t/*\n\t\t/ Serve the router ie: Start the server\n\t\t/ We will start the server with the configured router and address\n\t\t*/\n\t\tlet listener = tokio::net::TcpListener::bind(addr).await.unwrap();\n\t\taxum::serve(listener, app.into_make_service()).await?;\n\n\t\tOk(())\n\t}\n}\n","traces":[{"line":39,"address":[39434126,39434132,39433680],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","middleware.rs"],"content":"use crate::error::AppError;\nuse axum::{extract::Request, middleware::Next, response::IntoResponse};\nuse chrono::Utc;\nuse sqlx::PgPool;\nuse tower_cookies::{\n\tCookies,\n\tcookie::{\n\t\tCookie, Key, SameSite,\n\t\ttime::{Duration, OffsetDateTime},\n\t},\n};\n\n/// Inserted into request extensions on authenticated requests\n#[derive(Clone, Copy, Debug)]\npub struct AuthUser {\n\tpub id: i32,\n}\n\n/// Auth middleware for account routes\n/// - Decrypts `auth-token` private cookie using `Key` from extensions\n/// - Validates embedded expiration and that the user exists in DB\n/// - Inserts `AuthUser` into request extensions on success; otherwise 401\npub async fn middleware_auth(cookies: Cookies, mut req: Request, next: Next) -\u003e impl IntoResponse {\n\tlet key = match req.extensions().get::\u003cKey\u003e() {\n\t\tSome(k) =\u003e k.clone(),\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\tlet pool = match req.extensions().get::\u003cPgPool\u003e() {\n\t\tSome(p) =\u003e p.clone(),\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\t// Decrypt private cookie and extract token\n\tlet decrypted = match cookies.private(\u0026key).get(\"auth-token\") {\n\t\tSome(c) =\u003e c,\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\tlet token = decrypted.value().to_string();\n\n\t// Expect format: user-\u003cid\u003e.\u003cexp\u003e.sign\n\tlet parts: Vec\u003c\u0026str\u003e = token.split('.').collect();\n\n\tif parts.len() != 3 || parts[2] != \"sign\" || !parts[0].starts_with(\"user-\") {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\tlet user_id: i32 = match parts[0][5..].parse() {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\tlet exp: i64 = match parts[1].parse() {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\tlet now = Utc::now().timestamp();\n\tif now \u003e exp {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\t// If the cookie will expire in less than an hour, set it's expiration to one hour from now\n\tlet one_hour = 3600;\n\tif exp - now \u003c one_hour {\n\t\tlet new_exp = now + one_hour;\n\t\tlet new_token = format!(\"user-{}.{}.sign\", user_id, new_exp);\n\n\t\tlet domain = option_env!(\"DOMAIN\").unwrap_or(\"localhost\");\n\t\tlet app_env = option_env!(\"APP_ENV\").unwrap_or(\"development\");\n\t\tlet on_production = app_env == \"production\";\n\n\t\tlet new_cookie = Cookie::build((\"auth-token\", new_token.clone()))\n\t\t\t.domain(domain.to_string())\n\t\t\t.path(\"/\")\n\t\t\t.secure(on_production)\n\t\t\t.http_only(true)\n\t\t\t.same_site(if on_production {\n\t\t\t\tSameSite::Strict\n\t\t\t} else {\n\t\t\t\tSameSite::Lax\n\t\t\t})\n\t\t\t.expires(OffsetDateTime::now_utc().saturating_add(Duration::hours(1)))\n\t\t\t.max_age(Duration::hours(1))\n\t\t\t.build();\n\n\t\tcookies.private(\u0026key).add(new_cookie);\n\t}\n\n\t// Ensure user exists\n\tlet exists_row =\n\t\tsqlx::query_as::\u003c_, (bool,)\u003e(\"SELECT EXISTS(SELECT 1 FROM accounts WHERE id = $1)\")\n\t\t\t.bind(user_id)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.unwrap_or((false,));\n\n\tif !exists_row.0 {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\t// Attach user to request\n\treq.extensions_mut().insert(AuthUser { id: user_id });\n\n\tnext.run(req).await\n}\n","traces":[{"line":23,"address":[41289344,41293340,41293481,41289110,41289040,41294082],"length":1,"stats":{"Line":4}},{"line":24,"address":[41289325,41289464],"length":1,"stats":{"Line":2}},{"line":25,"address":[41289534],"length":1,"stats":{"Line":1}},{"line":26,"address":[41289564],"length":1,"stats":{"Line":0}},{"line":28,"address":[41289638],"length":1,"stats":{"Line":1}},{"line":29,"address":[41289855,41289742],"length":1,"stats":{"Line":2}},{"line":30,"address":[41289791],"length":1,"stats":{"Line":0}},{"line":34,"address":[41289858,41290068,41289969],"length":1,"stats":{"Line":3}},{"line":35,"address":[41290157],"length":1,"stats":{"Line":1}},{"line":36,"address":[41290222],"length":1,"stats":{"Line":1}},{"line":38,"address":[41290364],"length":1,"stats":{"Line":1}},{"line":41,"address":[41290444,41290541],"length":1,"stats":{"Line":2}},{"line":43,"address":[41290692,41290607,41290790],"length":1,"stats":{"Line":3}},{"line":44,"address":[41293479,41290744],"length":1,"stats":{"Line":0}},{"line":47,"address":[41290942],"length":1,"stats":{"Line":1}},{"line":48,"address":[41291166],"length":1,"stats":{"Line":1}},{"line":49,"address":[41293477,41291120],"length":1,"stats":{"Line":0}},{"line":52,"address":[41291186],"length":1,"stats":{"Line":1}},{"line":53,"address":[41291316],"length":1,"stats":{"Line":1}},{"line":54,"address":[41293475,41291278],"length":1,"stats":{"Line":0}},{"line":57,"address":[41291340],"length":1,"stats":{"Line":1}},{"line":58,"address":[41291410],"length":1,"stats":{"Line":1}},{"line":59,"address":[41293444,41291461],"length":1,"stats":{"Line":0}},{"line":63,"address":[41291431],"length":1,"stats":{"Line":1}},{"line":64,"address":[41291443,41291507],"length":1,"stats":{"Line":2}},{"line":65,"address":[41291672,41291579],"length":1,"stats":{"Line":1}},{"line":66,"address":[41291622,41291693],"length":1,"stats":{"Line":2}},{"line":68,"address":[41291836,41291939],"length":1,"stats":{"Line":2}},{"line":69,"address":[41291971],"length":1,"stats":{"Line":1}},{"line":70,"address":[41292034],"length":1,"stats":{"Line":1}},{"line":72,"address":[41292077,41292796,41292146,41292669,41292306],"length":1,"stats":{"Line":5}},{"line":73,"address":[41292314,41292111,41293422,41292246,41292265],"length":1,"stats":{"Line":2}},{"line":75,"address":[41292431],"length":1,"stats":{"Line":1}},{"line":77,"address":[41292506,41292492,41292516],"length":1,"stats":{"Line":3}},{"line":78,"address":[41292508],"length":1,"stats":{"Line":0}},{"line":80,"address":[41292498],"length":1,"stats":{"Line":1}},{"line":82,"address":[41292392,41292570,41292677,41292563,41293400],"length":1,"stats":{"Line":2}},{"line":83,"address":[41292755,41292728,41292828,41293368],"length":1,"stats":{"Line":2}},{"line":86,"address":[41292917,41293003],"length":1,"stats":{"Line":2}},{"line":90,"address":[41293285,41293673,41293760,41291537],"length":1,"stats":{"Line":4}},{"line":92,"address":[41293187],"length":1,"stats":{"Line":1}},{"line":93,"address":[41293224],"length":1,"stats":{"Line":1}},{"line":94,"address":[39189379],"length":1,"stats":{"Line":4}},{"line":95,"address":[41293745],"length":1,"stats":{"Line":1}},{"line":97,"address":[41293772],"length":1,"stats":{"Line":1}},{"line":98,"address":[41293776,41293841],"length":1,"stats":{"Line":0}},{"line":102,"address":[41294194,41293819],"length":1,"stats":{"Line":2}},{"line":104,"address":[39189400],"length":1,"stats":{"Line":2}}],"covered":40,"coverable":48},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","account.rs"],"content":"/// Row model for the `accounts` table.\n/// - Represents a persisted user.\npub struct AccountRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Unique email address\n\t#[allow(dead_code)] // email required for login route\n\tpub email: String,\n\t/// Argon2 hashed password\n\tpub password: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","event_list.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse serde::{Deserialize, Serialize};\n\nuse crate::sql_models::{Period, TimeOfDay};\n\n/// Row model for an inner join of `event_list` and `events` tables on chat session id.\n/// - Represents one event for an itinerary.\n#[derive(Debug, Serialize, Deserialize)]\npub struct EventListJoinRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Event name\n\tpub event_name: String,\n\t/// Event description\n\tpub event_description: Option\u003cString\u003e,\n\t/// Event address\n\tpub street_address: Option\u003cString\u003e,\n\t/// Event City\n\tpub city: Option\u003cString\u003e,\n\t/// Event Country\n\tpub country: Option\u003cString\u003e,\n\t/// Event post code\n\tpub postal_code: Option\u003ci32\u003e,\n\t/// Location coordinates\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\t/// Event type\n\tpub event_type: Option\u003cString\u003e,\n\t/// User-Created\n\tpub user_created: bool,\n\t/// Hard Start Time\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\t/// Hard End Time\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub place_id: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub website_uri: Option\u003cString\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n\tpub photo_width: Option\u003ci32\u003e,\n\tpub photo_height: Option\u003ci32\u003e,\n\tpub photo_author: Option\u003cString\u003e,\n\tpub photo_author_uri: Option\u003cString\u003e,\n\tpub photo_author_photo_uri: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Morning/Noon/Afternoon/Evening\n\tpub time_of_day: TimeOfDay,\n\t/// UTC date within itinerary date range (%Y-%m-%d)\n\tpub date: NaiveDate,\n\t/// Index the event is in within the time block.\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","itinerary.rs"],"content":"use chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\n\n/// Row model for the `itineraries` table.\n#[derive(Debug, Serialize, Deserialize)]\npub struct ItineraryRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Owner account id (FK)\n\tpub account_id: Option\u003ci32\u003e,\n\t/// Start date for itinerary (Destination's local timezone - naive %Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// End date for itinerary (Destination's local timezone - naive %Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// Possible chat session to link to if this itinerary is edited\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Array of event IDs that are unassigned to any specific time slot\n\tpub unassigned_event_ids: Option\u003cVec\u003ci32\u003e\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","message.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::ToSchema;\n\n/// Row model for `chat_sessions` table\n#[derive(Serialize, Deserialize, FromRow, ToSchema)]\npub struct ChatSessionRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Name of chat for user context\n\tpub title: String,\n}\n\n/// Row model for `message` table\n#[derive(Serialize, Deserialize, FromRow)]\npub struct MessageRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Chat session this message belongs to\n\tpub chat_session_id: i32,\n\t/// Possible itinerary associated with this message\n\tpub itinerary_id: Option\u003ci32\u003e,\n\t/// Whether this message was sent by the user or generated by the LLM\n\tpub is_user: bool,\n\t/// UTC timestamp this message was sent (%Y-%m-%d %H:%M:%S)\n\tpub timestamp: NaiveDateTime,\n\t/// Content of the message\n\tpub text: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","mod.rs"],"content":"use chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\nuse sqlx::Type;\nuse utoipa::ToSchema;\n\npub mod account;\npub mod event_list;\npub mod itinerary;\npub mod message;\n\n/// Budget preference enum mapped to Postgres `budget_bucket`.\n/// Used in account preferences and returned by account APIs.\n/// - Fields:\n///   - Enum variants representing budget bands\n#[derive(Debug, Serialize, Deserialize, Clone, Type, ToSchema)]\n#[sqlx(type_name = \"budget_bucket\")]\npub enum BudgetBucket {\n\tVeryLowBudget,\n\tLowBudget,\n\tMediumBudget,\n\tHighBudget,\n\tLuxuryBudget,\n}\n\n/// Risk tolerance enum mapped to Postgres `risk_tolerence`.\n/// Used in account preferences and returned by account APIs.\n/// - Fields:\n///   - Enum variants representing risk appetite\n#[derive(Debug, Serialize, Deserialize, Clone, Type, ToSchema)]\n#[sqlx(type_name = \"risk_tolerence\")]\npub enum RiskTolerence {\n\tChillVibes,\n\tLightFun,\n\tAdventurer,\n\tRiskTaker,\n}\n\n/// The time of day the event will take place in the itinerary\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq)]\n#[sqlx(type_name = \"time_of_day\")]\npub enum TimeOfDay {\n\tMorning,\n\tAfternoon,\n\tEvening,\n}\n\n/// The status of the LLM pipeline\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq, ToSchema)]\n#[sqlx(type_name = \"llm_progress\")]\npub enum LlmProgress {\n\tReady,\n\t// Task Agent Tools\n\tRetrieveUserProfile,\n\tRetrieveChatContext,\n\tUpdateTripContext,\n\tUpdateChatTitle,\n\tAskForClarification,\n\t// Research Agent\n\tSearching,\n\tGeocoding,\n\tSearchingEvents,\n\t// Constraint Agent\n\tFiltering,\n\tCheckingConstraints,\n\t// Scheduling\n\tScheduling,\n\t// Optimizer Agent\n\tOptimizing,\n\tRankingEvents,\n\t// Final Response\n\tFinalizingItinerary,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq, ToSchema)]\n#[sqlx(type_name = \"event_period\")]\npub struct Period {\n\tpub open_date: Option\u003cNaiveDate\u003e,\n\tpub open_truncated: Option\u003cbool\u003e,\n\tpub open_day: i32,\n\tpub open_hour: i32,\n\tpub open_minute: i32,\n\tpub close_date: Option\u003cNaiveDate\u003e,\n\tpub close_truncated: Option\u003cbool\u003e,\n\tpub close_day: Option\u003ci32\u003e,\n\tpub close_hour: Option\u003ci32\u003e,\n\tpub close_minute: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","swagger.rs"],"content":"use axum::Router;\nuse std::fs::{self, File};\nuse std::io::Write;\nuse std::path::PathBuf;\nuse utoipa::{\n\tModify, OpenApi,\n\topenapi::security::{ApiKey, ApiKeyValue, SecurityScheme},\n};\nuse utoipa_axum::router::OpenApiRouter;\nuse utoipa_swagger_ui::SwaggerUi;\n\nuse crate::controllers::{account::AccountApiDoc, chat::ChatApiDoc, itinerary::ItineraryApiDoc};\n\n#[derive(OpenApi)]\n#[openapi(\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n    info(\n    \ttitle=\"Journey API\",\n    \tdescription = \"The public API documentation for the Journey web application.\"\n    ),\n    nest(\n    \t(path=\"/api/account\", api=AccountApiDoc),\n    \t(path=\"/api/chat\", api=ChatApiDoc),\n    \t(path=\"/api/itinerary\", api=ItineraryApiDoc)\n    ),\n    servers(\n    \t(url=\"http://localhost:3001\", description=\"Local host server for development\"),\n     \t//TODO add deployed production server URL\n    )\n)]\nstruct ApiDoc;\n\npub struct SecurityAddon;\n\nimpl Modify for SecurityAddon {\n\tfn modify(\u0026self, openapi: \u0026mut utoipa::openapi::OpenApi) {\n\t\tif let Some(components) = openapi.components.as_mut() {\n\t\t\tcomponents.add_security_scheme(\n                \"set-cookie\",\n                SecurityScheme::ApiKey(ApiKey::Cookie(ApiKeyValue::with_description(\n                \t\"auth-token\",\n                 \t\"An HTTP-only cookie which must encode a valid account id, expiration timestamp, and other information\"\n                ))),\n            )\n\t\t}\n\t}\n}\n\n/// Merges swagger with the current routes\npub fn merge_swagger(router: OpenApiRouter) -\u003e Router {\n\tlet doc = ApiDoc::openapi();\n\tlet docs_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"docs\");\n\tfs::create_dir_all(\u0026docs_path).unwrap();\n\tlet mut file = File::create(docs_path.join(\"openapi.json\")).unwrap();\n\tfile.write_all(doc.to_pretty_json().unwrap().as_bytes())\n\t\t.unwrap();\n\tlet (router, api) = OpenApiRouter::with_openapi(doc)\n\t\t.merge(router)\n\t\t.split_for_parts();\n\trouter.merge(SwaggerUi::new(\"/swagger\").url(\"/docs/openapi.json\", api.clone()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","tests.rs"],"content":"use crate::agent::configs::orchestrator::create_dummy_orchestrator_agent;\nuse crate::http_models::chat_session::ProgressRequest;\nuse crate::sql_models::LlmProgress;\nuse crate::{\n\tagent, controllers, db,\n\tglobal::*,\n\thttp_models::{\n\t\taccount::{LoginRequest, SignupRequest, UpdateRequest},\n\t\tchat_session::RenameRequest,\n\t\tevent::{SearchEventRequest, UserEventRequest, UserEventResponse},\n\t\titinerary::{Itinerary, UnsaveRequest},\n\t\tmessage::{MessagePageRequest, SendMessageRequest, UpdateMessageRequest},\n\t},\n\tlog,\n\tmiddleware::AuthUser,\n\tsql_models::{BudgetBucket, RiskTolerence},\n};\nuse argon2::{\n\tArgon2,\n\tpassword_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\nuse axum::{Extension, Json, Router};\nuse chrono::{NaiveDate, NaiveDateTime, Utc};\nuse serde_json::json;\nuse serial_test::serial;\nuse sqlx::{PgPool, migrate};\nuse std::{\n\tfs,\n\tio::Write,\n\tpath::Path,\n\ttime::{Duration, SystemTime},\n};\nuse tokio::net::TcpListener;\nuse tokio::sync::Mutex;\nuse tower_cookies::{\n\tCookie, CookieManagerLayer, Key,\n\tcookie::{CookieJar, SameSite, time},\n};\nuse tracing::{error, info, trace};\n\n// UNIT TESTS\n\n/// Test password verification logic\n#[test]\nfn test_password_verification() {\n\tlet password = \"test_password123\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hash the password\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify correct password\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// Verify incorrect password fails\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"wrong_password\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test token generation format\n#[test]\nfn test_token_generation() {\n\tlet user_id = 42;\n\tlet token = format!(\"user-{}.exp.sign\", user_id);\n\tassert_eq!(token, \"user-42.exp.sign\");\n\tassert!(token.starts_with(\"user-\"));\n\tassert!(token.ends_with(\".exp.sign\"));\n}\n\n/// Test cookie security settings\n#[test]\nfn test_cookie_security_development() {\n\tlet token_value = \"test-token-123\";\n\tlet on_production = false;\n\tlet domain = \"localhost\";\n\n\tlet cookie = Cookie::build((\"auth-token\", token_value))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.max_age(time::Duration::days(3))\n\t\t.build();\n\n\tassert_eq!(cookie.name(), \"auth-token\");\n\tassert_eq!(cookie.value(), token_value);\n\tassert_eq!(cookie.path(), Some(\"/\"));\n\tassert_eq!(cookie.http_only(), Some(true));\n\tassert_eq!(cookie.same_site(), Some(SameSite::Lax));\n\tassert!(!cookie.secure().unwrap_or(false));\n}\n\n/// Test cookie security settings for production\n#[test]\nfn test_cookie_security_production() {\n\tlet token_value = \"test-token-456\";\n\tlet on_production = true;\n\tlet domain = \"example.com\";\n\n\tlet cookie = Cookie::build((\"auth-token\", token_value))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.max_age(time::Duration::days(3))\n\t\t.build();\n\n\tassert_eq!(cookie.name(), \"auth-token\");\n\tassert_eq!(cookie.value(), token_value);\n\tassert_eq!(cookie.http_only(), Some(true));\n\tassert_eq!(cookie.same_site(), Some(SameSite::Strict));\n\tassert!(cookie.secure().unwrap_or(false));\n}\n\n/// Test password hashing for signup\n#[test]\nfn test_signup_password_hashing() {\n\tlet password = \"secure_password_123\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hash the password (as done in signup)\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify the hash is not the same as the plain password\n\tassert_ne!(password_hash, password);\n\n\t// Verify the hash starts with expected format\n\tassert!(password_hash.starts_with(\"$argon2\"));\n\n\t// Verify we can verify the password later (as in login)\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n}\n\n/// Test that different salts produce different hashes\n#[test]\nfn test_signup_different_salts() {\n\tlet password = \"same_password\";\n\tlet argon2 = Argon2::default();\n\n\t// Generate two hashes with different salts\n\tlet salt1 = SaltString::generate(\u0026mut OsRng);\n\tlet hash1 = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt1)\n\t\t.unwrap()\n\t\t.to_string();\n\n\tlet salt2 = SaltString::generate(\u0026mut OsRng);\n\tlet hash2 = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt2)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Hashes should be different due to different salts\n\tassert_ne!(hash1, hash2);\n\n\t// But both should verify the same password\n\tlet parsed_hash1 = PasswordHash::new(\u0026hash1).unwrap();\n\tlet parsed_hash2 = PasswordHash::new(\u0026hash2).unwrap();\n\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash1)\n\t\t\t.is_ok()\n\t);\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash2)\n\t\t\t.is_ok()\n\t);\n}\n\n/// Test that password hash cannot be reversed to plain text\n#[test]\nfn test_signup_hash_irreversibility() {\n\tlet password = \"my_secret_password_456\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Hash should not contain the plain password\n\tassert!(!password_hash.contains(password));\n\n\t// Hash should be significantly longer than input\n\tassert!(password_hash.len() \u003e password.len() * 2);\n}\n\n/// Test that any password can be hashed (even if it wouldn't pass validation)\n#[test]\nfn test_password_hashing_mechanism() {\n\t// Test that the hashing algorithm works with any input\n\tlet test_password = \"abc\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hashing mechanism should work regardless of validation rules\n\tlet result = argon2.hash_password(test_password.as_bytes(), \u0026salt);\n\tassert!(result.is_ok());\n\n\tlet password_hash = result.unwrap().to_string();\n\n\t// Verify the hash works\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(test_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// But wrong password should fail\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"wrong\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test password with special ASCII characters\n#[test]\nfn test_signup_special_characters_password() {\n\t// Only ASCII special characters are allowed\n\tlet special_password = \"Passw0rd!@#$%\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(special_password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify special characters are handled correctly\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(special_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// Wrong password should fail\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"Passw0rd!@#$\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test maximum allowed password length (128 chars)\n#[test]\nfn test_signup_max_password_length() {\n\t// 128 characters with required complexity\n\tlet max_password = \"A\".to_string() + \u0026\"a\".repeat(126) + \"1\";\n\tassert_eq!(max_password.len(), 128);\n\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(max_password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify max length password works\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(max_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n}\n\n#[test]\nfn test_validate_email() {\n\t// valid\n\tassert!(SignupRequest::validate_email(\"user@example.com\"));\n\tassert!(SignupRequest::validate_email(\"test.user@domain.co.uk\"));\n\tassert!(SignupRequest::validate_email(\"name+tag@company.org\"));\n\tassert!(SignupRequest::validate_email(\"user123@test-domain.com\"));\n\n\t// invalid\n\tassert!(!SignupRequest::validate_email(\"\"));\n\tassert!(!SignupRequest::validate_email(\"notanemail\"));\n\tassert!(!SignupRequest::validate_email(\"@example.com\"));\n\tassert!(!SignupRequest::validate_email(\"user@\"));\n\tassert!(!SignupRequest::validate_email(\"user@.com\"));\n\tassert!(!SignupRequest::validate_email(\"user @example.com\"));\n\tassert!(!SignupRequest::validate_email(\"user@exam ple.com\"));\n}\n\n#[test]\nfn test_validate_password() {\n\t// valid\n\tassert!(SignupRequest::validate_password(\"Password1\").is_ok());\n\tassert!(SignupRequest::validate_password(\"MySecure123\").is_ok());\n\tassert!(SignupRequest::validate_password(\"Passw0rd!@#\").is_ok());\n\tassert!(SignupRequest::validate_password(\"LongerPassword123\").is_ok());\n\n\t// too short\n\tlet result = SignupRequest::validate_password(\"Pass1\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must be at least 8 characters long\"\n\t);\n\n\t// no uppercase\n\tlet result = SignupRequest::validate_password(\"password123\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one uppercase letter\"\n\t);\n\n\t// no lowercase\n\tlet result = SignupRequest::validate_password(\"PASSWORD123\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one lowercase letter\"\n\t);\n\n\t// no number\n\tlet result = SignupRequest::validate_password(\"PasswordOnly\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one number\"\n\t);\n\n\t// too long\n\tlet password = \"A\".repeat(129) + \"1a\";\n\tlet result = SignupRequest::validate_password(\u0026password);\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must be 128 characters or less\"\n\t);\n\n\t// non ascii\n\tlet result = SignupRequest::validate_password(\"Password1パスワード\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain only ASCII characters\"\n\t);\n\n\t// emoji\n\tlet result = SignupRequest::validate_password(\"Password1🔒\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain only ASCII characters\"\n\t);\n\n\t// max length allowed\n\t// Test that exactly 128 characters is okay (with required chars)\n\tlet password = \"A\".to_string() + \u0026\"a\".repeat(126) + \"1\";\n\tassert_eq!(password.len(), 128);\n\tassert!(SignupRequest::validate_password(\u0026password).is_ok());\n}\n\n#[test]\nfn test_validate_signup_payload() {\n\t// valid\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tassert!(payload.validate().is_ok());\n\n\t// empty email\n\tlet payload = SignupRequest {\n\t\temail: \"\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Email is required\");\n\n\t// invalid email\n\tlet payload = SignupRequest {\n\t\temail: \"not-an-email\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Invalid email format\");\n\n\t// empty first name\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"First name is required\");\n\n\t// empty last name\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Last name is required\");\n\n\t// first name too long\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"a\".repeat(51),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"First name must be 50 characters or less\"\n\t);\n\n\t// last name too long\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"a\".repeat(51),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Last name must be 50 characters or less\"\n\t);\n\n\t// weak password\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"weak\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert!(result.unwrap_err().contains(\"Password\"));\n\n\t// whitespace trimming\n\tlet payload = SignupRequest {\n\t\temail: \"  test@example.com  \".to_string(),\n\t\tfirst_name: \"  John  \".to_string(),\n\t\tlast_name: \"  Doe  \".to_string(),\n\t\tpassword: \"Password123\".to_string(), // Valid ASCII password\n\t};\n\t// Email and names should be validated after trimming whitespace\n\tassert!(payload.validate().is_ok());\n}\n\n/// Verifies that `db::create_pool` panics when `DATABASE_URL` is not set.\n#[test]\n#[serial(db)]\nfn test_db_pool_panics_without_env() {\n\t// Save and clear DATABASE_URL\n\tlet prev = std::env::var(\"DATABASE_URL\").ok();\n\tunsafe {\n\t\tstd::env::remove_var(\"DATABASE_URL\");\n\t}\n\n\tlet result = std::panic::catch_unwind(|| {\n\t\tlet rt = tokio::runtime::Runtime::new().unwrap();\n\t\trt.block_on(async {\n\t\t\t// Should panic due to missing env var\n\t\t\tlet _ = db::create_pool().await;\n\t\t});\n\t});\n\n\t// Restore DATABASE_URL\n\tmatch prev {\n\t\tSome(val) =\u003e unsafe { std::env::set_var(\"DATABASE_URL\", val) },\n\t\tNone =\u003e unsafe { std::env::remove_var(\"DATABASE_URL\") },\n\t}\n\n\tassert!(result.is_err());\n}\n\n/// Optional integration test requiring a real database in `DATABASE_URL`.\n/// Run with: `cargo test -- --ignored`\n#[tokio::test]\n#[ignore]\n#[serial(db)]\nasync fn test_db_pool_connects_and_selects() {\n\tlet database_url = match std::env::var(\"DATABASE_URL\") {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e {\n\t\t\t// Not set in most environments; mark as success skip\n\t\t\tinfo!(\"DATABASE_URL not set; skipping real DB test\");\n\t\t\treturn;\n\t\t}\n\t};\n\n\t// Ensure env var is present for this test\n\tunsafe {\n\t\tstd::env::set_var(\"DATABASE_URL\", database_url);\n\t}\n\n\tlet pool = db::create_pool().await;\n\n\t// Simple liveness query\n\tlet row: (i32,) = sqlx::query_as(\"SELECT 1\")\n\t\t.fetch_one(\u0026pool)\n\t\t.await\n\t\t.expect(\"SELECT 1 should succeed\");\n\tassert_eq!(row.0, 1);\n}\n\n/// Verifies that `logs/latest.log` is created and written to from log events.\n#[test]\n#[serial(log)]\nfn test_logger() {\n\t//dotenv doesn't work in github actions bc .env is ignored\n\tunsafe {\n\t\t// Safety\n\t\t//\n\t\t// Always safe on Windows.\n\t\t//\n\t\t// Other platforms: risk of race condition in multi-threaded environment.\n\t\t// We are not reading/writing this environment variable from multiple threads, so we're good.\n\t\tstd::env::set_var(\"RUST_LOG\", \"warn,Capping2025=debug\");\n\t}\n\tlet latest_log_path = Path::new(LOG_DIR).join(LATEST_LOG);\n\tlog::init_logger();\n\ttrace!(\"Test trace\");\n\terror!(\"Test error\");\n\tlog::log_writer().flush().unwrap();\n\t//wait for IO to finish because flushing doesn't work?\n\tstd::thread::sleep(Duration::from_millis(10));\n\tlet logs = fs::read_to_string(latest_log_path).unwrap();\n\tinfo!(\"{logs}\");\n\tassert!(logs.len() \u003e 0);\n}\n\n/// Verifies that `logs/crash.log` is created and written to on a panic.\n#[test]\n#[serial(panic_log)]\nfn test_panic_handler() {\n\tlog::init_panic_handler();\n\tstd::panic::catch_unwind(|| {\n\t\tpanic!(\"Test panic\");\n\t})\n\t.unwrap_err();\n\tlet content = fs::read_to_string(Path::new(LOG_DIR).join(CRASH_LOG)).unwrap();\n\tassert!(content.len() \u003e 0);\n}\n\n/// It's easier to have all these in 1 test to share a db pool, and we don't have to spin up a server\n#[tokio::test]\n#[serial(db)]\nasync fn test_controllers() {\n\t_ = dotenvy::dotenv();\n\tlet cookies = CookieJar::new();\n\tlet key = Extension(Key::derive_from(\u0026[0u8; 32]));\n\tlet pool = Extension(db::create_pool().await);\n\n\t_ = tokio::join!(\n\t\ttest_signup_conflict_on_duplicate_email(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_http_login_invalid_credentials(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_current_endpoint_returns_account(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_returns_account(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_partial_fields(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_with_preferences(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_get_itinerary_id_not_found(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_invalid_signup_email(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_saved_itineraries_endpoint(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_save_itineraries(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_chat_flow(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_user_event_flow(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_itinerary_success(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_itinerary_not_found(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_already_unsaved_itinerary(cookies.clone(), key.clone(), pool.clone()),\n\t);\n}\n\nasync fn test_signup_conflict_on_duplicate_email(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"dupe+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Bob\"),\n\t\tlast_name: String::from(\"Dupe\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// First signup should succeed\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json.clone())\n\t\t.await\n\t\t.unwrap();\n\t// Second signup with same email should 409\n\tassert_eq!(\n\t\tcontrollers::account::api_signup(\u0026mut cookies, key, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t409\n\t);\n}\n\nasync fn test_http_login_invalid_credentials(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"badEmail+{}@example.com\", unique);\n\tlet json = Json(LoginRequest {\n\t\temail,\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// attempt to login with nonexistant email\n\tassert_eq!(\n\t\tcontrollers::account::api_login(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n\n\tlet email = format!(\"goodEmail+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail: email.clone(),\n\t\tfirst_name: String::from(\"Alice\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// signup\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet json = Json(LoginRequest {\n\t\temail,\n\t\tpassword: String::from(\"ChickenNugget1234\"),\n\t});\n\t// attempt to login with a correct email, but the wrong password\n\tassert_eq!(\n\t\tcontrollers::account::api_login(\u0026mut cookies, key, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n}\n\nasync fn test_current_endpoint_returns_account(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"current+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Current\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\t// Test /current endpoint returns Account struct\n\t_ = controllers::account::api_current(pool.clone(), user)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_returns_account(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"update+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Update\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with all fields\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: Some(format!(\"updated+{}@example.com\", unique)),\n\t\tfirst_name: Some(String::from(\"Updated\")),\n\t\tlast_name: Some(String::from(\"User\")),\n\t\tpassword: Some(String::from(\"NewPassword123\")),\n\t\tcurrent_password: Some(String::from(\"Password123\")),\n\t\tbudget_preference: Some(BudgetBucket::HighBudget),\n\t\trisk_preference: Some(RiskTolerence::Adventurer),\n\t\tfood_allergies: Some(String::from(\"Peanuts, shellfish\")),\n\t\tdisabilities: Some(String::from(\"Wheelchair accessible\")),\n\t\tprofile_picture: Some(String::from(\"base64-txt\")),\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_partial_fields(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"partial+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Partial\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with only some fields\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: None,\n\t\tfirst_name: Some(String::from(\"PartiallyUpdated\")),\n\t\tlast_name: None,\n\t\tpassword: None,\n\t\tcurrent_password: None,\n\t\tbudget_preference: None,\n\t\trisk_preference: None,\n\t\tfood_allergies: Some(String::from(\"Gluten\")),\n\t\tdisabilities: None,\n\t\tprofile_picture: None,\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_with_preferences(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"prefs+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Prefs\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with enum preferences\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: None,\n\t\tfirst_name: None,\n\t\tlast_name: None,\n\t\tpassword: None,\n\t\tcurrent_password: None,\n\t\tbudget_preference: Some(BudgetBucket::LuxuryBudget),\n\t\trisk_preference: Some(RiskTolerence::RiskTaker),\n\t\tfood_allergies: None,\n\t\tdisabilities: None,\n\t\tprofile_picture: None,\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_get_itinerary_id_not_found(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"get_itinerary+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Get\"),\n\t\tlast_name: String::from(\"Itinerary\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /{id} endpoint with non-existent itinerary (should return 404)\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_get_itinerary(user, axum::extract::Path(999999), pool.clone())\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n}\n\nasync fn test_invalid_signup_email(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"invalid_email_{}\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Get\"),\n\t\tlast_name: String::from(\"Event\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tassert_eq!(\n\t\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n}\n\nasync fn test_saved_itineraries_endpoint(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"saved_itineraries+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /saved endpoint returns user's itineraries\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\t_ = controllers::itinerary::api_saved_itineraries(user, pool)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_save_itineraries(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_save_itinerary_new+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// save itinerary with id not in db\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Updated Title\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\tassert_ne!(itinerary_id, 0);\n\n\t// save itinerary with a matching id already in db\n\tlet json = Json(Itinerary {\n\t\tid: itinerary_id,\n\t\tstart_date: NaiveDate::parse_from_str(\"2026-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2026-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"2nd Updated Title\"),\n\t});\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_save(user, pool, json)\n\t\t\t.await\n\t\t\t.unwrap()\n\t\t\t.id,\n\t\titinerary_id\n\t);\n}\n\nasync fn test_chat_flow(mut cookies: CookieJar, key: Extension\u003cKey\u003e, pool: Extension\u003cPgPool\u003e) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_latest_message_page+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Create agent for testing - use dummy agent if DEPLOY_LLM != \"1\"\n\n\t// Clone the pool\n\tlet pool = pool.0.clone();\n\n\t// Always use dummy agent for tests\n\tlet (agent_executor, chat_session_id_atomic, _user_id_atomic, context_store) =\n\t\tcreate_dummy_orchestrator_agent(pool.clone()).expect(\"Dummy agent creation failed\");\n\n\t// Wrap in Extension and Arc\u003cMutex\u003e as usual\n\tlet agent = Extension(std::sync::Arc::new(tokio::sync::Mutex::new(agent_executor)));\n\tlet chat_session_id_atomic_ext = Extension(chat_session_id_atomic);\n\tlet context_store_ext = Extension(context_store);\n\n\tlet pool_ext = Extension(pool.clone());\n\n\t// create new chat\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet first_chat_session_id = controllers::chat::api_new_chat(user, pool_ext)\n\t\t.await\n\t\t.unwrap()\n\t\t.chat_session_id;\n\tassert_ne!(first_chat_session_id, 0);\n\n\t// create chat session - reusing first one because it's empty\n\tlet chat_session_id = controllers::chat::api_new_chat(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap()\n\t\t.chat_session_id;\n\tassert_eq!(first_chat_session_id, chat_session_id);\n\n\t// send a bunch of messages\n\tlet mut message_ids = [0; MESSAGE_PAGE_LEN as usize + 5];\n\tfor i in 0..MESSAGE_PAGE_LEN as usize + 5 {\n\t\tlet json = Json(SendMessageRequest {\n\t\t\tchat_session_id,\n\t\t\ttext: format!(\"Test msg {}\", i),\n\t\t\titinerary_id: None,\n\t\t});\n\t\tmessage_ids[i] = controllers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson,\n\t\t)\n\t\t.await\n\t\t.unwrap()\n\t\t.user_message_id;\n\t\tassert_ne!(message_ids[i], 0);\n\t}\n\n\t// send empty message\n\tlet json = Json(SendMessageRequest {\n\t\tchat_session_id,\n\t\ttext: String::new(),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t400\n\t);\n\n\t// send message invalid chat session\n\tlet json = Json(SendMessageRequest {\n\t\tchat_session_id: 0,\n\t\ttext: String::from(\"Test msg invalid chat session id\"),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// get llm progress\n\tlet json = Json(ProgressRequest { chat_session_id });\n\tassert_eq!(\n\t\tcontrollers::chat::api_progress(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap()\n\t\t\t.0\n\t\t\t.progress,\n\t\tLlmProgress::Ready\n\t);\n\n\t// llm progress invalid chat session id\n\tlet json = Json(ProgressRequest {\n\t\tchat_session_id: -1,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_progress(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// get latest messages and make sure messages are in chronological order\n\tlet chat_session = controllers::chat::api_chats(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap();\n\tlet chat_session = chat_session.0.chat_sessions.first().unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tlatest_page\n\t\t\t.0\n\t\t\t.message_page\n\t\t\t.is_sorted_by(|a, b| a.timestamp \u003c b.timestamp)\n\t);\n\n\t// get specific messages and make sure messages are in chronological order\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: Some(latest_page.message_page[0].id),\n\t});\n\tlet next_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tnext_page\n\t\t\t.0\n\t\t\t.message_page\n\t\t\t.is_sorted_by(|a, b| a.timestamp \u003c b.timestamp)\n\t);\n\tassert_eq!(\n\t\tlatest_page.message_page[0].id,\n\t\tnext_page.message_page.last().unwrap().id\n\t);\n\n\t// get page with invalid message id\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: Some(0),\n\t});\n\tlet empty_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(empty_page.message_page.len(), 0);\n\tassert_eq!(empty_page.prev_message_id, None);\n\n\t// get page with invalid chat session id\n\n\t// update message with empty text\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: message_ids[0],\n\t\tnew_text: String::new(),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_update_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t400\n\t);\n\n\t// update message with invalid message id\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: 0,\n\t\tnew_text: String::from(\"Updated message\"),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_update_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// update message\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: message_ids[0],\n\t\tnew_text: String::from(\"Updated message\"),\n\t\titinerary_id: None,\n\t});\n\t_ = controllers::chat::api_update_message(\n\t\tuser,\n\t\tExtension(pool.clone()),\n\t\tagent.clone(),\n\t\tchat_session_id_atomic_ext.clone(),\n\t\tcontext_store_ext.clone(),\n\t\tjson,\n\t)\n\t.await\n\t.unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(latest_page.prev_message_id, None);\n\tassert_eq!(latest_page.message_page.len(), 2);\n\n\t//rename chat empty string\n\tlet json = Json(RenameRequest {\n\t\tnew_title: String::from(\"\"),\n\t\tid: chat_session.id,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_rename(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n\n\t//rename chat\n\tlet new_title = String::from(\"Updated Title\");\n\tlet json = Json(RenameRequest {\n\t\tnew_title: new_title.clone(),\n\t\tid: chat_session.id,\n\t});\n\tcontrollers::chat::api_rename(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tlet Json(chats) = controllers::chat::api_chats(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tchats\n\t\t\t.chat_sessions\n\t\t\t.iter()\n\t\t\t.any(move |chat| chat.id == chat_session.id \u0026\u0026 chat.title == new_title)\n\t);\n\n\t//delete chat session\n\tcontrollers::chat::api_delete_chat(\n\t\tuser,\n\t\tExtension(pool.clone()),\n\t\taxum::extract::Path(chat_session_id),\n\t)\n\t.await\n\t.unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(latest_page.prev_message_id, None);\n\tassert_eq!(latest_page.message_page.len(), 0);\n}\n\nasync fn test_user_event_flow(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_user_event_flow+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// create event\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet test = String::from(\"test\");\n\tlet description = String::from(\"Unit test event\");\n\tlet json = Json(UserEventRequest {\n\t\tid: None,\n\t\tevent_name: test.clone(),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\tevent_description: Some(description.clone()),\n\t\thard_start: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2025-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t\tphoto_name: None,\n\t});\n\tlet Json(UserEventResponse { id }) =\n\t\tcontrollers::itinerary::api_user_event(user, pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap();\n\n\t// update event\n\tlet update_str = String::from(\"test updated\");\n\tlet json = Json(UserEventRequest {\n\t\tid: Some(id),\n\t\tevent_name: update_str.clone(),\n\t\tevent_description: Some(description),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\thard_start: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2025-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t\tphoto_name: None,\n\t});\n\tlet Json(res) = controllers::itinerary::api_user_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(id, res.id);\n\n\t// search event\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\t..Default::default()\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(res.events.iter().any(|e| e.event_name == update_str));\n\n\t// comprehensive search\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\tevent_description: Some(test.clone()),\n\t\tevent_name: Some(test.clone()),\n\t\thard_start_before: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2020-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_start_after: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2010-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end_before: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2030-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end_after: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2020-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(res.events.iter().any(|e| e.event_name == update_str));\n\n\t// delete event\n\tcontrollers::itinerary::api_delete_user_event(user, pool.clone(), axum::extract::Path(id))\n\t\t.await\n\t\t.unwrap();\n\n\t// verify deletion\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\t..Default::default()\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool, json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(!res.events.iter().any(|e| e.event_name == update_str));\n}\n\n// INTEGRATION TESTS\n\nstatic mut PORT: u16 = 0;\n\n#[tokio::test]\n#[serial(db, log, panic_log)]\nasync fn test_endpoints() {\n\t// Only use dotenvy for local testing\n\t// CI testing should use GitHub environment variables\n\t_ = dotenvy::dotenv();\n\n\t// Initialize project logger once so test logs are written to logs/latest.log\n\t// Set a default log level for tests if not provided\n\tif std::env::var(\"RUST_LOG\").is_err() {\n\t\tunsafe { std::env::set_var(\"RUST_LOG\", \"debug\") };\n\t}\n\tlog::init_panic_handler();\n\tlog::init_logger();\n\n\tlet pool = db::create_pool().await;\n\tmatch migrate!().run(\u0026pool).await {\n\t\tOk(_) =\u003e (),\n\t\tErr(sqlx::migrate::MigrateError::VersionMismatch(_)) =\u003e {\n\t\t\teprintln!(\"migrations version mismatch; assuming DB already prepared. Skipping.\");\n\t\t}\n\t\tErr(e) =\u003e panic!(\"migrations run: {e}\"),\n\t}\n\n\t// Build app\n\t// Use an encryption/signing key for private cookies\n\tlet cookie_key = Key::generate();\n\n\t// Always use dummy agent for tests\n\tlet (agent_executor, chat_session_id_atomic, user_id_atomic, _context_store) =\n\t\tcreate_dummy_orchestrator_agent(pool.clone()).expect(\"Dummy agent creation failed\");\n\n\t// Wrap in Extension and Arc\u003cMutex\u003e for router layers\n\tlet agent_arc = std::sync::Arc::new(tokio::sync::Mutex::new(agent_executor));\n\n\tlet account_routes = controllers::account::account_routes();\n\tlet itinerary_routes = controllers::itinerary::itinerary_routes();\n\tlet chat_routes = controllers::chat::chat_routes();\n\tlet api_routes = Router::new()\n\t\t.nest(\"/account\", account_routes)\n\t\t.nest(\"/itinerary\", itinerary_routes)\n\t\t.nest(\"/chat\", chat_routes);\n\tlet app = Router::new()\n\t\t.nest(\"/api\", api_routes)\n\t\t.layer(Extension(pool.clone()))\n\t\t.layer(Extension(cookie_key.clone()))\n\t\t.layer(Extension(agent_arc.clone()))\n\t\t.layer(Extension(chat_session_id_atomic))\n\t\t.layer(CookieManagerLayer::new());\n\n\t// Bind to ephemeral port and spawn server\n\tlet listener = TcpListener::bind(\"127.0.0.1:0\")\n\t\t.await\n\t\t.expect(\"bind test server\");\n\tunsafe { PORT = listener.local_addr().unwrap().port() };\n\tlet server = axum::serve(listener, app.into_make_service()).into_future();\n\ttokio::spawn(server);\n\n\t// Any unit tests that test cookies or middleware, or any integration tests should go here.\n\t// Any other unit test should not go here. Instead, run it as a separate unit test and just invoke the controller directly.\n\ttokio::join!(\n\t\ttest_signup_and_login_happy_path(\u0026cookie_key),\n\t\ttest_auth_for_all_required(),\n\t\ttest_http_signup_and_login_flow(),\n\t\ttest_validate_with_bad_and_good_cookie(),\n\t\ttest_get_itinerary_invalid_format(),\n\t\ttest_signup_logout(),\n\t\ttest_cookie_exp_extended(),\n\t\t// just throw all the tests in here\n\t);\n}\n\nasync fn test_signup_and_login_happy_path(key: \u0026Key) {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"user+{}@example.com\", unique);\n\n\t// Signup\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Alice\",\n\t\t\t\t\"last_name\": \"Tester\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(resp.status().as_u16(), 200);\n\n\t// Login\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"user+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(resp.status().as_u16(), 200);\n\t// Extract cookie and decrypt via private jar\n\tlet set_cookie = resp.header(\"set-cookie\").unwrap();\n\t// Parse full Set-Cookie line (handles '=' inside value)\n\tlet parsed = Cookie::parse(set_cookie.to_string()).unwrap();\n\tlet mut jar = CookieJar::new();\n\tjar.add(parsed.clone());\n\tlet decrypted = jar.private(\u0026key).get(parsed.name()).unwrap();\n\t// token: user-\u003cid\u003e.\u003cexp\u003e.sign\n\tlet parts: Vec\u003c\u0026str\u003e = decrypted.value().split('.').collect();\n\tassert_eq!(parts.len(), 3);\n\tassert!(parts[0].starts_with(\"user-\"));\n\tassert_eq!(parts[2], \"sign\");\n\tlet exp: i64 = parts[1].parse().unwrap();\n\tlet now = chrono::Utc::now().timestamp();\n\tassert!(exp \u003e now);\n}\n\nasync fn test_auth_for_all_required() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\n\tlet account_update_payload = json!({});\n\tlet chat_message_page_payload = json!({\n\t\t\"chat_session_id\": 1,\n\t\t\"message_id\": 1\n\t});\n\tlet chat_update_message_payload = json!({\n\t\t\"message_id\": 1,\n\t\t\"new_text\": \"test\"\n\t});\n\tlet chat_send_message_payload = json!({\n\t\t\"chat_session_id\": 1,\n\t\t\"text\": \"test\"\n\t});\n\tlet chat_rename_payload = json!({\n\t\t\"new_title\": \"Updated Title\",\n\t\t\"id\": 1\n\t});\n\tlet chat_progress_payload = json!({\n\t\t\"chat_session_id\": 10\n\t});\n\tlet itinerary_save_payload = json!({\n\t\t\"id\": 1,\n\t\t\"start_date\": \"2025-11-05 00:00:00\",\n\t\t\"end_date\": \"2025-11-10 00:00:00\",\n\t\t\"morning_events\": [],\n\t\t\"noon_events\": [],\n\t\t\"afternoon_events\": [],\n\t\t\"evening_events\": []\n\t});\n\tlet itinerary_user_event_payload = json!({\n\t\t\"event_name\": \"Test Event\"\n\t});\n\tlet itinerary_search_event_payload = json!({\n\t\t\"event_description\": \"test\"\n\t});\n\n\tfor res in futures::future::join_all([\n\t\thc.do_get(\"/api/account/current\"),\n\t\thc.do_get(\"/api/account/validate\"),\n\t\thc.do_get(\"/api/account/logout\"),\n\t\thc.do_get(\"/api/chat/chats\"),\n\t\thc.do_get(\"/api/chat/newChat\"),\n\t\thc.do_get(\"/api/itinerary/saved\"),\n\t\thc.do_get(\"/api/itinerary/:id\"),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n\n\tfor res in futures::future::join_all([\n\t\thc.do_post(\"/api/account/update\", account_update_payload),\n\t\thc.do_post(\"/api/chat/messagePage\", chat_message_page_payload),\n\t\thc.do_post(\"/api/chat/updateMessage\", chat_update_message_payload),\n\t\thc.do_post(\"/api/chat/sendMessage\", chat_send_message_payload),\n\t\thc.do_post(\"/api/chat/rename\", chat_rename_payload),\n\t\thc.do_post(\"/api/chat/progress\", chat_progress_payload),\n\t\thc.do_post(\"/api/itinerary/save\", itinerary_save_payload),\n\t\thc.do_post(\"/api/itinerary/userEvent\", itinerary_user_event_payload),\n\t\thc.do_post(\"/api/itinerary/searchEvent\", itinerary_search_event_payload),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n\n\tfor res in futures::future::join_all([\n\t\thc.do_delete(\"/api/itinerary/userEvent/1\"),\n\t\thc.do_delete(\"/api/chat/1\"),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n}\n\nasync fn test_http_signup_and_login_flow() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"user+{}@example.com\", unique);\n\n\t// Signup\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Alice\",\n\t\t\t\t\"last_name\": \"Tester\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tresp.status().is_success(),\n\t\t\"signup failed: {}\",\n\t\tresp.status()\n\t);\n\n\t// Login\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"user+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tresp.status().is_success(),\n\t\t\"login failed: {}\",\n\t\tresp.status()\n\t);\n}\n\nasync fn test_validate_with_bad_and_good_cookie() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\t// No cookie (treated similarly to bad/invalid cookie): expect unauthorized\n\tlet resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tresp.status().as_u16(),\n\t\t401,\n\t\t\"Missing/invalid cookie should return 401\"\n\t);\n\n\t// Good cookie: create user and login to receive a valid private cookie, then validate\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"cookie+{}@example.com\", unique);\n\n\tlet signup = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Cook\",\n\t\t\t\t\"last_name\": \"Ie\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup.status().as_u16(), 200);\n\n\tlet login = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"cookie+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(login.status().as_u16(), 200);\n\n\t// Client should now hold the private cookie; call validate and expect 200\n\tlet resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tresp.status().as_u16(),\n\t\t200,\n\t\t\"/validate with good cookie should return 200\"\n\t);\n}\n\nasync fn test_get_itinerary_invalid_format() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"get_itinerary+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Itinerary\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\t// Test with invalid ID format (should return 400)\n\tlet invalid_resp = hc.do_get(\"/api/itinerary/invalid\").await.unwrap();\n\tassert_eq!(invalid_resp.status().as_u16(), 400);\n}\n\nasync fn test_signup_logout() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"login_then_logout+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Event\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\tlet cookie = signup_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003e SystemTime::now());\n\n\t// Test profile picture update WHILE LOGGED IN\n\tlet update_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/update\",\n\t\t\tjson!({\n\t\t\t\t\"profile_picture\": \"https://example.com/pic.jpg\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(update_resp.status().as_u16(), 200);\n\n\tlet body = update_resp.json_body().unwrap();\n\tassert_eq!(body[\"profile_picture\"], \"https://example.com/pic.jpg\");\n\n\t// NOW logout\n\tlet logout_resp = hc.do_get(\"/api/account/logout\").await.unwrap();\n\tassert_eq!(logout_resp.status().as_u16(), 200);\n\n\tlet cookie = logout_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003c SystemTime::now());\n\n\t// Hit any protected route - should be 401 now\n\tlet validate_res = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tvalidate_res.status().as_u16(),\n\t\t401,\n\t\t\"Missing/invalid cookie should return 401\"\n\t);\n}\n\nasync fn test_cookie_exp_extended() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_cookie_exp_extended+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Event\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\tlet cookie = signup_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003e SystemTime::now());\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003c SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(TEST_COOKIE_EXP_SECONDS as u64))\n\t\t\t\t.unwrap()\n\t);\n\n\t// Hit any protected route\n\tlet validate_resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(validate_resp.status().as_u16(), 200);\n\n\tlet cookie = validate_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003e SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(TEST_COOKIE_EXP_SECONDS as u64))\n\t\t\t\t.unwrap()\n\t);\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003c SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(3600))\n\t\t\t\t.unwrap()\n\t);\n}\n\nasync fn test_unsave_itinerary_success(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_success+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"Success\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// First, save an itinerary\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Test Itinerary to Unsave\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\tassert_ne!(itinerary_id, 0);\n\n\t// Now unsave it\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Verify it's no longer in saved itineraries\n\tlet saved = controllers::itinerary::api_saved_itineraries(user, pool)\n\t\t.await\n\t\t.unwrap();\n\tassert!(!saved.itineraries.iter().any(|i| i.id == itinerary_id));\n}\n\nasync fn test_unsave_itinerary_not_found(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_not_found+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"NotFound\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// Try to unsave a non-existent itinerary\n\tlet json = Json(UnsaveRequest { id: 999999 });\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_unsave(user, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n}\n\nasync fn test_unsave_already_unsaved_itinerary(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_already_unsaved+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"Already\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// Save an itinerary\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Test Itinerary\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\n\t// Unsave it once\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Try to unsave it again\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool, json)\n\t\t.await\n\t\t.unwrap();\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","constraint.rs"],"content":"/*\n * src/agent/configs/constraint.rs\n *\n * File for Constraint Agent Configuration\n *\n * Purpose:\n *   Store Constraint Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIConfig, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse crate::agent::tools::constraint::*;\nuse sqlx::PgPool;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_constraint_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Get tools - pass LLM as Arc\u003cdyn LLM\u003e and database pool\n\tlet llm_arc: Arc\u003cdyn langchain_rust::language_models::llm::LLM + Send + Sync\u003e =\n\t\tArc::new(llm.clone());\n\tlet tools = constraint_tools(llm_arc, pool);\n\n\t// Create agent with system prompt and tools\n\tconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/constraint.md\");\n\tlet system_prompt = SYSTEM_PROMPT.to_string();\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Limit to 3 iterations - agent should: 1) call tool, 2) get result, 3) return final answer\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_constraint_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Get tools - pass LLM as Arc\u003cdyn LLM\u003e and database pool\n\tlet llm_arc: Arc\u003cdyn langchain_rust::language_models::llm::LLM + Send + Sync\u003e =\n\t\tArc::new(llm.clone());\n\tlet tools = constraint_tools(llm_arc, pool);\n\n\t// Create agent with system prompt and tools\n\tconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/constraint.md\");\n\tlet system_prompt = SYSTEM_PROMPT.to_string();\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","example.rs"],"content":"/*\n * src/agent/config.rs\n *\n * File for Agent Configuration\n *\n * Purpose:\n *   Store Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n\t//tools:: \u003c- Some tools can be gotten from here\n};\n\nuse crate::agent::tools::GreetingTool;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Get tools\n\tlet greeting_tool = GreetingTool;\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Create agent with system prompt and tools\n\tlet system_prompt = format!(\n\t\t\"You are a helpful AI assistant for planning travel itineraries. \\\n\t\tYou help users create and manage their trip plans with a friendly and professional demeanor. \\\n\t\tAlways be concise, clear, and focus on providing practical travel planning advice. \\\n\t\t\\\n\t\tUser Info: \\\n\t\tName: {} \\\n\t\tLocation: {} \\\n\t\tPreferences: {} \\\n\t\tBudget: {} \\\n\t\tTravel Dates: {} \\\n\t\tTravel Type: {} \\\n\t\tTravel Style: {} \\\n\t\tTravel Budget: {} \\\n\t\",\n\t\t\"christian\",\n\t\t\"Philadelphia\",\n\t\t\"Adventurous\",\n\t\t\"Cheap\",\n\t\t\"August 1st - August 8th\",\n\t\t\"Vacation\",\n\t\t\"Adventurous\",\n\t\t\"Cheap\"\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026[Arc::new(greeting_tool)])\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Get tools\n\tlet greeting_tool = GreetingTool;\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Create agent with system prompt and tools\n\tlet system_prompt = \"You are a helpful AI assistant for planning travel itineraries.\";\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(system_prompt)\n\t\t.tools(\u0026[Arc::new(greeting_tool)])\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","mock.rs"],"content":"/*\n * src/agent/configs/mock.rs\n *\n * Mock LLM implementation for testing\n */\n\nuse async_trait::async_trait;\nuse futures::stream::{self, Stream};\nuse langchain_rust::language_models::GenerateResult;\nuse langchain_rust::language_models::LLMError;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::schemas::{Message, StreamData};\nuse serde_json::Value;\nuse std::pin::Pin;\n\n/// Mock LLM implementation for testing that returns dummy responses\n/// without making actual API calls\n#[derive(Clone)]\npub struct MockLLM;\n\n#[async_trait]\nimpl LLM for MockLLM {\n\tasync fn generate(\u0026self, _messages: \u0026[Message]) -\u003e Result\u003cGenerateResult, LLMError\u003e {\n\t\tOk(GenerateResult {\n\t\t\tgeneration: \"This is a mock response for testing.\".to_string(),\n\t\t\ttokens: None,\n\t\t})\n\t}\n\n\tasync fn stream(\n\t\t\u0026self,\n\t\t_messages: \u0026[Message],\n\t) -\u003e Result\u003cPin\u003cBox\u003cdyn Stream\u003cItem = Result\u003cStreamData, LLMError\u003e\u003e + Send\u003e\u003e, LLMError\u003e {\n\t\tlet response = StreamData::new(\n\t\t\tValue::String(\"This is a mock response for testing.\".to_string()),\n\t\t\tNone,\n\t\t\t\"This is a mock response for testing.\",\n\t\t);\n\t\tlet stream = stream::once(async move { Ok(response) });\n\t\tOk(Box::pin(stream))\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","mod.rs"],"content":"pub mod constraint;\npub mod mock;\npub mod optimizer;\npub mod orchestrator;\npub mod research;\npub mod task;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","optimizer.rs"],"content":"/*\n * src/agent/configs/optimizer.rs\n *\n * File for Optimizer Agent Configuration\n *\n * Purpose:\n *   Store Optimizer Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIConfig, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse crate::agent::tools::optimizer::optimizer_tools;\n\nuse sqlx::PgPool;\n\nconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/optimize.md\");\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_optimize_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tdb: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet agent_llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\t// Create agent\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026optimizer_tools(Arc::new(llm), db))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(agent_llm)\n\t\t.unwrap();\n\n\t// Limit to 3 iterations - agent should: 1) call tool, 2) get result, 3) return final answer\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_optimize_agent(\n\tllm: OpenAI\u003cOpenAIConfig\u003e,\n\tdb: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet agent_llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\t// Create agent\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026optimizer_tools(Arc::new(llm), db))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(agent_llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(3))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","orchestrator.rs"],"content":"/*\n * src/agent/configs/orchestrator.rs\n *\n * File for Orchestrator Agent Configuration\n */\n\nuse std::sync::Arc;\nuse std::sync::atomic::AtomicI32;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::configs::constraint::create_constraint_agent;\nuse crate::agent::configs::mock::MockLLM;\nuse crate::agent::configs::optimizer::create_optimize_agent;\nuse crate::agent::configs::research::create_research_agent;\nuse crate::agent::configs::task::create_task_agent;\nuse crate::agent::models::context::SharedContextStore;\nuse crate::agent::tools::orchestrator::get_orchestrator_tools;\nuse langchain_rust::language_models::llm::LLM;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\npub fn create_orchestrator_agent(\n\tpool: PgPool,\n) -\u003e Result\u003c\n\t(\n\t\tAgentExecutor\u003cConversationalAgent\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tSharedContextStore,\n\t),\n\tAgentError,\n\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Create a shared LLM instance for the orchestrator and its tools\n\t// Use MockLLM if DEPLOY_LLM != \"1\", otherwise use OpenAI\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tlet llm_for_subagents = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\tlet llm_for_tools: Arc\u003cdyn LLM + Send + Sync\u003e = if use_mock {\n\t\tArc::new(MockLLM)\n\t} else {\n\t\tArc::new(llm_for_subagents.clone())\n\t};\n\n\t// Create memory for conversation history\n\tlet memory = SimpleMemory::new();\n\n\t// Create shared atomics for chat_session_id and user_id (will be set per request)\n\tlet chat_session_id = Arc::new(AtomicI32::new(0));\n\tlet user_id = Arc::new(AtomicI32::new(0));\n\n\t// In-memory context store shared by orchestrator + sub-agents\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\t// Create research agent\n\tlet research_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_research_agent(pool.clone()).unwrap(),\n\t))));\n\n\t// Create constraint agent\n\tlet constraint_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_constraint_agent(llm_for_subagents.clone(), pool.clone()).unwrap(),\n\t))));\n\n\t// Create optimize agent\n\tlet optimize_agent = Arc::new(tokio::sync::Mutex::new(Arc::new(tokio::sync::Mutex::new(\n\t\tcreate_optimize_agent(llm_for_subagents.clone(), pool.clone()).unwrap(),\n\t))));\n\n\t// Create Task Agent (sub-agent used to build context and user profile)\n\tlet task_agent_executor = create_task_agent(\n\t\tpool.clone(),\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store.clone(),\n\t)?;\n\tlet task_agent_inner: AgentType = Arc::new(tokio::sync::Mutex::new(task_agent_executor));\n\tlet task_agent = Arc::new(tokio::sync::Mutex::new(task_agent_inner));\n\n\t// Get orchestrator tools\n\tlet tools = get_orchestrator_tools(\n\t\tllm_for_tools,\n\t\tpool.clone(),\n\t\ttask_agent,\n\t\tresearch_agent,\n\t\tconstraint_agent,\n\t\toptimize_agent,\n\t\tchat_session_id.clone(),\n\t\tuser_id.clone(),\n\t\tcontext_store.clone(),\n\t);\n\n\t// Create agent with system prompt and tools\n\tlet agent = if use_mock {\n\t\tlet mock_llm = MockLLM;\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(mock_llm)\n\t\t\t.unwrap()\n\t} else {\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(llm_for_subagents)\n\t\t\t.unwrap()\n\t};\n\n\t// Create executor with increased max iterations for complex multi-agent workflows\n\t// Default is 10, but we need more for orchestrator → sub-agent → tools chains\n\tOk((\n\t\tAgentExecutor::from_agent(agent)\n\t\t\t.with_memory(memory.into())\n\t\t\t.with_max_iterations(30),\n\t\tchat_session_id,\n\t\tuser_id,\n\t\tcontext_store,\n\t))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_orchestrator_agent(\n\tpool: PgPool,\n) -\u003e Result\u003c\n\t(\n\t\tAgentExecutor\u003cConversationalAgent\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tArc\u003cAtomicI32\u003e,\n\t\tSharedContextStore,\n\t),\n\tAgentError,\n\u003e {\n\t// Use MockLLM for testing to avoid API key requirements\n\tlet llm = MockLLM;\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\tlet llm_arc = Arc::new(llm.clone());\n\tlet chat_session_id = Arc::new(AtomicI32::new(0));\n\tlet user_id = Arc::new(AtomicI32::new(0));\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\t// Dummy sub-agents (including a dummy Task Agent) share the same simple implementation\n\tlet dummy_agent = Arc::new(tokio::sync::Mutex::new(create_dummy_sub_agent()?));\n\tlet task_agent = Arc::clone(\u0026dummy_agent);\n\tlet research_agent = Arc::clone(\u0026dummy_agent);\n\tlet constraint_agent = Arc::clone(\u0026dummy_agent);\n\tlet optimize_agent = Arc::clone(\u0026dummy_agent);\n\tlet tools = get_orchestrator_tools(\n\t\tllm_arc,\n\t\tpool,\n\t\tArc::new(tokio::sync::Mutex::new(task_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(research_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(constraint_agent)),\n\t\tArc::new(tokio::sync::Mutex::new(optimize_agent)),\n\t\tchat_session_id.clone(),\n\t\tuser_id.clone(),\n\t\tcontext_store.clone(),\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(ORCHESTRATOR_SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk((\n\t\tAgentExecutor::from_agent(agent).with_memory(memory.into()),\n\t\tchat_session_id,\n\t\tuser_id,\n\t\tcontext_store,\n\t))\n}\n\n#[cfg(test)]\nfn create_dummy_sub_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\tlet memory = SimpleMemory::new();\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(\"Dummy sub-agent\".to_string())\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// The system prompt for the Orchestrator Agent.\npub const ORCHESTRATOR_SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/orchestrator.md\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","research.rs"],"content":"/*\n * src/agent/configs/research.rs\n *\n * File for Research Agent Configuration\n *\n * Purpose:\n *   Store Research Agent Configuration\n */\n\nuse std::sync::Arc;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::tools::research::research_tools;\n\n// Use a type alias for the agent type to make it easier to use\npub type AgentType = Arc\u003c\n\ttokio::sync::Mutex\u003c\n\t\tlangchain_rust::agent::AgentExecutor\u003clangchain_rust::agent::ConversationalAgent\u003e,\n\t\u003e,\n\u003e;\n\nconst SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/research.md\");\n\npub fn create_research_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Note: Even when DEPLOY_LLM != \"1\", we still need to create an agent\n\t// (it won't be used at runtime). OpenAI API key is still required for agent creation.\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model (will read key from environment variable)\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026research_tools(pool))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// Creates a dummy agent for testing purposes.\n/// This agent will have an invalid API key and will panic if invoked,\n/// but when DEPLOY_LLM != \"1\", the agent is never invoked, so this is safe.\n/// This allows tests to run without requiring a valid OPENAI_API_KEY.\n#[cfg(test)]\npub fn create_dummy_research_agent(\n\tpool: PgPool,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\t// The agent won't actually be used when DEPLOY_LLM != \"1\"\n\tlet original_key = std::env::var(\"OPENAI_API_KEY\").ok();\n\n\t// Set a dummy API key temporarily so agent creation doesn't fail\n\tunsafe {\n\t\tstd::env::set_var(\"OPENAI_API_KEY\", \"sk-dummy-key-for-testing-only\");\n\t}\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Select model\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026research_tools(pool))\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\t// Restore original key if it existed\n\tunsafe {\n\t\tif let Some(key) = original_key {\n\t\t\tstd::env::set_var(\"OPENAI_API_KEY\", key);\n\t\t} else {\n\t\t\tstd::env::remove_var(\"OPENAI_API_KEY\");\n\t\t}\n\t}\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","configs","task.rs"],"content":"/*\n * src/agent/configs/task.rs\n *\n * File for Task Agent Configuration\n *\n * Purpose:\n *   Task Agent is a sub-agent used by the Orchestrator.\n *   Its sole responsibility is to gather and prepare context for planning:\n *   - Retrieve user profile \u0026 chat history\n *   - Parse user intent\n *   - Ask for clarification when needed\n *   - Persist this information into the shared chat context\n *\n * The Orchestrator Agent then uses this prepared context to route work\n * to the research / constraint / optimize agents.\n */\n\nuse std::sync::Arc;\nuse std::sync::atomic::AtomicI32;\n\nuse langchain_rust::{\n\tagent::{AgentError, AgentExecutor, ConversationalAgent, ConversationalAgentBuilder},\n\tchain::options::ChainCallOptions,\n\tllm::openai::{OpenAI, OpenAIModel},\n\tmemory::SimpleMemory,\n};\n\nuse sqlx::PgPool;\n\nuse crate::agent::configs::mock::MockLLM;\nuse crate::agent::models::context::SharedContextStore;\nuse crate::agent::tools::task::get_task_tools;\nuse langchain_rust::language_models::llm::LLM;\n\n/// Creates the Task Agent used as a sub-agent by the Orchestrator.\n///\n/// The Task Agent shares the same `chat_session_id` and `user_id` atomics\n/// as the Orchestrator so all tools operate on the same conversation context.\npub fn create_task_agent(\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Load environment variables\n\tdotenvy::dotenv().ok();\n\n\t// Use MockLLM when DEPLOY_LLM != \"1\" so local/dev can run without a real key\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tlet llm_for_agent = OpenAI::default().with_model(OpenAIModel::Gpt4oMini);\n\tlet llm_for_tools: Arc\u003cdyn LLM + Send + Sync\u003e = if use_mock {\n\t\tArc::new(MockLLM)\n\t} else {\n\t\tArc::new(llm_for_agent.clone())\n\t};\n\n\t// Create memory for conversation history\n\tlet memory = SimpleMemory::new();\n\n\t// Tools focused on context building (profile, chat history, intent, clarification, respond)\n\tlet tools = get_task_tools(\n\t\tllm_for_tools,\n\t\tpool,\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store,\n\t);\n\n\t// Create agent with system prompt and tools\n\tlet agent = if use_mock {\n\t\tlet mock_llm = MockLLM;\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(mock_llm)\n\t\t\t.unwrap()\n\t} else {\n\t\tConversationalAgentBuilder::new()\n\t\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t\t.tools(\u0026tools)\n\t\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t\t.build(llm_for_agent)\n\t\t\t.unwrap()\n\t};\n\n\tOk(AgentExecutor::from_agent(agent)\n\t\t.with_memory(memory.into())\n\t\t.with_max_iterations(20))\n}\n\n/// Creates a dummy Task Agent for testing purposes.\n///\n/// Mirrors the dummy orchestrator agent but uses the Task Agent system prompt.\n#[cfg(test)]\npub fn create_dummy_task_agent(\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n) -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\t// Use MockLLM for testing to avoid API key requirements\n\tlet llm = MockLLM;\n\n\t// Create memory\n\tlet memory = SimpleMemory::new();\n\n\t// Dummy sub-agents (all the same simple agent)\n\tlet llm_arc = Arc::new(llm.clone());\n\n\t// In-memory context store for tests\n\tlet context_store: SharedContextStore =\n\t\tArc::new(tokio::sync::RwLock::new(std::collections::HashMap::new()));\n\n\tlet tools = get_task_tools(\n\t\tllm_arc,\n\t\tpool,\n\t\tArc::clone(\u0026chat_session_id),\n\t\tArc::clone(\u0026user_id),\n\t\tcontext_store,\n\t);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(TASK_SYSTEM_PROMPT.to_string())\n\t\t.tools(\u0026tools)\n\t\t.options(ChainCallOptions::new().with_max_tokens(2000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n#[cfg(test)]\nfn create_dummy_sub_agent() -\u003e Result\u003cAgentExecutor\u003cConversationalAgent\u003e, AgentError\u003e {\n\tlet memory = SimpleMemory::new();\n\tlet llm = OpenAI::default().with_model(OpenAIModel::Gpt4Turbo);\n\n\tlet agent = ConversationalAgentBuilder::new()\n\t\t.prefix(\"Dummy sub-agent\".to_string())\n\t\t.options(ChainCallOptions::new().with_max_tokens(1000))\n\t\t.build(llm)\n\t\t.unwrap();\n\n\tOk(AgentExecutor::from_agent(agent).with_memory(memory.into()))\n}\n\n/// The system prompt for the Task Agent.\npub const TASK_SYSTEM_PROMPT: \u0026str = include_str!(\"../prompts/task.md\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","mod.rs"],"content":"pub mod configs;\npub mod models;\npub mod tools;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","context.rs"],"content":"/*\n   src/agent/models/context.rs\n   File for Agent Context Models\n   Purpose:\n\t   Store Agent Context Models\n\n*/\n\nuse crate::http_models::event::Event;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskRoute {\n\tpub task_type: String, // \"research\", \"constraint\", \"optimize\"\n\tpub payload: Value,\n}\n\n/// TripContext: Single source of truth for all trip details\n/// This object is progressively filled in as the user provides information\n/// Instead of re-parsing chat history, we update this object incrementally\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct TripContext {\n\tpub destination: Option\u003cString\u003e,\n\tpub start_date: Option\u003cString\u003e, // ISO 8601 date format (YYYY-MM-DD)\n\tpub end_date: Option\u003cString\u003e,   // ISO 8601 date format (YYYY-MM-DD)\n\tpub budget: Option\u003cf64\u003e,        // Total budget in USD\n\tpub preferences: Vec\u003cString\u003e,   // [\"cultural experiences\", \"beach time\"] - OPTIONAL\n\tpub constraints: Vec\u003cString\u003e,   // Dietary, accessibility, etc. - pre-filled from profile\n\tpub action: Option\u003cString\u003e,     // \"create\", \"modify\", \"view\", \"delete\"\n\tpub itinerary_id: Option\u003ci32\u003e,  // For modify/view/delete actions\n\tpub asked_clarification: bool,  // Track if we've asked user at least once\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolExecution {\n\tpub tool_name: String,\n\tpub timestamp: String, // ISO 8601 format\n\tpub input: Value,\n\tpub output: Value,\n\tpub success: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum PipelineStage {\n\tInitial,      // Just started, parsing user input\n\tResearching,  // Research agent gathering events\n\tConstraining, // Constraint agent validating events\n\tOptimizing,   // Optimizer agent ranking and scheduling\n\tValidating,   // Orchestrator validating final itinerary\n\tComplete,     // Pipeline complete, ready to display\n\tUserFeedback, // Waiting for or processing user feedback\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ContextData {\n\tpub chat_session_id: i32, // Chat session this context belongs to\n\tpub user_id: i32,         // User ID for this context\n\tpub user_profile: Option\u003cValue\u003e,\n\tpub chat_history: Vec\u003cValue\u003e,\n\tpub trip_context: TripContext, // Single source of truth for trip details\n\tpub active_itinerary: Option\u003cValue\u003e,\n\tpub events: Vec\u003cEvent\u003e, // Current running list of events being processed\n\tpub tool_history: Vec\u003cToolExecution\u003e,\n\tpub pipeline_stage: Option\u003cString\u003e, // Current stage in the pipeline\n\tpub researched_events: Vec\u003cEvent\u003e,  // Events from research agent\n\tpub constrained_events: Vec\u003cEvent\u003e, // Events validated by constraint agent\n\tpub optimized_events: Vec\u003cEvent\u003e,   // Events ranked/optimized by optimizer agent\n\tpub constraints: Vec\u003cString\u003e, // User constraints extracted from intent (dietary, accessibility, budget, etc.)\n}\n\n/// Shared in-memory store for per-chat ContextData.\n///\n/// Keyed by chat_session_id so all agents/tools in a conversation can\n/// read/write the same contextual state without round-tripping through\n/// the database on every tool call.\npub type SharedContextStore = Arc\u003cRwLock\u003cHashMap\u003ci32, ContextData\u003e\u003e\u003e;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PartialResult {\n\tpub agent: String,\n\tpub data: Value,\n\tpub success: bool,\n\tpub error: Option\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","event.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse serde::{Deserialize, Serialize};\n\nuse crate::sql_models::Period;\n\n/// A subset of [crate::http_models::event::Event] which only contains fields that the LLM might need for context.\n#[derive(Deserialize, Serialize)]\npub struct Event {\n\t/// Primary key\n\tpub id: i32,\n\tpub event_name: String,\n\tpub event_description: Option\u003cString\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","itinerary.rs"],"content":"/*\n\tsrc/agent/models/itinerary.rs\n\tFile for Agent Itinerary Models\n\tPurpose:\n\t\tStore Agent Itinerary Models\n\n*/\n/*\n * src/models/itinerary.rs\n *\n * File for Itinerary table models and related responses\n *\n * Purpose:\n *   Strongly-typed models for the `itineraries` response DTOs\n *   used by itinerary routes.\n */\n\nuse chrono::NaiveDate;\nuse serde::Deserialize;\n\n/// A complete itinerary with event details\n#[derive(Deserialize)]\npub struct Itinerary {\n\t/// Primary key\n\tpub id: i32,\n\t/// UTC date that the first event may take place (%Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// UTC date that the last event may take place (%Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// List of days containing events for that day\n\t/// * Days are guaranteed to be sorted in chronological order\n\tpub event_days: Vec\u003cEventDay\u003e,\n\t/// Possible associated chat session for easy editing on frontend\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Events that are not assigned to any specific time slot\n\tpub unassigned_events: Vec\u003cEvent\u003e,\n}\n\n/// A single day of events in an itinerary\n#[derive(Deserialize)]\npub struct EventDay {\n\t/// All the events taking place in the morning\n\tpub morning_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the afternoon\n\tpub afternoon_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the evening\n\tpub evening_events: Vec\u003cEvent\u003e,\n\t/// The date of this day within the range of itinerary start and end dates (Destination's local timezone - %Y-%m-%d)\n\tpub date: NaiveDate,\n}\n\n#[derive(Deserialize)]\npub struct Event {\n\tid: i32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","mod.rs"],"content":"pub mod context;\npub mod event;\npub mod itinerary;\npub mod user;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","models","user.rs"],"content":"/*\n\tsrc/agent/models/user.rs\n\tFile for Agent User Models\n\tPurpose:\n\t\tStore Agent User Models\n\n*/\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UserIntent {\n\tpub action: String, // \"create_itinerary\", \"modify\", \"query\"\n\tpub destination: Option\u003cString\u003e,\n\tpub start_date: Option\u003cString\u003e,\n\tpub end_date: Option\u003cString\u003e,\n\tpub budget: Option\u003cf64\u003e,\n\tpub preferences: Vec\u003cString\u003e,\n\tpub constraints: Vec\u003cString\u003e,\n\tpub missing_info: Vec\u003cString\u003e, // What information is still needed\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","constraint.rs"],"content":"/*\n * src/agent/tools/constraint.rs\n *\n * Constraint Agent tools.\n *\n * These tools are used by the Constraint Agent to filter research results\n * based on user constraints (e.g., wheelchair accessibility).\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::time::Instant;\nuse tracing::{debug, info};\n\nuse crate::http_models::event::Event;\n\n/// Uses an LLM to intelligently determine if an event should be included\n/// based on trip context, user preferences, and constraints\nasync fn should_include_event(\n\tllm: \u0026Arc\u003cdyn LLM + Send + Sync\u003e,\n\tevent: \u0026Event,\n\tpreferences: \u0026[String],\n\tconstraints: \u0026[String],\n) -\u003e Result\u003c(bool, Option\u003cString\u003e), Box\u003cdyn Error\u003e\u003e {\n\t// Serialize the event as JSON for the LLM to analyze\n\tlet event_json = serde_json::to_string_pretty(event)\n\t\t.unwrap_or_else(|_| format!(\"Event: {}\", event.event_name));\n\n\t// Create a prompt with all event details\n\tlet prompt = format!(\n\t\tr#\"You are evaluating whether a place/event is relevant for a vacation trip.\n\nTRIP CONTEXT:\n- User preferences: {}\n- User constraints: {}\n\nPLACE TO EVALUATE (all available data):\n{}\n\nRULES:\n1. ALWAYS EXCLUDE: schools, universities, hospitals, clinics, retail stores (Home Depot, Target, CVS, Staples), DMV, government offices, gas stations, banks\n2. INCLUDE places that match user preferences (e.g., if they want to \"eat a lot\", include restaurants, cafes, bars, wineries)\n3. INCLUDE potentially interesting vacation spots: parks, museums, theaters, attractions, hotels, landmarks\n4. For food preferences, only include actual dining establishments (restaurants, cafes, bars, bakeries, wineries) - NOT grocery stores\n5. If user requires wheelchair accessibility, check the wheelchair_accessible fields and EXCLUDE places that are not accessible\n\nShould this place be INCLUDED in the vacation itinerary?\nRespond with ONLY a JSON object in this exact format:\n{{\"include\": true/false, \"reason\": \"brief reason\"}}\"#,\n\t\tif preferences.is_empty() {\n\t\t\t\"none specified\".to_string()\n\t\t} else {\n\t\t\tpreferences.join(\", \")\n\t\t},\n\t\tif constraints.is_empty() {\n\t\t\t\"none\".to_string()\n\t\t} else {\n\t\t\tconstraints.join(\", \")\n\t\t},\n\t\tevent_json\n\t);\n\n\tlet response = llm.invoke(\u0026prompt).await?;\n\n\t// Parse the LLM response\n\tlet cleaned = response\n\t\t.trim()\n\t\t.trim_start_matches(\"```json\")\n\t\t.trim_end_matches(\"```\")\n\t\t.trim();\n\n\tmatch serde_json::from_str::\u003cValue\u003e(cleaned) {\n\t\tOk(parsed) =\u003e {\n\t\t\tlet include = parsed\n\t\t\t\t.get(\"include\")\n\t\t\t\t.and_then(|v| v.as_bool())\n\t\t\t\t.unwrap_or(false);\n\t\t\tlet reason = parsed\n\t\t\t\t.get(\"reason\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.map(|s| s.to_string());\n\t\t\tOk((include, reason))\n\t\t}\n\t\tErr(_) =\u003e {\n\t\t\t// If parsing fails, default to including the event\n\t\t\tdebug!(target: \"constraint_tools\", \"Failed to parse LLM response for event: {}, response: {}\", event.event_name, response);\n\t\t\tOk((\n\t\t\t\ttrue,\n\t\t\t\tSome(\"LLM response parsing failed, including by default\".to_string()),\n\t\t\t))\n\t\t}\n\t}\n}\n\n/// Tool that filters a list of event IDs based on user constraints.\n///\n/// Expected input (from the Orchestrator via `route_task` with `task_type = \"constraint\"`):\n///\n/// ```json\n/// {\n///   \"event_ids\": [1, 2, 3, ...], // array of event IDs from research agent\n///   \"constraints\": [\"No Tree Nuts\", \"No Peanuts\", \"Wheelchair accessible required: ...\"],\n///   \"trip_context\": { ... } // optional, for future use\n/// }\n/// ```\n///\n/// - If `constraints` is empty, this tool returns a natural-language question\n///   asking the user for constraints/preferences.\n/// - If constraints are present, it fetches the events from the database by ID,\n///   evaluates each with an LLM, and returns:\n///\n/// ```json\n/// {\n///   \"filtered_event_ids\": [1, 3, 5, ...],\n///   \"removed_events\": [ { \"event_id\": 2, \"event_name\": \"...\", \"reasons\": [\"...\"] } ]\n/// }\n/// ```\n#[derive(Clone)]\npub struct FilterEventsByConstraintsTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tdb: PgPool,\n}\n\nimpl FilterEventsByConstraintsTool {\n\tpub fn new(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Self {\n\t\tSelf { llm, db }\n\t}\n}\n\n#[async_trait]\nimpl Tool for FilterEventsByConstraintsTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"filter_events_by_constraints\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Filters a list of event IDs from the Research Agent using the user's constraints (e.g., wheelchair accessibility). IMPORTANT: Pass the entire JSON input you received (with event_ids, constraints, and trip_context) as the action_input. The tool will extract what it needs.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"input_data\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Pass the entire JSON input you received as a string. Do not pass empty string.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"constraint\",\n\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\"Starting constraint filtering\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Normalize input: langchain_rust passes `action_input` as a STRING.\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Extract event_ids array - handle both array and JSON string formats\n\t\tlet mut event_ids_val = parsed_input\n\t\t\t.get(\"event_ids\")\n\t\t\t.cloned()\n\t\t\t.or_else(|| {\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"events\")\n\t\t\t\t\t.and_then(|v| v.get(\"event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.or_else(|| {\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"data\")\n\t\t\t\t\t.and_then(|v| v.get(\"event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.unwrap_or(Value::Null);\n\n\t\t// If event_ids is a JSON string, parse it into an array\n\t\tif event_ids_val.is_string() {\n\t\t\tlet event_ids_str = event_ids_val.as_str().unwrap_or(\"[]\");\n\t\t\tevent_ids_val = serde_json::from_str(event_ids_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\t// Check if we already have a result (agent calling tool on previous output)\n\t\tif event_ids_val.is_null() \u0026\u0026 parsed_input.get(\"filtered_event_ids\").is_some() {\n\t\t\t// Agent is trying to call the tool on its own previous output\n\t\t\t// Just return that output directly\n\t\t\tinfo!(\n\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\t\"Tool called with previous output, returning it directly\"\n\t\t\t);\n\t\t\treturn Ok(serde_json::to_string(\u0026parsed_input)?);\n\t\t}\n\n\t\tlet event_ids: Vec\u003ci32\u003e = event_ids_val\n\t\t\t.as_array()\n\t\t\t.ok_or(\"event_ids should be an array of integers\")?\n\t\t\t.iter()\n\t\t\t.filter_map(|v| v.as_i64().map(|i| i as i32))\n\t\t\t.collect();\n\n\t\tif event_ids.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"constraint\",\n\t\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no event IDs provided\"\n\t\t\t);\n\t\t\treturn Err(\"No event IDs provided to constraint agent\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tevent_ids_count = event_ids.len(),\n\t\t\t\"Fetching events from database\"\n\t\t);\n\n\t\t// Fetch all events from database by their IDs\n\t\tlet rows = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT \n\t\t\t\tid,\n\t\t\t\tevent_name,\n\t\t\t\tevent_description,\n\t\t\t\tstreet_address,\n\t\t\t\tcity,\n\t\t\t\tcountry,\n\t\t\t\tpostal_code,\n\t\t\t\tlat,\n\t\t\t\tlng,\n\t\t\t\tevent_type,\n\t\t\t\tuser_created,\n\t\t\t\thard_start,\n\t\t\t\thard_end,\n\t\t\t\ttimezone,\n\t\t\t\tplace_id,\n\t\t\t\twheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food,\n\t\t\t\tprice_level,\n\t\t\t\tutc_offset_minutes,\n\t\t\t\twebsite_uri,\n\t\t\t\ttypes,\n\t\t\t\tphoto_name,\n\t\t\t\tphoto_width,\n\t\t\t\tphoto_height,\n\t\t\t\tphoto_author,\n\t\t\t\tphoto_author_uri,\n\t\t\t\tphoto_author_photo_uri,\n\t\t\t\tweekday_descriptions,\n\t\t\t\tsecondary_hours_type,\n\t\t\t\tnext_open_time,\n\t\t\t\tnext_close_time,\n\t\t\t\topen_now,\n\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\tspecial_days\n\t\t\tFROM events\n\t\t\tWHERE id = ANY($1)\n\t\t\t\"#,\n\t\t\t\u0026event_ids\n\t\t)\n\t\t.fetch_all(\u0026self.db)\n\t\t.await?;\n\n\t\t// Map rows to Event structs\n\t\tlet events: Vec\u003cEvent\u003e = rows\n\t\t\t.into_iter()\n\t\t\t.map(|row| Event {\n\t\t\t\tid: row.id,\n\t\t\t\tevent_name: row.event_name,\n\t\t\t\tevent_description: row.event_description,\n\t\t\t\tstreet_address: row.street_address,\n\t\t\t\tcity: row.city,\n\t\t\t\tcountry: row.country,\n\t\t\t\tpostal_code: row.postal_code,\n\t\t\t\tlat: row.lat,\n\t\t\t\tlng: row.lng,\n\t\t\t\tevent_type: row.event_type,\n\t\t\t\tuser_created: row.user_created,\n\t\t\t\thard_start: row.hard_start,\n\t\t\t\thard_end: row.hard_end,\n\t\t\t\ttimezone: row.timezone,\n\t\t\t\tplace_id: row.place_id,\n\t\t\t\twheelchair_accessible_parking: row.wheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance: row.wheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom: row.wheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating: row.wheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food: row.serves_vegetarian_food,\n\t\t\t\tprice_level: row.price_level,\n\t\t\t\tutc_offset_minutes: row.utc_offset_minutes,\n\t\t\t\twebsite_uri: row.website_uri,\n\t\t\t\ttypes: row.types,\n\t\t\t\tphoto_name: row.photo_name,\n\t\t\t\tphoto_width: row.photo_width,\n\t\t\t\tphoto_height: row.photo_height,\n\t\t\t\tphoto_author: row.photo_author,\n\t\t\t\tphoto_author_uri: row.photo_author_uri,\n\t\t\t\tphoto_author_photo_uri: row.photo_author_photo_uri,\n\t\t\t\tweekday_descriptions: row.weekday_descriptions,\n\t\t\t\tsecondary_hours_type: row.secondary_hours_type,\n\t\t\t\tnext_open_time: row.next_open_time,\n\t\t\t\tnext_close_time: row.next_close_time,\n\t\t\t\topen_now: row.open_now,\n\t\t\t\tperiods: row.periods,\n\t\t\t\tspecial_days: row.special_days,\n\t\t\t\tblock_index: None, // Not used in constraint filtering\n\t\t\t})\n\t\t\t.collect();\n\n\t\tif events.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"constraint\",\n\t\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no events found in database for provided IDs\"\n\t\t\t);\n\t\t\treturn Err(\"No events found in database for the provided IDs\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tevents_fetched = events.len(),\n\t\t\t\"Events fetched successfully\"\n\t\t);\n\n\t\t// Extract constraints (strings, lowercased for matching)\n\t\tlet mut constraints_val = if parsed_input.get(\"constraints\").is_some() {\n\t\t\tparsed_input\n\t\t\t\t.get(\"constraints\")\n\t\t\t\t.cloned()\n\t\t\t\t.unwrap_or(Value::Null)\n\t\t} else {\n\t\t\tparsed_input\n\t\t\t\t.get(\"trip_context\")\n\t\t\t\t.and_then(|tc| tc.get(\"constraints\"))\n\t\t\t\t.cloned()\n\t\t\t\t.unwrap_or(Value::Null)\n\t\t};\n\n\t\t// If constraints is a JSON string, parse it into an array\n\t\tif constraints_val.is_string() {\n\t\t\tlet constraints_str = constraints_val.as_str().unwrap_or(\"[]\");\n\t\t\tconstraints_val = serde_json::from_str(constraints_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\tlet constraints: Vec\u003cString\u003e = if let Some(arr) = constraints_val.as_array() {\n\t\t\tarr.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_lowercase()))\n\t\t\t\t.collect()\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\n\t\t// Extract preferences from trip_context\n\t\tlet preferences: Vec\u003cString\u003e = parsed_input\n\t\t\t.get(\"trip_context\")\n\t\t\t.and_then(|tc| tc.get(\"preferences\"))\n\t\t\t.and_then(|p| p.as_array())\n\t\t\t.map(|arr| {\n\t\t\t\tarr.iter()\n\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_lowercase()))\n\t\t\t\t\t.collect()\n\t\t\t})\n\t\t\t.unwrap_or_else(Vec::new);\n\n\t\t// Constraints are optional - if none exist, we proceed with no filtering\n\t\t// The task agent should have already asked for clarification if critical info was missing\n\t\tif constraints.is_empty() {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\t\"No constraints provided - will include all events\"\n\t\t\t);\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\tpreferences = ?preferences,\n\t\t\tconstraints = ?constraints,\n\t\t\tevents_count = events.len(),\n\t\t\t\"Processing events with LLM-based filtering\"\n\t\t);\n\n\t\tlet mut filtered_ids: Vec\u003ci32\u003e = Vec::new();\n\t\tlet mut removed: Vec\u003cValue\u003e = Vec::new();\n\n\t\t// Process each event with LLM evaluation\n\t\tfor event in events.iter() {\n\t\t\t// Use LLM to evaluate if event should be included\n\t\t\tmatch should_include_event(\u0026self.llm, event, \u0026preferences, \u0026constraints).await {\n\t\t\t\tOk((should_include, reason)) =\u003e {\n\t\t\t\t\tif should_include {\n\t\t\t\t\t\tfiltered_ids.push(event.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet reason_text =\n\t\t\t\t\t\t\treason.unwrap_or_else(|| \"not relevant for trip\".to_string());\n\t\t\t\t\t\tremoved.push(json!({\n\t\t\t\t\t\t\t\"event_id\": event.id,\n\t\t\t\t\t\t\t\"event_name\": \u0026event.event_name,\n\t\t\t\t\t\t\t\"reasons\": [reason_text],\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"constraint_tools\",\n\t\t\t\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\t\t\t\terror = %e,\n\t\t\t\t\t\tevent_name = %event.event_name,\n\t\t\t\t\t\t\"LLM evaluation failed, including event by default\"\n\t\t\t\t\t);\n\t\t\t\t\t// On error, include the event by default to avoid over-filtering\n\t\t\t\t\tfiltered_ids.push(event.id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet result = json!({\n\t\t\t\"filtered_event_ids\": filtered_ids,\n\t\t\t\"removed_events\": removed,\n\t\t\t\"count\": filtered_ids.len()\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\t// Extract event names for debugging\n\t\tlet filtered_names: Vec\u003cString\u003e = events\n\t\t\t.iter()\n\t\t\t.filter(|e| filtered_ids.contains(\u0026e.id))\n\t\t\t.map(|e| e.event_name.clone())\n\t\t\t.collect();\n\n\t\tlet removed_names: Vec\u003cString\u003e = result[\"removed_events\"]\n\t\t\t.as_array()\n\t\t\t.map(|arr| {\n\t\t\t\tarr.iter()\n\t\t\t\t\t.filter_map(|e| {\n\t\t\t\t\t\te.get(\"event_name\")\n\t\t\t\t\t\t\t.and_then(|n| n.as_str())\n\t\t\t\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t\t})\n\t\t\t\t\t.collect()\n\t\t\t})\n\t\t\t.unwrap_or_default();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"constraint\",\n\t\t\ttool: \"filter_events_by_constraints\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\n\t\t\t\t\"elapsed_ms={}, filtered_count={}, removed_count={}, filtered=[{}], removed=[{}]\",\n\t\t\t\telapsed.as_millis(),\n\t\t\t\tfiltered_ids.len(),\n\t\t\t\tremoved.len(),\n\t\t\t\tfiltered_names.join(\", \"),\n\t\t\t\tremoved_names.join(\", \")\n\t\t\t)\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"constraint_tools\",\n\t\t\ttool = \"filter_events_by_constraints\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tfiltered_count = filtered_ids.len(),\n\t\t\tremoved_count = removed.len(),\n\t\t\t\"Constraint filtering completed\"\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n\npub fn constraint_tools(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![Arc::new(FilterEventsByConstraintsTool::new(llm, db))]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","example.rs"],"content":"/*\n * src/agent/example.rs\n *\n * File for Agent Tools\n *\n * Purpose:\n *   Store Agent Tools\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse std::error::Error;\n\n/// Example tool that returns a greeting message\n///\n/// This tool accepts a name as input and generates a friendly greeting.\n/// It implements the Tool trait from langchain-rust to be used by AI agents.\n#[derive(Clone)]\npub struct GreetingTool;\n\n#[async_trait]\nimpl Tool for GreetingTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"greeting_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that generates a friendly greeting message. Use this when you need to greet the user or create a welcoming message.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"name\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The name of the person to greet\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"name\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet name = input[\"name\"].as_str().ok_or(\"Name should be a string\")?;\n\n\t\tOk(format!(\"Hello, {}! Welcome to our AI assistant.\", name))\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","mod.rs"],"content":"pub mod constraint;\npub mod optimizer;\npub mod orchestrator;\npub mod research;\npub mod task;\npub mod tsp;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","optimizer.rs"],"content":"/*\n * src/agent/tools/optimizer.rs\n *\n * File for Optimizer Agent Tools\n *\n * Purpose:\n *   Store Optimizer Agent Tools for itinerary optimization\n */\n\nuse async_trait::async_trait;\nuse langchain_rust::{language_models::llm::LLM, tools::Tool};\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::{error::Error, sync::Arc, time::Instant};\nuse tracing::{debug, info, warn};\n\nuse crate::agent::models::event::Event;\n\npub fn optimizer_tools(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![Arc::new(OptimizeItineraryTool::new(\n\t\tllm.clone(),\n\t\tdb.clone(),\n\t))]\n}\n\n/// Main tool that orchestrates the full optimization workflow.\n/// This tool:\n/// 1. Accepts filtered event IDs from the constraint agent\n/// 2. Fetches events from the database\n/// 3. Retrieves user profile from context\n/// 4. Ranks POIs by preference\n/// 5. Drafts an itinerary\n/// 6. Optimizes routes for each day\n/// 7. Returns a complete structured itinerary\n#[derive(Clone)]\nstruct OptimizeItineraryTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tdb: PgPool,\n}\n\nimpl OptimizeItineraryTool {\n\tpub fn new(llm: Arc\u003cdyn LLM + Send + Sync\u003e, db: PgPool) -\u003e Self {\n\t\tSelf { llm, db }\n\t}\n}\n\n#[async_trait]\nimpl Tool for OptimizeItineraryTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"optimize_itinerary\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Main optimization workflow tool. IMPORTANT: Pass the entire JSON input you received (with filtered_event_ids, trip_context, and user_profile) as the action_input. Fetches events from database, ranks them by user preference, drafts an itinerary, and optimizes routes. Returns a complete structured itinerary ready for storage.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"input_data\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Pass the entire JSON input you received as a string. Do not pass empty string.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_itinerary\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"optimize_itinerary\",\n\t\t\t\"Starting itinerary optimization workflow\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Parse input (handle both string and object formats from langchain_rust)\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Extract and parse filtered_event_ids\n\t\tlet mut event_ids_val = parsed_input\n\t\t\t.get(\"filtered_event_ids\")\n\t\t\t.cloned()\n\t\t\t.or_else(|| {\n\t\t\t\t// Try alternative paths from orchestrator payload\n\t\t\t\tparsed_input\n\t\t\t\t\t.get(\"events\")\n\t\t\t\t\t.and_then(|v| v.get(\"filtered_event_ids\"))\n\t\t\t\t\t.cloned()\n\t\t\t})\n\t\t\t.unwrap_or(Value::Null);\n\n\t\t// If event_ids is a JSON string, parse it\n\t\tif event_ids_val.is_string() {\n\t\t\tlet event_ids_str = event_ids_val.as_str().unwrap_or(\"[]\");\n\t\t\tevent_ids_val = serde_json::from_str(event_ids_str).unwrap_or(Value::Null);\n\t\t}\n\n\t\t// Check if we already have a result (agent calling tool on previous output)\n\t\tif event_ids_val.is_null() \u0026\u0026 parsed_input.get(\"event_days\").is_some() {\n\t\t\t// Agent is trying to call the tool on its own previous output (an itinerary)\n\t\t\t// Just return that output directly\n\t\t\tinfo!(\n\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\"Tool called with previous output, returning it directly\"\n\t\t\t);\n\t\t\treturn Ok(serde_json::to_string(\u0026parsed_input)?);\n\t\t}\n\n\t\tlet event_ids: Vec\u003ci32\u003e = event_ids_val\n\t\t\t.as_array()\n\t\t\t.ok_or(\"filtered_event_ids should be an array of integers\")?\n\t\t\t.iter()\n\t\t\t.filter_map(|v| v.as_i64().map(|i| i as i32))\n\t\t\t.collect();\n\n\t\tif event_ids.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"optimize\",\n\t\t\t\ttool: \"optimize_itinerary\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no event IDs provided\"\n\t\t\t);\n\t\t\treturn Err(\"No event IDs provided to optimize agent\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tevent_count = event_ids.len(),\n\t\t\t\"Fetching events from database\"\n\t\t);\n\n\t\t// Fetch all events from database\n\t\tlet rows = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tid,\n\t\t\t\tevent_name,\n\t\t\t\tevent_description,\n\t\t\t\tstreet_address,\n\t\t\t\tcity,\n\t\t\t\tcountry,\n\t\t\t\tpostal_code,\n\t\t\t\tlat,\n\t\t\t\tlng,\n\t\t\t\tevent_type,\n\t\t\t\thard_start,\n\t\t\t\thard_end,\n\t\t\t\ttimezone,\n\t\t\t\twheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food,\n\t\t\t\tprice_level,\n\t\t\t\tutc_offset_minutes,\n\t\t\t\ttypes,\n\t\t\t\tweekday_descriptions,\n\t\t\t\tsecondary_hours_type,\n\t\t\t\tnext_open_time,\n\t\t\t\tnext_close_time,\n\t\t\t\topen_now,\n\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\tspecial_days\n\t\t\tFROM events\n\t\t\tWHERE id = ANY($1)\n\t\t\t\"#,\n\t\t\t\u0026event_ids\n\t\t)\n\t\t.fetch_all(\u0026self.db)\n\t\t.await?;\n\n\t\tlet events: Vec\u003cEvent\u003e = rows\n\t\t\t.into_iter()\n\t\t\t.map(|row| Event {\n\t\t\t\tid: row.id,\n\t\t\t\tevent_name: row.event_name,\n\t\t\t\tevent_description: row.event_description,\n\t\t\t\tstreet_address: row.street_address,\n\t\t\t\tcity: row.city,\n\t\t\t\tcountry: row.country,\n\t\t\t\tpostal_code: row.postal_code,\n\t\t\t\tlat: row.lat,\n\t\t\t\tlng: row.lng,\n\t\t\t\tevent_type: row.event_type,\n\t\t\t\thard_start: row.hard_start,\n\t\t\t\thard_end: row.hard_end,\n\t\t\t\ttimezone: row.timezone,\n\t\t\t\twheelchair_accessible_parking: row.wheelchair_accessible_parking,\n\t\t\t\twheelchair_accessible_entrance: row.wheelchair_accessible_entrance,\n\t\t\t\twheelchair_accessible_restroom: row.wheelchair_accessible_restroom,\n\t\t\t\twheelchair_accessible_seating: row.wheelchair_accessible_seating,\n\t\t\t\tserves_vegetarian_food: row.serves_vegetarian_food,\n\t\t\t\tprice_level: row.price_level,\n\t\t\t\tutc_offset_minutes: row.utc_offset_minutes,\n\t\t\t\ttypes: row.types,\n\t\t\t\tweekday_descriptions: row.weekday_descriptions,\n\t\t\t\tsecondary_hours_type: row.secondary_hours_type,\n\t\t\t\tnext_open_time: row.next_open_time,\n\t\t\t\tnext_close_time: row.next_close_time,\n\t\t\t\topen_now: row.open_now,\n\t\t\t\tperiods: row.periods,\n\t\t\t\tspecial_days: row.special_days,\n\t\t\t\tblock_index: None,\n\t\t\t})\n\t\t\t.collect();\n\n\t\tif events.is_empty() {\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"optimize\",\n\t\t\t\ttool: \"optimize_itinerary\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: \"no events found in database\"\n\t\t\t);\n\t\t\treturn Err(\"No events found in database for provided IDs\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tevents_fetched = events.len(),\n\t\t\t\"Events fetched successfully\"\n\t\t);\n\n\t\t// Extract trip_context and user_profile\n\t\tlet mut trip_context_val = parsed_input\n\t\t\t.get(\"trip_context\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\tif trip_context_val.is_string() {\n\t\t\ttrip_context_val = serde_json::from_str(trip_context_val.as_str().unwrap_or(\"{}\"))\n\t\t\t\t.unwrap_or(json!({}));\n\t\t}\n\n\t\tlet mut user_profile_val = parsed_input\n\t\t\t.get(\"user_profile\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\tif user_profile_val.is_string() {\n\t\t\tuser_profile_val = serde_json::from_str(user_profile_val.as_str().unwrap_or(\"{}\"))\n\t\t\t\t.unwrap_or(json!({}));\n\t\t}\n\n\t\t// STEP 1: Rank POIs by preference\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 1: Ranking POIs by user preference\"\n\t\t);\n\n\t\tlet events_json = serde_json::to_value(\u0026events)?;\n\t\tlet rank_input = json!({\n\t\t\t\"pois\": events_json,\n\t\t\t\"user_profile\": user_profile_val\n\t\t});\n\n\t\tlet rank_tool = RankPOIsByPreferenceTool {\n\t\t\tllm: self.llm.clone(),\n\t\t};\n\t\tlet ranked_result = rank_tool.run(rank_input).await?;\n\n\t\t// Parse the ranked POIs (should be JSON array with rank fields added)\n\t\t// Try to extract JSON from markdown code blocks if present\n\t\tlet cleaned_result = ranked_result\n\t\t\t.trim()\n\t\t\t.strip_prefix(\"```json\")\n\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t.or_else(|| {\n\t\t\t\tranked_result\n\t\t\t\t\t.trim()\n\t\t\t\t\t.strip_prefix(\"```\")\n\t\t\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t})\n\t\t\t.unwrap_or(ranked_result.trim());\n\n\t\tlet mut ranked_pois: Vec\u003cValue\u003e = serde_json::from_str(cleaned_result)\n\t\t\t.map_err(|e| {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\terror = %e,\n\t\t\t\t\tresponse = %ranked_result,\n\t\t\t\t\t\"Failed to parse ranked POIs, adding default ranks\"\n\t\t\t\t);\n\t\t\t\te\n\t\t\t})\n\t\t\t.unwrap_or_else(|_| {\n\t\t\t\t// Fallback: use original events and add default ranks\n\t\t\t\tevents_json.as_array().cloned().unwrap_or_default()\n\t\t\t});\n\n\t\t// Ensure all POIs have a rank field (add default if missing)\n\t\tfor poi in ranked_pois.iter_mut() {\n\t\t\tif poi.get(\"rank\").is_none() {\n\t\t\t\t// Add a high default rank for POIs missing the rank field\n\t\t\t\tif let Some(obj) = poi.as_object_mut() {\n\t\t\t\t\tobj.insert(\"rank\".to_string(), json!(999));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Sort by rank to ensure best POIs come first\n\t\tranked_pois.sort_by(|a, b| {\n\t\t\tlet rank_a = a.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\tlet rank_b = b.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\trank_a.cmp(\u0026rank_b)\n\t\t});\n\n\t\t// Extract ranking summary for logging\n\t\tlet mut rankings: Vec\u003cString\u003e = ranked_pois\n\t\t\t.iter()\n\t\t\t.map(|poi| {\n\t\t\t\tlet name = poi\n\t\t\t\t\t.get(\"event_name\")\n\t\t\t\t\t.and_then(|n| n.as_str())\n\t\t\t\t\t.unwrap_or(\"Unknown\");\n\t\t\t\tlet rank = poi.get(\"rank\").and_then(|r| r.as_i64()).unwrap_or(999);\n\t\t\t\tformat!(\"{}(rank:{})\", name, rank)\n\t\t\t})\n\t\t\t.collect();\n\t\trankings.sort_by_key(|s| {\n\t\t\t// Extract rank number for sorting\n\t\t\ts.split(\"rank:\")\n\t\t\t\t.nth(1)\n\t\t\t\t.and_then(|r| r.trim_end_matches(')').parse::\u003ci64\u003e().ok())\n\t\t\t\t.unwrap_or(999)\n\t\t});\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tranked_count = ranked_pois.len(),\n\t\t\t\"POIs ranked successfully\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"rankings=[{}]\", rankings.join(\", \"))\n\t\t);\n\n\t\t// STEP 2: Draft the itinerary\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 2: Drafting itinerary structure\"\n\t\t);\n\n\t\tlet draft_input = json!({\n\t\t\t\"pois\": ranked_pois,\n\t\t\t\"diversity_factor\": 0.7,\n\t\t\t\"trip_context\": trip_context_val\n\t\t});\n\n\t\tlet draft_tool = DraftItineraryTool {\n\t\t\tllm: self.llm.clone(),\n\t\t};\n\t\tlet draft_result = draft_tool.run(draft_input).await?;\n\n\t\t// Parse the draft itinerary\n\t\t// Try to extract JSON from markdown code blocks if present\n\t\tlet cleaned_draft = draft_result\n\t\t\t.trim()\n\t\t\t.strip_prefix(\"```json\")\n\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t.or_else(|| {\n\t\t\t\tdraft_result\n\t\t\t\t\t.trim()\n\t\t\t\t\t.strip_prefix(\"```\")\n\t\t\t\t\t.and_then(|s| s.strip_suffix(\"```\"))\n\t\t\t})\n\t\t\t.unwrap_or(draft_result.trim());\n\n\t\t// Try standard JSON parsing first\n\t\tlet mut itinerary: Value = match serde_json::from_str(cleaned_draft) {\n\t\t\tOk(value) =\u003e value,\n\t\t\tErr(e) =\u003e {\n\t\t\t\twarn!(\n\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\terror = %e,\n\t\t\t\t\tresponse_len = draft_result.len(),\n\t\t\t\t\t\"Failed to parse draft itinerary with standard JSON parser, trying JSON5\"\n\t\t\t\t);\n\n\t\t\t\t// Try JSON5 parser which is more lenient (handles trailing commas, comments, etc.)\n\t\t\t\tmatch json5::from_str(cleaned_draft) {\n\t\t\t\t\tOk(value) =\u003e {\n\t\t\t\t\t\tinfo!(\n\t\t\t\t\t\t\ttarget: \"optimize_tools\",\n\t\t\t\t\t\t\t\"Successfully parsed draft itinerary using JSON5 (lenient parser)\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t\tErr(json5_err) =\u003e {\n\t\t\t\t\t\t// Both parsers failed - log detailed error and return error\n\t\t\t\t\t\tlet preview = draft_result.chars().take(500).collect::\u003cString\u003e();\n\n\t\t\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\t\t\tagent: \"optimize\",\n\t\t\t\t\t\t\ttool: \"draft_itinerary\",\n\t\t\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\t\t\tdetails: format!(\"JSON parse failed: {}\", e)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn Err(format!(\n\t\t\t\t\t\t\"Failed to parse draft itinerary. Standard JSON error: {}. JSON5 error: {}. Response preview: {}\",\n\t\t\t\t\t\te, json5_err, preview\n\t\t\t\t\t).into());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Build schedule summary\n\t\tlet mut schedule_summary: Vec\u003cString\u003e = Vec::new();\n\t\tif let Some(event_days) = itinerary.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\tfor (day_idx, day) in event_days.iter().enumerate() {\n\t\t\t\tlet date = day\n\t\t\t\t\t.get(\"date\")\n\t\t\t\t\t.and_then(|d| d.as_str())\n\t\t\t\t\t.unwrap_or(\"unknown\");\n\n\t\t\t\tlet morning = day\n\t\t\t\t\t.get(\"morning_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet afternoon = day\n\t\t\t\t\t.get(\"afternoon_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet evening = day\n\t\t\t\t\t.get(\"evening_events\")\n\t\t\t\t\t.and_then(|e| e.as_array())\n\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t.filter_map(|e| e.get(\"event_name\").and_then(|n| n.as_str()))\n\t\t\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t})\n\t\t\t\t\t.unwrap_or_default();\n\n\t\t\t\tlet mut day_parts = Vec::new();\n\t\t\t\tif !morning.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"AM:[{}]\", morning));\n\t\t\t\t}\n\t\t\t\tif !afternoon.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"PM:[{}]\", afternoon));\n\t\t\t\t}\n\t\t\t\tif !evening.is_empty() {\n\t\t\t\t\tday_parts.push(format!(\"EVE:[{}]\", evening));\n\t\t\t\t}\n\n\t\t\t\tschedule_summary.push(format!(\n\t\t\t\t\t\"Day{}({}):{}\",\n\t\t\t\t\tday_idx + 1,\n\t\t\t\t\tdate,\n\t\t\t\t\tif day_parts.is_empty() {\n\t\t\t\t\t\t\"empty\".to_string()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tday_parts.join(\" \")\n\t\t\t\t\t}\n\t\t\t\t));\n\t\t\t}\n\t\t}\n\n\t\tlet days_count = schedule_summary.len();\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tdays_count = days_count,\n\t\t\t\"Draft itinerary created\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"schedule=[{}]\", schedule_summary.join(\" | \"))\n\t\t);\n\n\t\t// STEP 3: Optimize routes for each day\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\t\"Step 3: Optimizing routes for each day\"\n\t\t);\n\n\t\tlet optimize_route_tool = OptimizeRouteTool;\n\t\tlet mut optimized_days = 0;\n\n\t\t// Get event_days array\n\t\tif let Some(event_days) = itinerary\n\t\t\t.get_mut(\"event_days\")\n\t\t\t.and_then(|v| v.as_array_mut())\n\t\t{\n\t\t\tfor day in event_days.iter_mut() {\n\t\t\t\t// Optimize morning events\n\t\t\t\tif let Some(morning) = day.get(\"morning_events\").cloned() {\n\t\t\t\t\tif let Some(morning_arr) = morning.as_array() {\n\t\t\t\t\t\tif !morning_arr.is_empty() \u0026\u0026 morning_arr.len() \u003e 1 {\n\t\t\t\t\t\t\t// Get first event location as start\n\t\t\t\t\t\t\tif let Some(first) = morning_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": morning,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"morning_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Optimize afternoon events\n\t\t\t\tif let Some(afternoon) = day.get(\"afternoon_events\").cloned() {\n\t\t\t\t\tif let Some(afternoon_arr) = afternoon.as_array() {\n\t\t\t\t\t\tif !afternoon_arr.is_empty() \u0026\u0026 afternoon_arr.len() \u003e 1 {\n\t\t\t\t\t\t\tif let Some(first) = afternoon_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": afternoon,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"afternoon_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Optimize evening events\n\t\t\t\tif let Some(evening) = day.get(\"evening_events\").cloned() {\n\t\t\t\t\tif let Some(evening_arr) = evening.as_array() {\n\t\t\t\t\t\tif !evening_arr.is_empty() \u0026\u0026 evening_arr.len() \u003e 1 {\n\t\t\t\t\t\t\tif let Some(first) = evening_arr.first() {\n\t\t\t\t\t\t\t\tlet start_location = json!({\n\t\t\t\t\t\t\t\t\t\"latitude\": first.get(\"lat\").and_then(|v| v.as_f64()).unwrap_or(0.0),\n\t\t\t\t\t\t\t\t\t\"longitude\": first.get(\"lng\").and_then(|v| v.as_f64()).unwrap_or(0.0)\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tlet route_input = json!({\n\t\t\t\t\t\t\t\t\t\"day_pois\": evening,\n\t\t\t\t\t\t\t\t\t\"start_location\": start_location\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif let Ok(optimized) = optimize_route_tool.run(route_input).await {\n\t\t\t\t\t\t\t\t\tif let Ok(optimized_arr) =\n\t\t\t\t\t\t\t\t\t\tserde_json::from_str::\u003cValue\u003e(\u0026optimized)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tday[\"evening_events\"] = optimized_arr;\n\t\t\t\t\t\t\t\t\t\toptimized_days += 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\toptimized_blocks = optimized_days,\n\t\t\t\"Routes optimized for all days\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{} time blocks optimized\", optimized_days)\n\t\t);\n\n\t\t// Add metadata to itinerary\n\t\titinerary[\"start_date\"] = trip_context_val\n\t\t\t.get(\"start_date\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\titinerary[\"end_date\"] = trip_context_val\n\t\t\t.get(\"end_date\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(Value::Null);\n\t\titinerary[\"title\"] = trip_context_val\n\t\t\t.get(\"destination\")\n\t\t\t.cloned()\n\t\t\t.unwrap_or(json!(\"Trip Itinerary\"));\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tlet result = serde_json::to_string(\u0026itinerary)?;\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, events_processed={}\", elapsed.as_millis(), events.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tevents_processed = events.len(),\n\t\t\t\"Optimization workflow completed successfully\"\n\t\t);\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool that ranks Points of Interest based on user preferences and constraints\n///\n/// This tool evaluates and ranks POIs considering user profile factors such as:\n/// - Budget constraints\n/// - Risk tolerance\n/// - Dietary restrictions/allergies\n/// - Accessibility needs/disabilities\n/// - Personal interests and preferences\n#[derive(Clone)]\nstruct RankPOIsByPreferenceTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n}\n\n/// Tool that builds an itinerary from a list of events\n#[derive(Clone)]\nstruct DraftItineraryTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n}\n\n/// Tool that optimizes the travel route for a day using TSP algorithms\n///\n/// This tool applies Traveling Salesman Problem optimization to minimize\n/// travel time and distance between POIs in a single day. Considers:\n/// - Geographic proximity\n/// - Transportation methods available\n/// - Traffic patterns\n/// - Walking distances\n#[derive(Clone)]\nstruct OptimizeRouteTool;\n\n#[async_trait]\nimpl Tool for RankPOIsByPreferenceTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"rank_pois_by_preference\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Ranks a list of Points of Interest based on user preferences, budget, risk tolerance, allergies, and accessibility needs. Returns a prioritized list of POIs with scores.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects to be ranked\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"user_profile\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"User profile containing budget, risk tolerance, allergies, disabilities, and preferences\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"budget\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"risk_tolerance\": {\"type\": \"string\"},\n\t\t\t\t\t\t\"allergies\": {\"type\": \"array\"},\n\t\t\t\t\t\t\"disabilities\": {\"type\": \"array\"},\n\t\t\t\t\t\t\"interests\": {\"type\": \"array\"}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"pois\", \"user_profile\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"rank_pois_by_preference\",\n\t\t\t\"Starting POI ranking\"\n\t\t);\n\n\t\tlet pois = input[\"pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"pois must be an array of objects\")?;\n\t\tlet profile = input[\"user_profile\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"user_profile must be an object\")?;\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tpois_count = pois.len(),\n\t\t\t\"Ranking POIs by preference\"\n\t\t);\n\n\t\tlet prompt = format!(\n\t\t\tinclude_str!(\"../prompts/rank_pois_preference.md\"),\n\t\t\tserde_json::to_string_pretty(\u0026pois)?,\n\t\t\tserde_json::to_string_pretty(\u0026profile)?\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"rank_pois_by_preference\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, pois_count={}\", elapsed.as_millis(), pois.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tpois_count = pois.len(),\n\t\t\t\"POI ranking completed\"\n\t\t);\n\n\t\tOk(response.trim().to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for DraftItineraryTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"draft_itinerary\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Assemble an itinerary from the list of POIs into the provided itinerary model structure.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects to be clustered\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"diversity_factor\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"Factor controlling how much diversity to enforce (0.0 to 1.0)\",\n\t\t\t\t\t\"default\": 0.7\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"pois\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"draft_itinerary\",\n\t\t\t\"Starting itinerary drafting\"\n\t\t);\n\n\t\tlet pois = input[\"pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"pois must be an array of objects\")?;\n\t\tlet diversity_factor = input[\"diversity_factor\"].as_number().map(|n| {\n\t\t\tn.as_f64()\n\t\t\t\t.ok_or(\"diversity_factor must be a 64-bit floating point number\")\n\t\t});\n\t\tlet trip_context = input.get(\"trip_context\").cloned().unwrap_or(json!({}));\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\tpois_count = pois.len(),\n\t\t\tdiversity_factor = diversity_factor.unwrap_or(Ok(0.7)).unwrap_or(0.7),\n\t\t\t\"Drafting itinerary from POIs\"\n\t\t);\n\n\t\tlet prompt = format!(\n\t\t\tinclude_str!(\"../prompts/draft_itinerary.md\"),\n\t\t\tserde_json::to_string_pretty(\u0026pois)?,\n\t\t\tinclude_str!(\"../prompts/itinerary.ts\"),\n\t\t\tdiversity_factor.unwrap_or(Ok(0.7))?,\n\t\t\tserde_json::to_string_pretty(\u0026trip_context)?\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"draft_itinerary\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}, pois_count={}\", elapsed.as_millis(), pois.len())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tpois_count = pois.len(),\n\t\t\t\"Itinerary draft completed\"\n\t\t);\n\n\t\tOk(response.trim().to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for OptimizeRouteTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"optimize_route\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Optimizes the order of POIs for a day to minimize travel time and distance using Traveling Salesman Problem algorithms. Returns the most efficient route. Input must be a single array of events, and the output will be that array sorted to optimize for shortest routes between events.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"day_pois\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"Array of POI objects for a single day with location data. Should not include start_location or end_location.\",\n\t\t\t\t\t\"items\": {\n\t\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\t\"id\": {\"type\": \"string\"},\n\t\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"start_location\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"Starting location (e.g., hotel)\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"end_location\": {\n\t\t\t\t\t\"type\": \"object\",\n\t\t\t\t\t\"description\": \"Ending location (optional, defaults to start_location)\",\n\t\t\t\t\t\"properties\": {\n\t\t\t\t\t\t\"latitude\": {\"type\": \"number\"},\n\t\t\t\t\t\t\"longitude\": {\"type\": \"number\"}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"day_pois\", \"start_location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tuse super::tsp::{EndpointMode, Pt, compute_route};\n\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"start\"\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\ttool = \"optimize_route\",\n\t\t\t\"Starting route optimization\"\n\t\t);\n\n\t\tlet mut pois = input[\"day_pois\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"day_pois must be an array of objects\")?\n\t\t\t.iter()\n\t\t\t.map(|poi| {\n\t\t\t\tlet poi = poi\n\t\t\t\t\t.as_object()\n\t\t\t\t\t.ok_or(\"day_pois must be an array of objects\")?;\n\t\t\t\tOk(Pt {\n\t\t\t\t\tid: Some(poi[\"id\"].as_str().ok_or(\"id must be a string\")?),\n\t\t\t\t\tlat: poi[\"latitude\"]\n\t\t\t\t\t\t.as_number()\n\t\t\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t\t\t.as_f64()\n\t\t\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\t\t\tlng: poi[\"longitude\"]\n\t\t\t\t\t\t.as_number()\n\t\t\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t\t\t.as_f64()\n\t\t\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect::\u003cResult\u003cVec\u003cPt\u003e, \u0026str\u003e\u003e()?;\n\n\t\tlet start = input[\"start_location\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"start_location must be an object\")?;\n\t\tlet start = Pt {\n\t\t\tid: None,\n\t\t\tlat: start[\"latitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\tlng: start[\"longitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t};\n\n\t\tpois.insert(0, start);\n\n\t\tif input[\"end_location\"].is_null() {\n\t\t\tpois = compute_route(pois.as_slice(), EndpointMode::Circle)\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|i| pois[i])\n\t\t\t\t.collect();\n\t\t\treturn Ok(json!(pois).to_string());\n\t\t}\n\n\t\tlet end = input[\"end_location\"]\n\t\t\t.as_object()\n\t\t\t.ok_or(\"end_location must be an object\")?;\n\t\tlet end = Pt {\n\t\t\tid: None,\n\t\t\tlat: end[\"latitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"latitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"latitude must be a 64-bit floating point number\")?,\n\t\t\tlng: end[\"longitude\"]\n\t\t\t\t.as_number()\n\t\t\t\t.ok_or(\"longitude must be an number\")?\n\t\t\t\t.as_f64()\n\t\t\t\t.ok_or(\"longitude must be a 64-bit floating point number\")?,\n\t\t};\n\n\t\tif start.lat == end.lat \u0026\u0026 start.lng == end.lng {\n\t\t\tpois = compute_route(pois.as_slice(), EndpointMode::Circle)\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|i| pois[i])\n\t\t\t\t.collect();\n\t\t\treturn Ok(json!(pois).to_string());\n\t\t}\n\n\t\tpois.push(end);\n\n\t\tpois = compute_route(pois.as_slice(), EndpointMode::Path)\n\t\t\t.into_iter()\n\t\t\t.map(|i| pois[i])\n\t\t\t.collect();\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"optimize\",\n\t\t\ttool: \"optimize_route\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"elapsed_ms={}\", elapsed.as_millis())\n\t\t);\n\n\t\tinfo!(\n\t\t\ttarget: \"optimize_tools\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Route optimization completed\"\n\t\t);\n\n\t\tOk(json!(pois).to_string())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","orchestrator.rs"],"content":"/*\n * src/agent/tools/orchestrator.rs\n *\n * Orchestrator Agent Tools Implementation - LLM-based extraction\n *\n * IMPORTANT: Tool Parameter Schema Pattern\n * ========================================\n * For parameters that can be objects/arrays, ALWAYS use \"type\": \"string\" in the schema.\n * Do NOT use \"anyOf\" or omit the type - langchain_rust 4.6.0 has a validation bug\n * that causes \"invalid type: map, expected a string\" errors during agent planning.\n *\n * Pattern to follow:\n * 1. Schema: Use \"type\": \"string\" for flexible parameters (objects/arrays)\n * 2. Description: Explicitly instruct LLM to pass JSON as strings\n * 3. Run method: Parse strings as JSON, but handle objects/arrays as fallback\n *\n * Example (see ask_for_clarification tool):\n *   \"missing_info\": {\n *     \"type\": \"string\",  // NOT \"anyOf\" or no type!\n *     \"description\": \"...as a JSON string. Example: '[\\\"item\\\"]'\"\n *   }\n *\n * This allows langchain_rust validation to pass while still accepting\n * whatever format the LLM generates (we handle both in run()).\n */\n\nuse crate::agent::models::context::{ContextData, SharedContextStore, ToolExecution};\nuse crate::agent::tools::task::RespondToUserTool;\nuse crate::sql_models::LlmProgress;\nuse async_trait::async_trait;\nuse langchain_rust::chain::Chain;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse tokio::sync::Mutex;\nuse tracing::{debug, error, info};\n\n/// Helper function to automatically track tool executions in context.\n/// This is called by every tool to record its execution in the tool_history.\n///\n/// Marked pub(crate) so it can be reused by Task tools without exposing it outside\n/// the agent tools module.\npub(crate) async fn track_tool_execution(\n\t_context_store: \u0026SharedContextStore,\n\tchat_session_id: \u0026Arc\u003cAtomicI32\u003e,\n\ttool_name: \u0026str,\n\tinput: \u0026Value,\n\toutput: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n\tlet chat_id = chat_session_id.load(Ordering::Relaxed);\n\tif chat_id == 0 {\n\t\t// If chat_session_id is not set, we're probably in a test or the tool is being called outside the agent context\n\t\treturn Ok(());\n\t}\n\n\t// Get existing in-memory context (should exist from controller initialization)\n\tlet mut store_guard = _context_store.write().await;\n\tlet context_data = match store_guard.get_mut(\u0026chat_id) {\n\t\tSome(ctx) =\u003e ctx,\n\t\tNone =\u003e {\n\t\t\t// Context doesn't exist - this shouldn't happen in normal flow\n\t\t\t// but create it to be safe\n\t\t\tstore_guard.insert(\n\t\t\t\tchat_id,\n\t\t\t\tContextData {\n\t\t\t\t\tchat_session_id: chat_id,\n\t\t\t\t\tuser_id: 0, // Unknown\n\t\t\t\t\tuser_profile: None,\n\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\tevents: vec![],\n\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\tconstraints: vec![],\n\t\t\t\t},\n\t\t\t);\n\t\t\tstore_guard.get_mut(\u0026chat_id).unwrap()\n\t\t}\n\t};\n\n\t// Add tool execution to history\n\tlet tool_exec = ToolExecution {\n\t\ttool_name: tool_name.to_string(),\n\t\tinput: input.clone(),\n\t\toutput: serde_json::from_str(output).unwrap_or_else(|_| json!(output)),\n\t\ttimestamp: chrono::Utc::now().to_rfc3339(),\n\t\tsuccess: true, // Assume success if the tool is calling this function\n\t};\n\n\tcontext_data.tool_history.push(tool_exec);\n\n\t// Keep only last 100 entries\n\tif context_data.tool_history.len() \u003e 100 {\n\t\tcontext_data.tool_history.remove(0);\n\t}\n\n\tdebug!(\n\t\ttarget: \"orchestrator_tool\",\n\t\ttool = tool_name,\n\t\tchat_id = chat_id,\n\t\ttool_history_count = context_data.tool_history.len(),\n\t\t\"Tracked tool execution\"\n\t);\n\n\tOk(())\n}\n\n#[derive(Clone)]\npub struct RouteTaskTool {\n\tpub task_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub research_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub constraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpub optimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RouteTaskTool {\n\tpub fn new(\n\t\ttask_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tresearch_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tconstraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\toptimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\ttask_agent,\n\t\t\tresearch_agent,\n\t\t\tconstraint_agent,\n\t\t\toptimize_agent,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n/// Tool 4: Route Task to Sub-Agent\n/// Routes a task to the appropriate sub-agent (research, constraint, or optimize).\n/// Returns a TaskRoute object.\n#[async_trait]\nimpl Tool for RouteTaskTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"route_task\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Routes a task to the appropriate sub-agent (research, constraint, or optimize). IMPORTANT: All parameters must be passed as strings. For 'payload', pass the JSON object as a JSON string.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"task_type\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"enum\": [\"task\", \"research\", \"constraint\", \"optimize\"],\n\t\t\t\t\t\"description\": \"The type of task to route: 'task' (Task Agent for context building), 'research', 'constraint', or 'optimize'\"\n\t\t\t\t},\n\t\t\t\t\"payload\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The data to send to the sub-agent as a JSON string. If you have an object, serialize it to JSON first.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"task_type\", \"payload\"]\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in route_task\"\n\t\t);\n\n\t\t// langchain_rust passes action_input as a STRING, so parse it first if needed\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| {\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\ttool = \"route_task\",\n\t\t\t\t\t\"Failed to parse input as JSON, using as-is\"\n\t\t\t\t);\n\t\t\t\tinput.clone()\n\t\t\t})\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle task_type - prefer simple string, but be defensive about weird shapes\n\t\t//\n\t\t// In theory the LLM should always pass a plain string (\\\"task\\\", \\\"research\\\", etc.)\n\t\t// but in practice we have seen cases in logs where this ended up as \\\"null\\\"\n\t\t// and caused `Unknown task type: null` errors, preventing the Task Agent from running.\n\t\t//\n\t\t// Strategy:\n\t\t// - If we can read a string, use it directly.\n\t\t// - If it's an object, look for common fields (`value`, `task_type`).\n\t\t// - If it's missing / null / empty, *default to \\\"task\\\"* so first-turn\n\t\t//   orchestration still calls the Task Agent instead of hard failing.\n\t\tlet raw_task_type_value = \u0026parsed_input[\"task_type\"];\n\n\t\tlet mut task_type = if let Some(s) = raw_task_type_value.as_str() {\n\t\t\ts.to_string()\n\t\t} else if raw_task_type_value.is_object() {\n\t\t\traw_task_type_value\n\t\t\t\t.get(\"value\")\n\t\t\t\t.or_else(|| raw_task_type_value.get(\"task_type\"))\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t.unwrap_or_else(|| raw_task_type_value.to_string())\n\t\t} else if raw_task_type_value.is_null() {\n\t\t\t// This is the problematic case we've seen in logs; default to \\\"task\\\"\n\t\t\t\"task\".to_string()\n\t\t} else {\n\t\t\traw_task_type_value.to_string()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\traw_task_type = %serde_json::to_string(\u0026raw_task_type_value)?,\n\t\t\tparsed_task_type = %task_type,\n\t\t\t\"Parsed task_type from input\"\n\t\t);\n\n\t\t// Handle payload - can be string (JSON), object, or already a string\n\t\tlet payload_str = if let Some(s) = parsed_input[\"payload\"].as_str() {\n\t\t\t// If it's a string, check if it's valid JSON, otherwise use as-is\n\t\t\tif serde_json::from_str::\u003cValue\u003e(s).is_ok() {\n\t\t\t\ts.to_string()\n\t\t\t} else {\n\t\t\t\ts.to_string()\n\t\t\t}\n\t\t} else if parsed_input[\"payload\"].is_object() {\n\t\t\t// If it's an object, serialize it to string\n\t\t\tserde_json::to_string(\u0026parsed_input[\"payload\"])?\n\t\t} else {\n\t\t\t// Fallback: convert to string representation\n\t\t\tparsed_input[\"payload\"].to_string()\n\t\t};\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\ttask_type = task_type,\n\t\t\t\"Routing task to sub-agent\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tinput = %serde_json::to_string(\u0026parsed_input)?,\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// Normalize task_type to lowercase string and handle degenerate values\n\t\tlet mut task_type_normalized = task_type.to_lowercase().trim().to_string();\n\n\t\t// If the normalized value is empty or literally \\\"null\\\", treat it as \\\"task\\\"\n\t\t// so that we still invoke the Task Agent instead of erroring.\n\t\tif task_type_normalized.is_empty() || task_type_normalized == \"null\" {\n\t\t\tdebug!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"route_task\",\n\t\t\t\traw_task_type = %raw_task_type_value,\n\t\t\t\t\"task_type was empty or 'null'; defaulting to 'task'\"\n\t\t\t);\n\t\t\ttask_type_normalized = \"task\".to_string();\n\t\t\ttask_type = \"task\".to_string();\n\t\t}\n\n\t\t// Tool trace logging\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"orchestrator\",\n\t\t\ttool: \"route_task\",\n\t\t\tstatus: \"start\",\n\t\t\tdetails: format!(\"task_type={}\", task_type)\n\t\t);\n\n\t\t// Update LLM progress status in database BEFORE processing\n\t\tif let Some(progress) = match task_type_normalized.as_str() {\n\t\t\t\"research\" =\u003e Some(LlmProgress::Searching),\n\t\t\t\"constraint\" =\u003e Some(LlmProgress::Filtering),\n\t\t\t\"optimize\" =\u003e Some(LlmProgress::Optimizing),\n\t\t\t\"task\" =\u003e Some(LlmProgress::Scheduling),\n\t\t\t_ =\u003e None,\n\t\t} {\n\t\t\tlet chat_session_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tinfo!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, progress = ?progress, \"Updating LLM progress\");\n\n\t\t\tmatch sqlx::query!(\n\t\t\t\tr#\"UPDATE chat_sessions\n\t\t\t\tSET llm_progress=$1\n\t\t\t\tWHERE id=$2;\"#,\n\t\t\t\tprogress as _,\n\t\t\t\tchat_session_id\n\t\t\t)\n\t\t\t.execute(\u0026self.pool)\n\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(result) =\u003e {\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, rows_affected = result.rows_affected(), \"LLM progress updated successfully\");\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\terror!(target: \"orchestrator_pipeline\", chat_session_id = chat_session_id, error = %e, \"Failed to update LLM progress\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// SPECIAL HANDLING: High-level Task Agent\n\t\t//\n\t\t// When task_type == \"task\", we want to delegate the entire planning pipeline\n\t\t// to the Task Agent and propagate its raw string output back to the controller.\n\t\t// This preserves markers like \"MESSAGE_INSERTED:\" and \"FINAL_ANSWER:\" so that\n\t\t// `send_message_to_llm` can handle them as before.\n\t\tif task_type_normalized == \"task\" {\n\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"begin\", status: \"invoked\");\n\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", \"Invoking task agent\");\n\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"task\", payload = %payload_str, \"Agent input\");\n\n\t\t\tlet agent_outer = self.task_agent.lock().await;\n\t\t\tlet agent_inner = agent_outer.lock().await;\n\n\t\t\tlet response = match agent_inner\n\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t})\n\t\t\t\t.await\n\t\t\t{\n\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"complete\", status: \"success\");\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", status = \"completed\", \"Task agent completed\");\n\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"task\", response = %response, \"Task agent raw output\");\n\t\t\t\t\tresponse\n\t\t\t\t}\n\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\tcrate::tool_trace!(agent: \"task\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"task\", status = \"error\", error = %e, \"Task agent error\");\n\t\t\t\t\tformat!(\"TASK_AGENT_ERROR: {}\", e)\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Track this tool execution with a JSON wrapper for observability,\n\t\t\t// but return the raw response string so the controller can interpret it.\n\t\t\tlet tracking_value = json!({\n\t\t\t\t\"agent\": \"task\",\n\t\t\t\t\"status\": if response.starts_with(\"TASK_AGENT_ERROR:\") { \"error\" } else { \"completed\" },\n\t\t\t\t\"raw\": response,\n\t\t\t});\n\t\t\tlet tracking_str = serde_json::to_string(\u0026tracking_value)?;\n\n\t\t\ttrack_tool_execution(\n\t\t\t\t\u0026self.context_store,\n\t\t\t\t\u0026self.chat_session_id,\n\t\t\t\t\"route_task\",\n\t\t\t\t\u0026input_clone,\n\t\t\t\t\u0026tracking_str,\n\t\t\t)\n\t\t\t.await?;\n\n\t\t\treturn Ok(response);\n\t\t}\n\n\t\t// For research/constraint/optimize agents, inject context from context_store\n\t\tlet payload_str = if task_type_normalized == \"research\" {\n\t\t\t// Research gets the current trip_context snapshot\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\tlet trip_context_json = serde_json::to_string(\u0026context_data.trip_context)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"research\",\n\t\t\t\t\t\t\"Injecting trip context into payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\ttrip_context = %trip_context_json,\n\t\t\t\t\t\t\"Trip context being passed to research agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\ttrip_context_json\n\t\t\t\t} else {\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else if task_type_normalized == \"constraint\" {\n\t\t\t// Constraint gets both trip context and the latest research results\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\t// Find latest successful research result from tool_history\n\t\t\t\t\tlet mut research_data: Value = json!(null);\n\t\t\t\t\tfor exec in context_data.tool_history.iter().rev() {\n\t\t\t\t\t\tif exec.tool_name == \"route_task\" {\n\t\t\t\t\t\t\tif let Some(agent) = exec.output.get(\"agent\").and_then(|v| v.as_str()) {\n\t\t\t\t\t\t\t\tif agent == \"research\" {\n\t\t\t\t\t\t\t\t\tif exec.output.get(\"status\").and_then(|v| v.as_str())\n\t\t\t\t\t\t\t\t\t\t== Some(\"completed\")\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tresearch_data =\n\t\t\t\t\t\t\t\t\t\t\texec.output.get(\"data\").cloned().unwrap_or(json!(null));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extract event_ids from research data\n\t\t\t\t\tlet event_ids = if let Some(ids) = research_data.get(\"event_ids\") {\n\t\t\t\t\t\tids.clone()\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Research data might be wrapped differently\n\t\t\t\t\t\tjson!([])\n\t\t\t\t\t};\n\n\t\t\t\t\tlet constraint_payload = json!({\n\t\t\t\t\t\t\"trip_context\": \u0026context_data.trip_context,\n\t\t\t\t\t\t\"constraints\": \u0026context_data.constraints,\n\t\t\t\t\t\t\"event_ids\": event_ids\n\t\t\t\t\t});\n\n\t\t\t\t\tlet payload_json = serde_json::to_string(\u0026constraint_payload)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"constraint\",\n\t\t\t\t\t\t\"Injecting trip context and research results into constraint payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tpayload = %payload_json,\n\t\t\t\t\t\t\"Constraint payload being passed to agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\tpayload_json\n\t\t\t\t} else {\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else if task_type_normalized == \"optimize\" {\n\t\t\t// Optimize gets trip context, user profile, and constraint results\n\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\tdebug!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tagent = \"optimize\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\t\"Building optimize payload from context\"\n\t\t\t);\n\t\t\tif chat_id \u003e 0 {\n\t\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\ttool_history_count = context_data.tool_history.len(),\n\t\t\t\t\t\t\"Found context data with tool history\"\n\t\t\t\t\t);\n\t\t\t\t\t// Find latest successful constraint result from tool_history\n\t\t\t\t\tlet mut constraint_data: Value = json!(null);\n\t\t\t\t\tfor exec in context_data.tool_history.iter().rev() {\n\t\t\t\t\t\tif exec.tool_name == \"route_task\" {\n\t\t\t\t\t\t\tif let Some(agent) = exec.output.get(\"agent\").and_then(|v| v.as_str()) {\n\t\t\t\t\t\t\t\tif agent == \"constraint\" {\n\t\t\t\t\t\t\t\t\tif exec.output.get(\"status\").and_then(|v| v.as_str())\n\t\t\t\t\t\t\t\t\t\t== Some(\"completed\")\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconstraint_data =\n\t\t\t\t\t\t\t\t\t\t\texec.output.get(\"data\").cloned().unwrap_or(json!(null));\n\t\t\t\t\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\t\t\t\t\tconstraint_data = %serde_json::to_string(\u0026constraint_data).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\t\t\t\t\t\"Found constraint result in tool_history\"\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extract filtered_event_ids from constraint result\n\t\t\t\t\t// Handle multiple possible structures:\n\t\t\t\t\t// 1. Direct: {\"filtered_event_ids\": [...]}\n\t\t\t\t\t// 2. Wrapped in raw string: {\"raw\": \"{\\\"filtered_event_ids\\\":[...]}\"}\n\t\t\t\t\tlet filtered_ids = if let Some(ids) = constraint_data.get(\"filtered_event_ids\")\n\t\t\t\t\t{\n\t\t\t\t\t\tids.clone()\n\t\t\t\t\t} else if let Some(raw) = constraint_data.get(\"raw\") {\n\t\t\t\t\t\t// Parse the raw string\n\t\t\t\t\t\tif let Some(raw_str) = raw.as_str() {\n\t\t\t\t\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cValue\u003e(raw_str) {\n\t\t\t\t\t\t\t\tparsed\n\t\t\t\t\t\t\t\t\t.get(\"filtered_event_ids\")\n\t\t\t\t\t\t\t\t\t.cloned()\n\t\t\t\t\t\t\t\t\t.unwrap_or(json!([]))\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if constraint_data.is_string() {\n\t\t\t\t\t\t// Parse constraint result if it's a string itself\n\t\t\t\t\t\tlet constraint_str = constraint_data.as_str().unwrap_or(\"{}\");\n\t\t\t\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cValue\u003e(constraint_str) {\n\t\t\t\t\t\t\tparsed\n\t\t\t\t\t\t\t\t.get(\"filtered_event_ids\")\n\t\t\t\t\t\t\t\t.cloned()\n\t\t\t\t\t\t\t\t.unwrap_or(json!([]))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjson!([])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjson!([])\n\t\t\t\t\t};\n\n\t\t\t\t\t// Log what we extracted for debugging\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\tfiltered_ids = %serde_json::to_string(\u0026filtered_ids).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\"Extracted filtered_event_ids from constraint result\"\n\t\t\t\t\t);\n\n\t\t\t\t\tlet optimize_payload = json!({\n\t\t\t\t\t\t\"trip_context\": \u0026context_data.trip_context,\n\t\t\t\t\t\t\"user_profile\": \u0026context_data.user_profile,\n\t\t\t\t\t\t\"filtered_event_ids\": filtered_ids\n\t\t\t\t\t});\n\n\t\t\t\t\tlet payload_json = serde_json::to_string(\u0026optimize_payload)\n\t\t\t\t\t\t.unwrap_or_else(|_| \"{}\".to_string());\n\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\"Injecting trip context, user profile, and constraint results into optimize payload\"\n\t\t\t\t\t);\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tpayload = %payload_json,\n\t\t\t\t\t\t\"Optimize payload being passed to agent\"\n\t\t\t\t\t);\n\n\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\tpayload_json\n\t\t\t\t} else {\n\t\t\t\t\tdebug!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\t\"No context data found for chat_id, using original payload\"\n\t\t\t\t\t);\n\t\t\t\t\tpayload_str\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\"chat_id is 0, using original payload\"\n\t\t\t\t);\n\t\t\t\tpayload_str\n\t\t\t}\n\t\t} else {\n\t\t\tpayload_str\n\t\t};\n\n\t\tlet result = match task_type_normalized.as_str() {\n\t\t\t\"research\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", \"Invoking research agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"research\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.research_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\t// Parse response as JSON Value if possible\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", status = \"completed\", \"Research agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"research\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"research\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"research\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"research\", status = \"error\", error = %e, \"Research agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"research\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\"constraint\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", \"Invoking constraint agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"constraint\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.constraint_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\tagent = \"constraint\",\n\t\t\t\t\t\t\traw_response = %response,\n\t\t\t\t\t\t\t\"Constraint agent raw response before parsing\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", status = \"completed\", \"Constraint agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"constraint\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"constraint\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"constraint\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"constraint\", status = \"error\", error = %e, \"Constraint agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"constraint\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\"optimize\" =\u003e {\n\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"begin\", status: \"invoked\");\n\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", \"Invoking optimize agent\");\n\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"optimize\", payload = %payload_str, \"Agent input\");\n\n\t\t\t\tlet agent_outer = self.optimize_agent.lock().await;\n\t\t\t\tlet agent_inner = agent_outer.lock().await;\n\t\t\t\tmatch agent_inner\n\t\t\t\t\t.invoke(langchain_rust::prompt_args! {\n\t\t\t\t\t\t\"input\" =\u003e payload_str.as_str(),\n\t\t\t\t\t})\n\t\t\t\t\t.await\n\t\t\t\t{\n\t\t\t\t\tOk(response) =\u003e {\n\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\traw_response = %response,\n\t\t\t\t\t\t\t\"Optimize agent raw response before parsing\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlet data: Value = serde_json::from_str(\u0026response)\n\t\t\t\t\t\t\t.unwrap_or_else(|_| json!({ \"raw\": response }));\n\n\t\t\t\t\t\t// Store the complete itinerary in active_itinerary context\n\t\t\t\t\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\t\t\t\t\tif chat_id \u003e 0 {\n\t\t\t\t\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\t\t\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\t\t\t\t\tcontext_data.active_itinerary = Some(data.clone());\n\t\t\t\t\t\t\t\tinfo!(\n\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\tagent = \"optimize\",\n\t\t\t\t\t\t\t\t\t\"Stored itinerary in active_itinerary context\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdebug!(\n\t\t\t\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\t\t\t\titinerary = %serde_json::to_string(\u0026data).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\t\t\t\t\"Itinerary stored in context\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdrop(store_guard);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"complete\", status: \"success\");\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", status = \"completed\", \"Optimize agent completed\");\n\t\t\t\t\t\tdebug!(target: \"orchestrator_pipeline\", agent = \"optimize\", response = %serde_json::to_string(\u0026data)?, \"Agent output\");\n\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"optimize\",\n\t\t\t\t\t\t\t\"status\": \"completed\",\n\t\t\t\t\t\t\t\"data\": data\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tErr(e) =\u003e {\n\t\t\t\t\t\tcrate::tool_trace!(agent: \"optimize\", tool: \"complete\", status: \"error\", details: format!(\"{}\", e));\n\t\t\t\t\t\tinfo!(target: \"orchestrator_pipeline\", agent = \"optimize\", status = \"error\", error = %e, \"Optimize agent error\");\n\t\t\t\t\t\tjson!({\n\t\t\t\t\t\t\t\"agent\": \"optimize\",\n\t\t\t\t\t\t\t\"status\": \"error\",\n\t\t\t\t\t\t\t\"error\": format!(\"{}\", e)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t_ =\u003e {\n\t\t\t\treturn Err(format!(\"Unknown task type: {}\", task_type).into());\n\t\t\t}\n\t\t};\n\n\t\tlet result_str = serde_json::to_string(\u0026result)?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\ttask_type = task_type,\n\t\t\tstatus = result.get(\"status\").and_then(|s| s.as_str()).unwrap_or(\"unknown\"),\n\t\t\t\"Task routing completed\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"route_task\",\n\t\t\tresult = %result_str,\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"route_task\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result_str,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result_str)\n\t}\n}\n\n/// Gets all the orchestrator tools.\n/// Returns a vector of Arc\u003cdyn Tool\u003e objects.\n/// chat_session_id and user_id are shared across tools that need them and can be updated per request.\npub fn get_orchestrator_tools(\n\t_llm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\ttask_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tresearch_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tconstraint_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\toptimize_agent: Arc\u003cMutex\u003ccrate::agent::configs::orchestrator::AgentType\u003e\u003e,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t_user_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![\n\t\tArc::new(RouteTaskTool::new(\n\t\t\ttask_agent,\n\t\t\tresearch_agent,\n\t\t\tconstraint_agent,\n\t\t\toptimize_agent,\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RespondToUserTool::new(pool, chat_session_id, context_store)),\n\t\t// Note: context-building tools (profile, chat history, intent, clarification)\n\t\t// are exposed via the Task Agent through `get_task_tools` and should not be\n\t\t// called directly by the Orchestrator.\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","research.rs"],"content":"/*\n * src/agent/tools/research.rs\n *\n * File for Reseearch Agent Tools\n *\n * Purpose:\n *   Store Research Agent Tools\n */\n\nuse async_trait::async_trait;\nuse google_maps::places_new::{Field, FieldMask, PlaceType};\nuse langchain_rust::tools::Tool;\nuse serde::{Deserialize, de::IntoDeserializer};\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse sqlx::prelude::FromRow;\nuse std::time::Instant;\nuse std::{error::Error, sync::Arc};\nuse tracing::{debug, info};\n\nuse crate::{global::GOOGLE_MAPS_API_KEY, http_models::event::Event};\n\npub fn research_tools(db: PgPool) -\u003e [Arc\u003cdyn Tool\u003e; 2] {\n\t[\n\t\tArc::new(GeocodeTool),\n\t\t// Arc::new(QueryDbEventsTool { db: db.clone() }),\n\t\tArc::new(NearbySearchTool { db }),\n\t]\n}\n\n/// This tool takes an address and converts it into coordinates using Google Maps Geocoding API.\n#[derive(Clone)]\nstruct GeocodeTool;\n\n/// This tool queries the DB for events that may be relevant to the itinerary being generated.\n#[derive(Clone)]\n#[allow(dead_code)]\nstruct QueryDbEventsTool {\n\tpub db: PgPool,\n}\n\n/// This tool uses Google Maps Nearby Search to fetch a list of places in a given area with certain input criteria.\n/// The resulting events are inserted or updated in the database.\n#[derive(Clone)]\nstruct NearbySearchTool {\n\tpub db: PgPool,\n}\n\n#[async_trait]\nimpl Tool for GeocodeTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"geocode_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that takes an address or location and converts it into coordinates using Google Maps Geocoding API.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"location\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The street address that you want to geocode, in the format used by the national postal service of the country concerned. Additional address elements such as business names and unit, suite or floor numbers hould be avoided. The street will likely not always be provided, but city should almost always be expected.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(agent: \"research\", tool: \"geocode_tool\", status: \"start\");\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\t\"Starting geocoding\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// langchain-rust passes `action_input` as a STRING, but the LLM may:\n\t\t// - pass a plain text location like \"Connecticut\"\n\t\t// - pass a JSON string like \"{\\\"location\\\":\\\"Connecticut\\\"}\"\n\t\t// - or pass an object with `location` or `destination` fields.\n\t\t//\n\t\t// Normalize all of these into a single `location` string.\n\t\tlet location: String = if input.is_string() {\n\t\t\tlet raw = input.as_str().unwrap_or(\"\").trim();\n\n\t\t\tif raw.is_empty() {\n\t\t\t\treturn Err(\"Location is required\".into());\n\t\t\t}\n\n\t\t\tif raw.starts_with('{') || raw.starts_with('[') {\n\t\t\t\tlet v: Value =\n\t\t\t\t\tserde_json::from_str(raw).unwrap_or_else(|_| json!({ \"location\": raw }));\n\n\t\t\t\tv.get(\"location\")\n\t\t\t\t\t.or_else(|| v.get(\"destination\"))\n\t\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t\t.ok_or(\"Location or destination field should be a string\")?\n\t\t\t\t\t.to_string()\n\t\t\t} else {\n\t\t\t\traw.to_string()\n\t\t\t}\n\t\t} else {\n\t\t\tinput\n\t\t\t\t.get(\"location\")\n\t\t\t\t.or_else(|| input.get(\"destination\"))\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.ok_or(\"Location or destination field should be a string\")?\n\t\t\t\t.to_string()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tlocation = %location,\n\t\t\t\"Geocoding location\"\n\t\t);\n\n\t\tdotenvy::dotenv().map_err(|_| \"Failed to load environment variables\")?;\n\t\tlet gm_api_key =\n\t\t\tstd::env::var(GOOGLE_MAPS_API_KEY).map_err(|_| \"GOOGLE_MAPS_API_KEY is not set\")?;\n\n\t\t// use google maps api to get the address from the provided location and use geocoding to get its coordinates\n\t\tlet gm_client = google_maps::Client::try_new(gm_api_key)\n\t\t\t.map_err(|_| \"Failed to create client for Google Maps API\")?;\n\t\tlet geocode_res = gm_client\n\t\t\t.geocoding()\n\t\t\t.with_address(\u0026location)\n\t\t\t.execute()\n\t\t\t.await?;\n\t\tif let Some(err) = geocode_res.error_message {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - Geocoding API error: {}\", elapsed.as_millis(), err)\n\t\t\t);\n\t\t\treturn Err(format!(\n\t\t\t\t\"Geocoding failed with status {} - {err}\",\n\t\t\t\tgeocode_res.status\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\t\tif !matches!(geocode_res.status, google_maps::geocoding::Status::Ok) {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - Bad status: {}\", elapsed.as_millis(), geocode_res.status)\n\t\t\t);\n\t\t\treturn Err(format!(\"Geocoding failed with status {}\", geocode_res.status).into());\n\t\t}\n\t\tif geocode_res.results.is_empty() {\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tcrate::tool_trace!(\n\t\t\t\tagent: \"research\",\n\t\t\t\ttool: \"geocode_tool\",\n\t\t\t\tstatus: \"error\",\n\t\t\t\tdetails: format!(\"{}ms - No results\", elapsed.as_millis())\n\t\t\t);\n\t\t\treturn Err(format!(\"Geocoding could not get coordinates for {location}\").into());\n\t\t}\n\n\t\tlet result = json!({\n\t\t\t\"lat\": geocode_res.results[0].geometry.location.lat,\n\t\t\t\"lng\": geocode_res.results[0].geometry.location.lng\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tlat = %geocode_res.results[0].geometry.location.lat,\n\t\t\tlng = %geocode_res.results[0].geometry.location.lng,\n\t\t\t\"Geocoding completed successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"geocode_tool\",\n\t\t\tresult = %result.to_string(),\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"research\",\n\t\t\ttool: \"geocode_tool\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{}ms\", elapsed.as_millis())\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n\n#[async_trait]\nimpl Tool for QueryDbEventsTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"query_db_events_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that queries the DB for events that may be relevant to the itinerary being generated.\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"location\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"A location in the world from the user's prompt; ideally a city name or postal code, but could be anything that indicates a place like a street address or country.\"\n\t\t\t\t},\n\t\t\t\t\"keywords\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of keywords from the user's prompt that can be used to search for relevant events.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"location\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\t// TODO create filters and query the db for possibly relevant events\n\n\t\tlet name = input[\"name\"].as_str().ok_or(\"Name should be a string\")?;\n\t\tOk(format!(\"Hello, {}! Welcome to our AI assistant.\", name))\n\t}\n}\n\n#[async_trait]\nimpl\u003c'db\u003e Tool for NearbySearchTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"nearby_search_tool\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"A tool that uses Google Maps Nearby Search to fetch a list of places in a given area with certain input criteria. The resulting events are inserted or updated in the database and their IDs are returned. Returns a JSON object with 'event_ids' (array of integer IDs) and 'count' (number of events found).\"\n            .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"lat\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"The lattitude of the target location.\"\n\t\t\t\t},\n\t\t\t\t\"lng\": {\n\t\t\t\t\t\"type\": \"number\",\n\t\t\t\t\t\"description\": \"The longitude of the target location.\"\n\t\t\t\t},\n\t\t\t\t\"includedTypes\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of places types to include.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t},\n\t\t\t\t\"excludedTypes\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of places types to exclude.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"}\n\t\t\t\t},\n\t\t\t\t\"cities\": {\n\t\t\t\t\t\"type\": \"array\",\n\t\t\t\t\t\"description\": \"An array of strings representing cities the user would like to travel to. If a list of cities cannot be interpreted from the user's prompt, this must be an empty array. Cities could be obtained directly from the user's prompt or by using neighboring cities that weren't mentioned.\",\n\t\t\t\t\t\"items\": {\"type\": \"string\"},\n\t\t\t\t\t\"default\": []\n\t\t\t\t},\n\t\t\t\t\"country\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The country the user would like to travel to.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"lat\", \"lng\", \"cities\"]\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\n\t\tcrate::tool_trace!(agent: \"research\", tool: \"nearby_search_tool\", status: \"start\");\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\"Starting nearby search\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tinput = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"invalid\".to_string()),\n\t\t\t\"Tool input\"\n\t\t);\n\n\t\t// langchain-rust usually passes `action_input` as a STRING. Normalize it:\n\t\t// - If it's a JSON string, parse it into an object.\n\t\t// - If it's a plain string, treat it as a \"lat,lng\" location string.\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\tlet raw = input.as_str().unwrap_or(\"\").trim();\n\t\t\tif raw.starts_with('{') || raw.starts_with('[') {\n\t\t\t\tserde_json::from_str(raw).unwrap_or_else(|_| json!({ \"location\": raw }))\n\t\t\t} else {\n\t\t\t\tjson!({ \"location\": raw })\n\t\t\t}\n\t\t} else {\n\t\t\tinput\n\t\t};\n\n\t\t// Handle multiple input formats:\n\t\t// 1. Combined \"location\" field as \"lat,lng\" string\n\t\t// 2. \"location\" field as object with lat/lng properties\n\t\t// 3. Separate lat/lng fields (as numbers or strings)\n\t\tlet (lat, lng) = if let Some(location_val) = parsed_input.get(\"location\") {\n\t\t\tdebug!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\tlocation_val = %location_val,\n\t\t\t\t\"Processing location field\"\n\t\t\t);\n\n\t\t\t// Check if location is an object with lat/lng properties\n\t\t\tif location_val.is_object() {\n\t\t\t\tlet lat = if let Some(f) = location_val.get(\"lat\").and_then(|v| v.as_f64()) {\n\t\t\t\t\tf\n\t\t\t\t} else if let Some(s) = location_val.get(\"lat\").and_then(|v| v.as_str()) {\n\t\t\t\t\ts.parse::\u003cf64\u003e().map_err(|e| {\n\t\t\t\t\t\tformat!(\"lat in location object should be a valid number: {}\", e)\n\t\t\t\t\t})?\n\t\t\t\t} else {\n\t\t\t\t\treturn Err(\n\t\t\t\t\t\t\"location object must have a 'lat' field as a number or string\".into(),\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tlet lng = if let Some(f) = location_val.get(\"lng\").and_then(|v| v.as_f64()) {\n\t\t\t\t\tf\n\t\t\t\t} else if let Some(s) = location_val.get(\"lng\").and_then(|v| v.as_str()) {\n\t\t\t\t\ts.parse::\u003cf64\u003e().map_err(|e| {\n\t\t\t\t\t\tformat!(\"lng in location object should be a valid number: {}\", e)\n\t\t\t\t\t})?\n\t\t\t\t} else {\n\t\t\t\t\treturn Err(\n\t\t\t\t\t\t\"location object must have a 'lng' field as a number or string\".into(),\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\t(lat, lng)\n\t\t\t} else if let Some(location_str) = location_val.as_str() {\n\t\t\t\t// Parse from \"location\" field as \"lat,lng\" string\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\tlocation = %location_str,\n\t\t\t\t\t\"Parsing location string\"\n\t\t\t\t);\n\n\t\t\t\tlet parts: Vec\u003c\u0026str\u003e = location_str.split(',').collect();\n\t\t\t\tif parts.len() != 2 {\n\t\t\t\t\treturn Err(\"location string should be in format 'lat,lng'\".into());\n\t\t\t\t}\n\t\t\t\tlet lat = parts[0]\n\t\t\t\t\t.trim()\n\t\t\t\t\t.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"Invalid latitude in location string: {}\", e))?;\n\t\t\t\tlet lng = parts[1]\n\t\t\t\t\t.trim()\n\t\t\t\t\t.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"Invalid longitude in location string: {}\", e))?;\n\t\t\t\t(lat, lng)\n\t\t\t} else {\n\t\t\t\treturn Err(\"location field should be either a string in format 'lat,lng' or an object with lat/lng properties\".into());\n\t\t\t}\n\t\t} else {\n\t\t\t// Parse from separate lat/lng fields\n\t\t\tdebug!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\"No location field, looking for separate lat/lng fields\"\n\t\t\t);\n\n\t\t\tlet lat = if let Some(f) = parsed_input.get(\"lat\").and_then(|v| v.as_f64()) {\n\t\t\t\tf\n\t\t\t} else if let Some(s) = parsed_input.get(\"lat\").and_then(|v| v.as_str()) {\n\t\t\t\ts.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"lat should be a valid number: {}\", e))?\n\t\t\t} else {\n\t\t\t\treturn Err(\"lat should be a 64-bit floating point number\".into());\n\t\t\t};\n\n\t\t\tlet lng = if let Some(f) = parsed_input.get(\"lng\").and_then(|v| v.as_f64()) {\n\t\t\t\tf\n\t\t\t} else if let Some(s) = parsed_input.get(\"lng\").and_then(|v| v.as_str()) {\n\t\t\t\ts.parse::\u003cf64\u003e()\n\t\t\t\t\t.map_err(|e| format!(\"lng should be a valid number: {}\", e))?\n\t\t\t} else {\n\t\t\t\treturn Err(\"lng should be a 64-bit floating point number\".into());\n\t\t\t};\n\t\t\t(lat, lng)\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tlat = lat,\n\t\t\tlng = lng,\n\t\t\t\"Search coordinates\"\n\t\t);\n\n\t\tlet cities = parsed_input[\"cities\"]\n\t\t\t.as_array()\n\t\t\t.ok_or(\"cities should be an array of strings\")?\n\t\t\t.into_iter()\n\t\t\t.map(|v| v.as_str().ok_or(\"cities should be an array of strings\"))\n\t\t\t.collect::\u003cResult\u003cVec\u003c\u0026str\u003e, \u0026str\u003e\u003e()?;\n\n\t\tconst INCLUDE_TYPES_ERR: \u0026str = \"includedTypes should be an array of strings\";\n\t\tconst EXCLUDE_TYPES_ERR: \u0026str = \"excludedTypes should be an array of strings\";\n\t\tlet included_types = if !parsed_input[\"includedTypes\"].is_null() {\n\t\t\tparsed_input[\"includedTypes\"]\n\t\t\t\t.as_array()\n\t\t\t\t.ok_or(INCLUDE_TYPES_ERR)?\n\t\t\t\t.iter()\n\t\t\t\t.map(|v| v.as_str().ok_or(INCLUDE_TYPES_ERR))\n\t\t\t\t.collect::\u003cResult\u003c_, _\u003e\u003e()\n\t\t\t\t.map_err(|_| INCLUDE_TYPES_ERR)?\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\t\tlet excluded_types = if !parsed_input[\"excludedTypes\"].is_null() {\n\t\t\tparsed_input[\"excludedTypes\"]\n\t\t\t\t.as_array()\n\t\t\t\t.ok_or(EXCLUDE_TYPES_ERR)?\n\t\t\t\t.iter()\n\t\t\t\t.map(|v| v.as_str().ok_or(EXCLUDE_TYPES_ERR))\n\t\t\t\t.collect::\u003cResult\u003c_, _\u003e\u003e()\n\t\t\t\t.map_err(|_| EXCLUDE_TYPES_ERR)?\n\t\t} else {\n\t\t\tVec::new()\n\t\t};\n\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tincluded_types_count = included_types.len(),\n\t\t\texcluded_types_count = excluded_types.len(),\n\t\t\t\"Place type filters\"\n\t\t);\n\n\t\tdotenvy::dotenv().map_err(|_| \"Failed to load environment variables\")?;\n\t\tlet gm_api_key =\n\t\t\tstd::env::var(GOOGLE_MAPS_API_KEY).map_err(|_| \"GOOGLE_MAPS_API_KEY is not set\")?;\n\n\t\t// use google maps api to get nearby places\n\t\tlet gm_client = google_maps::Client::try_new(gm_api_key)\n\t\t\t.map_err(|_| \"Failed to create client for Google Maps API\")?;\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\"Calling Google Maps API\"\n\t\t);\n\n\t\t// Query DB and do nearby search concurrently\n\t\tlet nearby_search = async move |radius: f64| {\n\t\t\tlet search_res = gm_client\n\t\t\t\t.nearby_search((lat, lng, radius))\n\t\t\t\t.map_err(|e| e.to_string())?\n\t\t\t\t.field_mask(FieldMask::Specific(vec![\n\t\t\t\t\tField::PlacesAccessibilityOptions,\n\t\t\t\t\tField::PlacesAdrFormatAddress,\n\t\t\t\t\tField::PlacesDisplayName,\n\t\t\t\t\tField::PlacesId,\n\t\t\t\t\tField::PlacesPhotos,\n\t\t\t\t\tField::PlacesUtcOffsetMinutes,\n\t\t\t\t\tField::PlacesPriceLevel,\n\t\t\t\t\tField::PlacesRegularOpeningHours,\n\t\t\t\t\tField::PlacesWebsiteUri,\n\t\t\t\t\tField::PlacesServesVegetarianFood,\n\t\t\t\t\tField::PlacesTypes,\n\t\t\t\t\tField::PlacesPrimaryType,\n\t\t\t\t\tField::PlacesEditorialSummary,\n\t\t\t\t]))\n\t\t\t\t// pray to our lord and savior Terry Davis that this works\n\t\t\t\t.included_types(\n\t\t\t\t\tincluded_types\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|t| {\n\t\t\t\t\t\t\tPlaceType::deserialize(t.into_deserializer()).map_err(\n\t\t\t\t\t\t\t\t|_: serde::de::value::Error| \"Could not deserialize place type within includedTypes array\",\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n\t\t\t\t\t\t.map_err(|e| e.to_string())?,\n\t\t\t\t)\n\t\t\t\t.excluded_types(\n\t\t\t\t\texcluded_types\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|t| {\n\t\t\t\t\t\t\tPlaceType::deserialize(t.into_deserializer()).map_err(\n\t\t\t\t\t\t\t\t|_: serde::de::value::Error| \"Could not deserialize place type within excludedTypes array\",\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n\t\t\t\t\t\t.map_err(|e| e.to_string())?,\n\t\t\t\t)\n\t\t\t\t.execute()\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| e.to_string())?;\n\n\t\t\tif let Some(err) = search_res.error() {\n\t\t\t\tlet elapsed = start_time.elapsed();\n\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\tagent: \"research\",\n\t\t\t\t\ttool: \"nearby_search_tool\",\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tdetails: format!(\"{}ms - API error: {}\", elapsed.as_millis(), err)\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\terror = %err,\n\t\t\t\t\t\"Nearby search API error\"\n\t\t\t\t);\n\t\t\t\treturn Err(format!(\"Nearby Search failed - {err}\"));\n\t\t\t}\n\t\t\tlet places = search_res.places();\n\t\t\tif places.is_empty() {\n\t\t\t\tlet elapsed = start_time.elapsed();\n\t\t\t\tcrate::tool_trace!(\n\t\t\t\t\tagent: \"research\",\n\t\t\t\t\ttool: \"nearby_search_tool\",\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tdetails: format!(\"{}ms - No places found\", elapsed.as_millis())\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"research_tools\",\n\t\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\t\"No places found in nearby search\"\n\t\t\t\t);\n\t\t\t\treturn Err(format!(\"Nearby Search returned an empty array of places\").into());\n\t\t\t}\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"research_tools\",\n\t\t\t\ttool = \"nearby_search_tool\",\n\t\t\t\tplaces_count = places.len(),\n\t\t\t\t\"Found places from Google Maps\"\n\t\t\t);\n\t\t\tOk(places\n\t\t\t\t.into_iter()\n\t\t\t\t.map(|p| Event::from(p))\n\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e())\n\t\t};\n\n\t\t// Define a struct to capture the RETURNING clause results\n\t\t#[derive(FromRow)]\n\t\tstruct EventInsertResult {\n\t\t\tid: i32,\n\t\t\tevent_name: String,\n\t\t}\n\n\t\tlet (mut nearby_search_events, db_query_events) =\n\t\t\tif let Some(country) = parsed_input[\"country\"].as_str() {\n\t\t\t\tlet db_query_task = async move {\n\t\t\t\t\tlet mut qb = sqlx::QueryBuilder::new(\n\t\t\t\t\t\t\"SELECT id, event_name FROM events WHERE country ILIKE \",\n\t\t\t\t\t);\n\t\t\t\t\tqb.push_bind(country);\n\t\t\t\t\tlet mut separated = qb.separated(\" OR \");\n\t\t\t\t\tfor city in cities {\n\t\t\t\t\t\t// Add \"%\" wildcards here if needed\n\t\t\t\t\t\tseparated.push(\"city ILIKE \");\n\t\t\t\t\t\tseparated.push_bind(format!(\"%{}%\", city));\n\t\t\t\t\t}\n\t\t\t\t\tlet query = qb.build_query_as::\u003cEventInsertResult\u003e();\n\t\t\t\t\tquery.fetch_all(\u0026self.db).await\n\t\t\t\t};\n\n\t\t\t\tlet (nearby_search_50, nearby_search_10, db_query_task) = tokio::join!(\n\t\t\t\t\tnearby_search(50_000.),\n\t\t\t\t\tnearby_search(10_000.),\n\t\t\t\t\tdb_query_task\n\t\t\t\t);\n\t\t\t\tlet mut nearby_searches = nearby_search_50?;\n\t\t\t\tnearby_searches.append(\u0026mut nearby_search_10?);\n\t\t\t\t(nearby_searches, db_query_task?)\n\t\t\t} else {\n\t\t\t\tlet (nearby_search_50, nearby_search_10) =\n\t\t\t\t\ttokio::join!(nearby_search(50_000.), nearby_search(10_000.));\n\t\t\t\tlet mut nearby_searches = nearby_search_50?;\n\t\t\t\tnearby_searches.append(\u0026mut nearby_search_10?);\n\t\t\t\tlet len = nearby_searches.len();\n\t\t\t\t(nearby_searches, Vec::with_capacity(len))\n\t\t\t};\n\n\t\tnearby_search_events.sort_unstable_by(|a, b| a.place_id.cmp(\u0026b.place_id));\n\t\tnearby_search_events.dedup_by(|a, b| a.place_id == b.place_id);\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tevents_to_insert = nearby_search_events.len(),\n\t\t\t\"Inserting/updating events in database\"\n\t\t);\n\n\t\t// Use query! macro for compile-time type checking\n\t\t// Insert events one by one to use the type-safe macro\n\t\tlet mut results: Vec\u003cEventInsertResult\u003e = db_query_events;\n\t\tresults.reserve(nearby_search_events.len());\n\n\t\tfor ev in nearby_search_events.iter() {\n\t\t\tlet result = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO events (\n\t\t\t\t\tevent_name,\n\t\t\t\t\tevent_description,\n\t\t\t\t\tstreet_address,\n\t\t\t\t\tcity,\n\t\t\t\t\tcountry,\n\t\t\t\t\tpostal_code,\n\t\t\t\t\tlat,\n\t\t\t\t\tlng,\n\t\t\t\t\tevent_type,\n\t\t\t\t\tuser_created,\n\t\t\t\t\thard_start,\n\t\t\t\t\thard_end,\n\t\t\t\t\ttimezone,\n\t\t\t\t\tplace_id,\n\t\t\t\t\twheelchair_accessible_parking,\n\t\t\t\t\twheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom,\n\t\t\t\t\twheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food,\n\t\t\t\t\tprice_level,\n\t\t\t\t\tutc_offset_minutes,\n\t\t\t\t\twebsite_uri,\n\t\t\t\t\ttypes,\n\t\t\t\t\tphoto_name,\n\t\t\t\t\tphoto_width,\n\t\t\t\t\tphoto_height,\n\t\t\t\t\tphoto_author,\n\t\t\t\t\tphoto_author_uri,\n\t\t\t\t\tphoto_author_photo_uri,\n\t\t\t\t\tweekday_descriptions,\n\t\t\t\t\tsecondary_hours_type,\n\t\t\t\t\tnext_open_time,\n\t\t\t\t\tnext_close_time,\n\t\t\t\t\topen_now,\n\t\t\t\t\tperiods,\n\t\t\t\t\tspecial_days\n\t\t\t\t)\n\t\t\t\tVALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36)\n\t\t\t\tON CONFLICT (place_id) DO UPDATE SET\n\t\t\t\t\tevent_name = EXCLUDED.event_name,\n\t\t\t\t\tevent_description = EXCLUDED.event_description,\n\t\t\t\t\tstreet_address = EXCLUDED.street_address,\n\t\t\t\t\tcity = EXCLUDED.city,\n\t\t\t\t\tcountry = EXCLUDED.country,\n\t\t\t\t\tpostal_code = EXCLUDED.postal_code,\n\t\t\t\t\tlat = EXCLUDED.lat,\n\t\t\t\t\tlng = EXCLUDED.lng,\n\t\t\t\t\tevent_type = EXCLUDED.event_type,\n\t\t\t\t\tuser_created = EXCLUDED.user_created,\n\t\t\t\t\thard_start = EXCLUDED.hard_start,\n\t\t\t\t\thard_end = EXCLUDED.hard_end,\n\t\t\t\t\ttimezone = EXCLUDED.timezone,\n\t\t\t\t\twheelchair_accessible_parking = EXCLUDED.wheelchair_accessible_parking,\n\t\t\t\t\twheelchair_accessible_entrance = EXCLUDED.wheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom = EXCLUDED.wheelchair_accessible_restroom,\n\t\t\t\t\twheelchair_accessible_seating = EXCLUDED.wheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food = EXCLUDED.serves_vegetarian_food,\n\t\t\t\t\tprice_level = EXCLUDED.price_level,\n\t\t\t\t\tutc_offset_minutes = EXCLUDED.utc_offset_minutes,\n\t\t\t\t\twebsite_uri = EXCLUDED.website_uri,\n\t\t\t\t\ttypes = EXCLUDED.types,\n\t\t\t\t\tphoto_name = EXCLUDED.photo_name,\n\t\t\t\t\tphoto_width = EXCLUDED.photo_width,\n\t\t\t\t\tphoto_height = EXCLUDED.photo_height,\n\t\t\t\t\tphoto_author = EXCLUDED.photo_author,\n\t\t\t\t\tphoto_author_uri = EXCLUDED.photo_author_uri,\n\t\t\t\t\tphoto_author_photo_uri = EXCLUDED.photo_author_photo_uri,\n\t\t\t\t\tweekday_descriptions = EXCLUDED.weekday_descriptions,\n\t\t\t\t\tsecondary_hours_type = EXCLUDED.secondary_hours_type,\n\t\t\t\t\tnext_open_time = EXCLUDED.next_open_time,\n\t\t\t\t\tnext_close_time = EXCLUDED.next_close_time,\n\t\t\t\t\topen_now = EXCLUDED.open_now,\n\t\t\t\t\tperiods = EXCLUDED.periods,\n\t\t\t\t\tspecial_days = EXCLUDED.special_days\n\t\t\t\tRETURNING id, event_name\n\t\t\t\t\"#,\n\t\t\t\t\u0026ev.event_name,\n\t\t\t\tev.event_description.as_ref(),\n\t\t\t\tev.street_address.as_ref(),\n\t\t\t\tev.city.as_ref(),\n\t\t\t\tev.country.as_ref(),\n\t\t\t\tev.postal_code,\n\t\t\t\tev.lat,\n\t\t\t\tev.lng,\n\t\t\t\tev.event_type.as_ref(),\n\t\t\t\tev.user_created,\n\t\t\t\tev.hard_start,\n\t\t\t\tev.hard_end,\n\t\t\t\tev.timezone.as_ref(),\n\t\t\t\tev.place_id.as_ref(),\n\t\t\t\tev.wheelchair_accessible_parking,\n\t\t\t\tev.wheelchair_accessible_entrance,\n\t\t\t\tev.wheelchair_accessible_restroom,\n\t\t\t\tev.wheelchair_accessible_seating,\n\t\t\t\tev.serves_vegetarian_food,\n\t\t\t\tev.price_level,\n\t\t\t\tev.utc_offset_minutes,\n\t\t\t\tev.website_uri.as_ref(),\n\t\t\t\tev.types.as_ref(),\n\t\t\t\tev.photo_name.as_ref(),\n\t\t\t\tev.photo_width,\n\t\t\t\tev.photo_height,\n\t\t\t\tev.photo_author.as_ref(),\n\t\t\t\tev.photo_author_uri.as_ref(),\n\t\t\t\tev.photo_author_photo_uri.as_ref(),\n\t\t\t\tev.weekday_descriptions.as_ref(),\n\t\t\t\tev.secondary_hours_type,\n\t\t\t\tev.next_open_time,\n\t\t\t\tev.next_close_time,\n\t\t\t\tev.open_now,\n\t\t\t\t\u0026ev.periods as _,\n\t\t\t\t\u0026ev.special_days as _,\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.db)\n\t\t\t.await?;\n\n\t\t\tresults.push(EventInsertResult {\n\t\t\t\tid: result.id,\n\t\t\t\tevent_name: result.event_name,\n\t\t\t});\n\t\t}\n\n\t\tlet elapsed = start_time.elapsed();\n\n\t\t// Extract event IDs and names for the response and debugging\n\t\tresults.sort_unstable_by(|a, b| a.id.cmp(\u0026b.id));\n\t\tresults.dedup_by(|a, b| a.id == b.id);\n\t\tlet event_ids: Vec\u003ci32\u003e = results.iter().map(|r| r.id).collect();\n\t\tlet event_names: Vec\u003cString\u003e = results.iter().map(|r| r.event_name.clone()).collect();\n\n\t\t// Return only the IDs to keep the context window clean\n\t\tlet result = json!({\n\t\t\t\"event_ids\": event_ids,\n\t\t\t\"count\": event_ids.len()\n\t\t});\n\n\t\tinfo!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tevents_count = event_ids.len(),\n\t\t\tevent_ids = ?event_ids,\n\t\t\t\"Nearby search completed successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"research_tools\",\n\t\t\ttool = \"nearby_search_tool\",\n\t\t\tevents_sample = %serde_json::to_string(\u0026results.iter().take(3).map(|r| json!({\"id\": r.id, \"name\": \u0026r.event_name})).collect::\u003cVec\u003c_\u003e\u003e()).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\"Sample of events (first 3)\"\n\t\t);\n\n\t\tcrate::tool_trace!(\n\t\t\tagent: \"research\",\n\t\t\ttool: \"nearby_search_tool\",\n\t\t\tstatus: \"success\",\n\t\t\tdetails: format!(\"{}ms - {} events - [{}]\", elapsed.as_millis(), event_ids.len(), event_names.join(\", \"))\n\t\t);\n\n\t\tOk(result.to_string())\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","task.rs"],"content":"/*\n * src/agent/tools/task.rs\n *\n * Task Agent Tools Implementation - context and intent helpers\n *\n * These tools are focused on:\n * - retrieving user profile\n * - retrieving chat history/context\n * - parsing user intent\n * - asking for clarification when information is missing\n * - responding to the user\n *\n * They are used by the Task Agent and are intentionally kept separate\n * from the Orchestrator-specific tools.\n */\n\nuse crate::agent::models::context::{ContextData, SharedContextStore};\nuse crate::agent::models::user::UserIntent;\nuse crate::agent::tools::orchestrator::track_tool_execution;\nuse crate::controllers::itinerary::insert_event_list;\nuse crate::http_models::itinerary::Itinerary as HttpItinerary;\nuse crate::sql_models::LlmProgress;\nuse async_trait::async_trait;\nuse chrono::Datelike;\nuse langchain_rust::language_models::llm::LLM;\nuse langchain_rust::tools::Tool;\nuse serde_json::{Value, json};\nuse sqlx::PgPool;\nuse std::error::Error;\nuse std::sync::Arc;\nuse std::sync::atomic::{AtomicI32, Ordering};\nuse std::time::Instant;\nuse tracing::{debug, info};\n\n/// Tool 1: Parse User Intent\n/// Parses user input to extract intent, destination, dates, budget, and constraints.\n/// Returns a UserIntent object.\n#[derive(Clone)]\npub struct ParseUserIntentTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl ParseUserIntentTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for ParseUserIntentTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"parse_user_intent\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Parses user input using an LLM to extract intent, destination, dates, budget, preferences, and constraints. Returns a UserIntent object with constraints array that should be stored in context for other agents to access. IMPORTANT: If you have retrieved chat context, include the recent conversation history in your analysis to extract information from previous messages.\"\n             .to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"user_message\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"The raw user message to parse. If you have conversation history from retrieve_chat_context, include the recent messages (last 3-5 exchanges) as context in this field to help extract information from previous messages.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": [\"user_message\"]\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"parse_user_intent\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in parse_user_intent\"\n\t\t);\n\n\t\t// Handle user_message as string or object (convert object to string)\n\t\tlet user_message = if let Some(s) = input[\"user_message\"].as_str() {\n\t\t\ts.to_string()\n\t\t} else if input[\"user_message\"].is_object() {\n\t\t\tserde_json::to_string(\u0026input[\"user_message\"])?\n\t\t} else {\n\t\t\tinput[\"user_message\"].to_string()\n\t\t};\n\n\t\tlet prompt = format!(\n\t\t\tr#\"Extract travel planning information from the user's conversation history.\n\nCRITICAL: You will receive either:\n1. A JSON string containing a chat_history array with role/content messages\n2. A JSON object with destination/dates/budget fields that you should parse\n3. Plain text describing the travel request\n\nYour job is to extract ALL information mentioned in ANY format.\n\nUser input: {}\n\nExtract the following information and return ONLY a valid JSON object with these fields:\n{{\n  \"action\": \"create_itinerary\" | \"modify_itinerary\" | \"query\" | \"other\",\n  \"destination\": string or null (extract from ANY field - look for country/city names like \"brazil\", \"paris\", \"destination\", etc.),\n  \"start_date\": string or null (ISO format YYYY-MM-DD if mentioned - look in \"dates\", \"start_date\", or message content),\n  \"end_date\": string or null (ISO format YYYY-MM-DD if mentioned - look in \"dates\", \"end_date\", or message content),\n  \"budget\": number or null (total budget in USD - look in \"budget\" field or dollar amounts in messages. Use midpoint for ranges like \"20-30\"),\n  \"preferences\": [array of strings - look in \"preferences\" field or message content for activities, interests],\n  \"constraints\": [array of strings - dietary restrictions, accessibility needs found anywhere],\n  \"missing_info\": [array of strings - list ONLY what is truly missing. If destination/dates/budget appear ANYWHERE, they are NOT missing]\n}}\n\nRules:\n- If input has a \"chat_history\" array, read ALL messages in it\n- If input has direct fields like \"destination\", \"dates\", \"budget\", extract those\n- If input is plain text, parse it directly\n- For \"july 20-30th\" or \"june 10-20\", extract as start_date \"2026-07-20\" and end_date \"2026-07-30\" (year 2026 since we're in Dec 2025)\n- For budget ranges like \"20-30 dollars\", use the midpoint: 25\n- If preferences say \"no preferences\" or similar, use empty array but don't list it as missing\n- missing_info should ONLY contain items that are completely absent from the input\n\nReturn ONLY the JSON object, no other text.\"#,\n\t\t\tuser_message\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\n\t\t// Clean up the response - remove markdown code blocks if present\n\t\tlet cleaned = response\n\t\t\t.trim()\n\t\t\t.trim_start_matches(\"```json\")\n\t\t\t.trim_start_matches(\"```\")\n\t\t\t.trim_end_matches(\"```\")\n\t\t\t.trim();\n\n\t\t// Validate it's proper JSON and return as UserIntent\n\t\tlet intent: UserIntent = serde_json::from_str(cleaned).map_err(|e| {\n\t\t\tformat!(\n\t\t\t\t\"Failed to parse LLM response as JSON: {}. Response was: {}\",\n\t\t\t\te, cleaned\n\t\t\t)\n\t\t})?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\taction = %intent.action,\n\t\t\tdestination = ?intent.destination,\n\t\t\tstart_date = ?intent.start_date,\n\t\t\tend_date = ?intent.end_date,\n\t\t\tbudget = ?intent.budget,\n\t\t\tpreferences_count = intent.preferences.len(),\n\t\t\tconstraints_count = intent.constraints.len(),\n\t\t\tmissing_info = ?intent.missing_info,\n\t\t\t\"Parsed user intent successfully\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\tintent = %serde_json::to_string(\u0026intent)?,\n\t\t\t\"Full parsed intent\"\n\t\t);\n\n\t\t// Return serialized UserIntent\n\t\tlet result = serde_json::to_string(\u0026intent)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"parse_user_intent\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"parse_user_intent\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool 2: Retrieve Chat Context\n/// Retrieves chat history and context for the current conversation.\n/// Returns a vector of Message objects.\n#[derive(Clone)]\npub struct RetrieveChatContextTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RetrieveChatContextTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RetrieveChatContextTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"retrieve_chat_context\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Retrieves chat history and context for the current conversation.\".to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, _input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = _input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"retrieve_chat_context\", status: \"start\");\n\n\t\t// Get chat_session_id from shared atomic (set by controller before agent invocation)\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"Retrieving chat context\"\n\t\t);\n\n\t\t// Query database for chat history\n\t\tlet messages = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tm.id,\n\t\t\t\tm.is_user,\n\t\t\t\tm.timestamp,\n\t\t\t\tm.text,\n\t\t\t\tm.itinerary_id\n\t\t\tFROM messages m\n\t\t\tWHERE m.chat_session_id = $1\n\t\t\tORDER BY m.timestamp ASC\n\t\t\tLIMIT 50\n\t\t\t\"#,\n\t\t\tchat_id\n\t\t)\n\t\t.fetch_all(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tlet chat_history: Vec\u003cValue\u003e = messages\n\t\t\t.into_iter()\n\t\t\t.map(|msg| {\n\t\t\t\tjson!({\n\t\t\t\t\t\"id\": msg.id,\n\t\t\t\t\t\"role\": if msg.is_user { \"user\" } else { \"assistant\" },\n\t\t\t\t\t\"content\": msg.text,\n\t\t\t\t\t\"timestamp\": msg.timestamp.format(\"%Y-%m-%dT%H:%M:%S%.fZ\").to_string(),\n\t\t\t\t\t\"itinerary_id\": msg.itinerary_id\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect();\n\n\t\t// Retrieve or initialize in-memory context (includes pipeline state and events)\n\t\tlet mut store_guard = self.context_store.write().await;\n\t\tlet context_data = match store_guard.get_mut(\u0026chat_id) {\n\t\t\tSome(ctx) =\u003e ctx,\n\t\t\tNone =\u003e {\n\t\t\t\t// Context doesn't exist - create it\n\t\t\t\tstore_guard.insert(\n\t\t\t\t\tchat_id,\n\t\t\t\t\tContextData {\n\t\t\t\t\t\tchat_session_id: chat_id,\n\t\t\t\t\t\tuser_id: 0,\n\t\t\t\t\t\tuser_profile: None,\n\t\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\t\tevents: vec![],\n\t\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\t\tconstraints: vec![],\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\tstore_guard.get_mut(\u0026chat_id).unwrap()\n\t\t\t}\n\t\t};\n\n\t\t// Update chat_history with the messages we just retrieved\n\t\tcontext_data.chat_history = chat_history.clone();\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tchat_id = chat_id,\n\t\t\tchat_history_count = context_data.chat_history.len(),\n\t\t\tpipeline_stage = ?context_data.pipeline_stage,\n\t\t\tevents_count = context_data.events.len(),\n\t\t\tconstraints_count = context_data.constraints.len(),\n\t\t\t\"Retrieved chat context\"\n\t\t);\n\n\t\tlet result = serde_json::to_string(\u0026context_data.clone())?;\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\tcontext = %result,\n\t\t\t\"Full context data\"\n\t\t);\n\n\t\t// Log trip_context specifically for debugging\n\t\tif let Ok(context_obj) = serde_json::from_str::\u003cValue\u003e(\u0026result) {\n\t\t\tif let Some(trip_ctx) = context_obj.get(\"trip_context\") {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"retrieve_chat_context\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"Retrieved trip_context from database\",\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttrip_context = %serde_json::to_string_pretty(\u0026trip_ctx).unwrap_or_else(|_| \"error\".to_string()),\n\t\t\t\t\t\"Trip context at retrieve_chat_context\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Return full context including pipeline state\n\t\tdrop(store_guard);\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_chat_context\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tchat_history_count = chat_history.len(),\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"retrieve_chat_context\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool 3: Retrieve User Profile\n/// Retrieves user profile information including preferences and past trips.\n/// Returns a UserProfile object.\n#[derive(Clone)]\npub struct RetrieveUserProfileTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RetrieveUserProfileTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tuser_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tuser_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RetrieveUserProfileTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"retrieve_user_profile\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Retrieves user profile information including preferences and past trips. Automatically uses the logged-in user's ID.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"retrieve_user_profile\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_user_profile\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in retrieve_user_profile\"\n\t\t);\n\n\t\t// Get chat_session_id from atomic\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\t// Get user_id from context (safer than atomics - no race conditions)\n\t\tlet user_id = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tstore_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.map(|ctx| ctx.user_id)\n\t\t\t\t.unwrap_or(0)\n\t\t};\n\n\t\tif user_id == 0 {\n\t\t\t// In some flows (e.g., tests or unauthenticated calls) we may not have\n\t\t\t// a user_id. Treat this as \"no profile available\" instead of a hard\n\t\t\t// error so the Task Agent can still proceed and rely on chat history.\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\t\"User ID not set in context; proceeding with empty profile\"\n\t\t\t);\n\n\t\t\tlet empty_profile = json!({\n\t\t\t\t\"user_id\": null,\n\t\t\t\t\"email\": null,\n\t\t\t\t\"first_name\": null,\n\t\t\t\t\"last_name\": null,\n\t\t\t\t\"budget_preference\": null,\n\t\t\t\t\"risk_preference\": null,\n\t\t\t\t\"food_allergies\": \"\",\n\t\t\t\t\"disabilities\": \"\"\n\t\t\t});\n\n\t\t\t// Save empty profile into in-memory context for this chat (if any)\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.user_profile = Some(empty_profile.clone());\n\t\t\t}\n\n\t\t\tlet result = serde_json::to_string(\u0026empty_profile)?;\n\n\t\t\tlet elapsed = start_time.elapsed();\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\t\"Tool completed (no user logged in)\"\n\t\t\t);\n\n\t\t\ttrack_tool_execution(\n\t\t\t\t\u0026self.context_store,\n\t\t\t\t\u0026self.chat_session_id,\n\t\t\t\t\"retrieve_user_profile\",\n\t\t\t\t\u0026input_clone,\n\t\t\t\t\u0026result,\n\t\t\t)\n\t\t\t.await?;\n\n\t\t\treturn Ok(result);\n\t\t}\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"retrieve_user_profile\", user_id = user_id, \"Retrieving user profile\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"retrieve_user_profile\", input = %serde_json::to_string(\u0026input)?, \"Tool input\");\n\n\t\t// Query database for user profile\n\t\tuse crate::sql_models::{BudgetBucket, RiskTolerence};\n\t\tlet account = sqlx::query_as!(\n\t\t\tcrate::http_models::account::CurrentResponse,\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\temail,\n\t\t\t\tfirst_name,\n\t\t\t\tlast_name,\n\t\t\t\tbudget_preference as \"budget_preference: BudgetBucket\",\n\t\t\t\trisk_preference as \"risk_preference: RiskTolerence\",\n\t\t\t\tCOALESCE(food_allergies, '') as \"food_allergies!: String\",\n\t\t\t\tCOALESCE(disabilities, '') as \"disabilities!: String\",\n\t\t\t\tCOALESCE(profile_picture, '') as \"profile_picture!: String\"\n\t\t\tFROM accounts\n\t\t\tWHERE id = $1\n\t\t\t\"#,\n\t\t\tuser_id\n\t\t)\n\t\t.fetch_optional(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tlet profile = if let Some(acc) = account {\n\t\t\tjson!({\n\t\t\t\t\"user_id\": user_id,\n\t\t\t\t\"email\": acc.email,\n\t\t\t\t\"first_name\": acc.first_name,\n\t\t\t\t\"last_name\": acc.last_name,\n\t\t\t\t\"budget_preference\": acc.budget_preference,\n\t\t\t\t\"risk_preference\": acc.risk_preference,\n\t\t\t\t\"food_allergies\": acc.food_allergies,\n\t\t\t\t\"disabilities\": acc.disabilities\n\t\t\t})\n\t\t} else {\n\t\t\treturn Err(format!(\"User with id {} not found\", user_id).into());\n\t\t};\n\n\t\t// Automatically save user profile to in-memory context AND pre-fill trip context\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id != 0 {\n\t\t\t// Get existing in-memory context\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.user_profile = Some(profile.clone());\n\n\t\t\t\t// Pre-fill trip_context constraints from user profile\n\t\t\t\tlet mut constraints = Vec::new();\n\n\t\t\t\t// Add food allergies as constraints\n\t\t\t\tif let Some(allergies) = profile.get(\"food_allergies\").and_then(|v| v.as_str()) {\n\t\t\t\t\tif !allergies.is_empty() {\n\t\t\t\t\t\tfor allergy in allergies.split(',') {\n\t\t\t\t\t\t\tlet allergy_trimmed = allergy.trim();\n\t\t\t\t\t\t\tif !allergy_trimmed.is_empty() {\n\t\t\t\t\t\t\t\tconstraints.push(format!(\"No {}\", allergy_trimmed));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add disabilities as constraints\n\t\t\t\tif let Some(disabilities) = profile.get(\"disabilities\").and_then(|v| v.as_str()) {\n\t\t\t\t\tif !disabilities.is_empty() {\n\t\t\t\t\t\tconstraints\n\t\t\t\t\t\t\t.push(format!(\"Wheelchair accessible required: {}\", disabilities));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Store constraints in trip_context\n\t\t\t\tcontext_data.trip_context.constraints = constraints.clone();\n\n\t\t\t\t// Also store in the legacy constraints field for backward compatibility\n\t\t\t\tcontext_data.constraints = constraints;\n\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\tuser_id = user_id,\n\t\t\t\t\tconstraints_count = context_data.trip_context.constraints.len(),\n\t\t\t\t\t\"Saved user profile to context and pre-filled trip constraints\"\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"retrieve_user_profile\",\n\t\t\t\t\tconstraints = ?context_data.trip_context.constraints,\n\t\t\t\t\t\"Pre-filled constraints from user profile\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tlet result = serde_json::to_string(\u0026profile)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"retrieve_user_profile\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tuser_id = user_id,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"retrieve_user_profile\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Ask for Clarification\n/// Generates a natural clarification question using an LLM when user input is ambiguous.\n/// STOPS THE PIPELINE by inserting the clarification message into the chat and returning success.\n#[derive(Clone)]\npub struct AskForClarificationTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl AskForClarificationTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for AskForClarificationTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"ask_for_clarification\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"STOPS THE PIPELINE by generating a natural, human-readable clarification question and sending it to the user. This tool inserts a message into the chat and returns the readable question text. Use this when critical information is missing. CRITICAL STOPPING RULE: After calling this tool, you MUST immediately return 'Final Answer' with the EXACT text returned by this tool. DO NOT call this tool again. DO NOT call any other tools. DO NOT call retrieve_chat_context or parse_user_intent after this. The tool returns ONLY the readable question text - use that EXACT text as your Final Answer. This is your FINAL response to the user - stop immediately after receiving the tool response. Always provide the missing_info parameter as a JSON string array (e.g., '[\\\"destination\\\", \\\"dates\\\", \\\"budget\\\"]'). If missing_info is not provided, the tool will use default common missing information.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tlet params = json!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"missing_info\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Array of strings describing what information is missing, as a JSON string. Example: '[\\\"destination\\\", \\\"dates\\\", \\\"budget\\\"]'. If you have an array, serialize it to JSON first.\"\n\t\t\t\t},\n\t\t\t\t\"context\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Additional context about the conversation as a JSON string. Optional.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t});\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tparameters = %serde_json::to_string(\u0026params).unwrap_or_else(|_| \"failed\".to_string()),\n\t\t\t\"Tool parameters schema\"\n\t\t);\n\t\tparams\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"ask_for_clarification\", status: \"start\");\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in ask_for_clarification\"\n\t\t);\n\n\t\t// langchain_rust passes action_input as a STRING, so we need to parse it first\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle missing_info - can be array, string, object, or missing\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tmissing_info_type = ?parsed_input.get(\"missing_info\").map(|v| {\n\t\t\t\tif v.is_array() { \"array\" }\n\t\t\t\telse if v.is_string() { \"string\" }\n\t\t\t\telse if v.is_object() { \"object\" }\n\t\t\t\telse { \"other\" }\n\t\t\t}),\n\t\t\tmissing_info_value = ?parsed_input.get(\"missing_info\"),\n\t\t\t\"Processing missing_info\"\n\t\t);\n\n\t\t// missing_info should be a JSON string, but handle all cases for robustness\n\t\tlet missing_info: Vec\u003cString\u003e = if let Some(s) = parsed_input[\"missing_info\"].as_str() {\n\t\t\t// Try to parse as JSON array first\n\t\t\tif let Ok(parsed) = serde_json::from_str::\u003cVec\u003cString\u003e\u003e(s) {\n\t\t\t\tparsed\n\t\t\t} else {\n\t\t\t\t// If not valid JSON, treat as single string\n\t\t\t\tvec![s.to_string()]\n\t\t\t}\n\t\t} else if let Some(arr) = parsed_input[\"missing_info\"].as_array() {\n\t\t\t// Fallback: if somehow we get an array directly\n\t\t\tarr.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t.collect()\n\t\t} else if parsed_input[\"missing_info\"].is_object() {\n\t\t\t// If it's an object, try to find an array field in it\n\t\t\tparsed_input[\"missing_info\"]\n\t\t\t\t.get(\"missing_info\")\n\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t\t.map(|arr| {\n\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t\t\t.collect()\n\t\t\t\t})\n\t\t\t\t.or_else(|| {\n\t\t\t\t\t// Try other common field names\n\t\t\t\t\tparsed_input[\"missing_info\"]\n\t\t\t\t\t\t.get(\"items\")\n\t\t\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t\t\t\t.map(|arr| {\n\t\t\t\t\t\t\tarr.iter()\n\t\t\t\t\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t\t\t\t\t.collect()\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or_else(|| {\n\t\t\t\t\tvec![\n\t\t\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\t\t\"dates\".to_string(),\n\t\t\t\t\t\t\"budget\".to_string(),\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t} else if parsed_input.get(\"missing_info\").is_some() {\n\t\t\t// Some other type - use defaults\n\t\t\tvec![\n\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\"dates\".to_string(),\n\t\t\t\t\"budget\".to_string(),\n\t\t\t]\n\t\t} else {\n\t\t\t// If missing_info is not provided at all, use default common missing information\n\t\t\t// This prevents the tool from failing and allows the agent to continue\n\t\t\tinfo!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", \"missing_info not provided, using defaults\");\n\t\t\tvec![\n\t\t\t\t\"destination\".to_string(),\n\t\t\t\t\"travel dates\".to_string(),\n\t\t\t\t\"budget\".to_string(),\n\t\t\t\t\"preferences\".to_string(),\n\t\t\t]\n\t\t};\n\n\t\t// Handle context - can be string (JSON), object, or missing\n\t\tlet context = parsed_input.get(\"context\").unwrap_or(\u0026Value::Null);\n\t\tlet context_str = if let Some(s) = context.as_str() {\n\t\t\t// If it's a string, check if it's JSON, otherwise use as-is\n\t\t\tif serde_json::from_str::\u003cValue\u003e(s).is_ok() {\n\t\t\t\ts.to_string()\n\t\t\t} else {\n\t\t\t\ts.to_string()\n\t\t\t}\n\t\t} else if context.is_object() {\n\t\t\tserde_json::to_string(context).unwrap_or_else(|_| \"{}\".to_string())\n\t\t} else {\n\t\t\t\"\".to_string()\n\t\t};\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", missing_info_count = missing_info.len(), \"Asking for clarification\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"ask_for_clarification\", input = %serde_json::to_string(\u0026parsed_input)?, \"Tool input\");\n\n\t\t// Retrieve chat context to extract known information\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\t// ANTI-LOOP PROTECTION: Check if we've already asked for clarification\n\t\t// If asked_clarification flag is already true in trip context, we should NOT ask again\n\t\t{\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tif let Some(context_data) = store_guard.get(\u0026chat_id) {\n\t\t\t\tif context_data.trip_context.asked_clarification {\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\t\t\ttool = \"ask_for_clarification\",\n\t\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\t\"Already asked for clarification before - returning ready signal to prevent loop\"\n\t\t\t\t\t);\n\t\t\t\t\t// Return a signal that tells the agent we're ready to proceed\n\t\t\t\t\treturn Ok(\"Ready for research pipeline.\".to_string());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get chat history to extract known information\n\t\tlet messages = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT\n\t\t\t\tm.id,\n\t\t\t\tm.is_user,\n\t\t\t\tm.timestamp,\n\t\t\t\tm.text,\n\t\t\t\tm.itinerary_id\n\t\t\tFROM messages m\n\t\t\tWHERE m.chat_session_id = $1\n\t\t\tORDER BY m.timestamp ASC\n\t\t\tLIMIT 50\n\t\t\t\"#,\n\t\t\tchat_id\n\t\t)\n\t\t.fetch_all(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t// Extract known information from chat history and in-memory context\n\t\tlet mut known_info: Vec\u003cString\u003e = Vec::new();\n\t\tlet chat_text = messages\n\t\t\t.iter()\n\t\t\t.filter(|m| m.is_user)\n\t\t\t.map(|m| m.text.as_str())\n\t\t\t.collect::\u003cVec\u003c\u0026str\u003e\u003e()\n\t\t\t.join(\" \");\n\n\t\t// Try to extract from chat history using simple patterns\n\t\tif known_info.is_empty() {\n\t\t\tlet chat_lower = chat_text.to_lowercase();\n\n\t\t\t// Check for destination (common country/city names)\n\t\t\tlet destinations = vec![\n\t\t\t\t\"brazil\",\n\t\t\t\t\"paris\",\n\t\t\t\t\"tokyo\",\n\t\t\t\t\"london\",\n\t\t\t\t\"new york\",\n\t\t\t\t\"rome\",\n\t\t\t\t\"barcelona\",\n\t\t\t\t\"amsterdam\",\n\t\t\t\t\"berlin\",\n\t\t\t\t\"dubai\",\n\t\t\t\t\"singapore\",\n\t\t\t\t\"sydney\",\n\t\t\t\t\"mumbai\",\n\t\t\t\t\"bangkok\",\n\t\t\t];\n\t\t\tfor dest in destinations {\n\t\t\t\tif chat_lower.contains(dest) {\n\t\t\t\t\tknown_info.push(format!(\n\t\t\t\t\t\t\"Destination: {}\",\n\t\t\t\t\t\tdest.split_whitespace()\n\t\t\t\t\t\t\t.next()\n\t\t\t\t\t\t\t.unwrap_or(dest)\n\t\t\t\t\t\t\t.to_uppercase()\n\t\t\t\t\t));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for budget (numbers with $ or dollar/buck keywords)\n\t\t\tif chat_lower.contains(\"$\")\n\t\t\t\t|| chat_lower.contains(\"dollar\")\n\t\t\t\t|| chat_lower.contains(\"budget\")\n\t\t\t\t|| chat_lower.contains(\"buck\")\n\t\t\t{\n\t\t\t\tlet words: Vec\u003c\u0026str\u003e = chat_text.split_whitespace().collect();\n\t\t\t\tfor (i, word) in words.iter().enumerate() {\n\t\t\t\t\tlet word_lower = word.to_lowercase();\n\t\t\t\t\tif word_lower.contains(\"$\")\n\t\t\t\t\t\t|| word_lower.contains(\"dollar\")\n\t\t\t\t\t\t|| word_lower.contains(\"budget\")\n\t\t\t\t\t\t|| word_lower.contains(\"buck\")\n\t\t\t\t\t{\n\t\t\t\t\t\t// Look for numbers nearby\n\t\t\t\t\t\tfor j in i.saturating_sub(2)..(i + 3).min(words.len()) {\n\t\t\t\t\t\t\tif words[j].chars().any(|c| c.is_numeric()) {\n\t\t\t\t\t\t\t\tknown_info.push(format!(\"Budget: {}\", words[j]));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check for dates (months or date patterns)\n\t\t\tlet months = vec![\n\t\t\t\t\"january\",\n\t\t\t\t\"february\",\n\t\t\t\t\"march\",\n\t\t\t\t\"april\",\n\t\t\t\t\"may\",\n\t\t\t\t\"june\",\n\t\t\t\t\"july\",\n\t\t\t\t\"august\",\n\t\t\t\t\"september\",\n\t\t\t\t\"october\",\n\t\t\t\t\"november\",\n\t\t\t\t\"december\",\n\t\t\t];\n\t\t\tfor month in months {\n\t\t\t\tif chat_lower.contains(month) {\n\t\t\t\t\tknown_info.push(format!(\"Dates: mentioned in conversation\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet known_info_str = if known_info.is_empty() {\n\t\t\t\"None yet\".to_string()\n\t\t} else {\n\t\t\tknown_info.join(\", \")\n\t\t};\n\t\tlet missing_info_str = missing_info.join(\", \");\n\n\t\tlet prompt = format!(\n\t\t\tr#\"Generate a friendly, natural clarification message for a travel planning conversation.\n\nIMPORTANT: You must show the user what information you already have and what you still need.\n\nInformation I Already Have:\n{}\n\nInformation I Still Need:\n{}\n\nConversation Context: {}\n\nCreate a friendly message that:\n1. Acknowledges what information you already have (if any)\n2. Clearly states what information is still needed to create the itinerary\n3. Asks for the missing information in a natural, conversational way\n\nFormat your response as a complete message that shows both what you know and what you need.\nExample: \"Great! I see you're planning a trip to [destination]. To create your itinerary, I still need to know [missing info]. Could you share [specific questions]?\"\n\nReturn ONLY the message text, nothing else.\"#,\n\t\t\tknown_info_str, missing_info_str, context_str\n\t\t);\n\n\t\tlet response = self.llm.invoke(\u0026prompt).await?;\n\t\tlet clarification = response.trim().to_string();\n\n\t\t// Insert the clarification message into the database to stop the pipeline\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\tchat_id,\n\t\t\tclarification\n\t\t)\n\t\t.fetch_one(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tchat_id = chat_id,\n\t\t\tmessage_id = record.id,\n\t\t\t\"Clarification message sent - pipeline stopped\"\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\tclarification = %clarification,\n\t\t\t\"Tool output\"\n\t\t);\n\n\t\t// Mark that we've asked for clarification in the trip context\n\t\t{\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.trip_context.asked_clarification = true;\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"ask_for_clarification\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"Marked asked_clarification flag in trip context\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Return the clarification text directly.\n\t\t// The message is already inserted in the database with the ID in record.id\n\t\t// The agent prompt instructs to use this as Final Answer immediately.\n\t\tlet result = clarification.clone();\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"ask_for_clarification\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed - pipeline stopped\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"ask_for_clarification\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Respond to User\n/// Sends a response to the user with the current itinerary (if available) or asks for more information.\n/// This tool STOPS the pipeline and sends the final message to the user.\n#[derive(Clone)]\npub struct RespondToUserTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl RespondToUserTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for RespondToUserTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"respond_to_user\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"STOPS THE PIPELINE and sends a response to the user. If active_itinerary exists in context, creates/updates the itinerary in the database and sends it to the user. If active_itinerary is empty or missing, sends a message asking for more information. This tool inserts a message into the chat and returns a success message. CRITICAL: After calling this tool, you MUST immediately return 'Final Answer' with a confirmation. DO NOT call any other tools. Use this as your final action when ready to respond to the user.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {\n\t\t\t\t\"message\": {\n\t\t\t\t\t\"type\": \"string\",\n\t\t\t\t\t\"description\": \"Optional message to send to the user as a string. If not provided, will generate based on itinerary status.\"\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone(); // Clone for tracking\n\n\t\tcrate::tool_trace!(agent: \"orchestrator\", tool: \"respond_to_user\", status: \"start\");\n\n\t\t// Update progress to FinalizingItinerary\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id \u003e 0 {\n\t\t\t_ = sqlx::query!(\n\t\t\t\tr#\"UPDATE chat_sessions\n\t\t\t\tSET llm_progress=$1\n\t\t\t\tWHERE id=$2;\"#,\n\t\t\t\tLlmProgress::FinalizingItinerary as _,\n\t\t\t\tchat_id\n\t\t\t)\n\t\t\t.execute(\u0026self.pool)\n\t\t\t.await;\n\t\t}\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"respond_to_user\",\n\t\t\tinput_raw = %serde_json::to_string(\u0026input).unwrap_or_else(|_| \"failed to serialize\".to_string()),\n\t\t\t\"Received input in respond_to_user\"\n\t\t);\n\n\t\t// Get chat_session_id from shared atomic (set by controller before agent invocation)\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set. This should be set by the controller before invoking the agent.\".into());\n\t\t}\n\n\t\t// langchain_rust passes action_input as a STRING, so we need to parse it first\n\t\tlet parsed_input: Value = if input.is_string() {\n\t\t\t// If input is a string (JSON string from action_input), parse it\n\t\t\tserde_json::from_str(input.as_str().unwrap_or(\"{}\")).unwrap_or_else(|_| json!({}))\n\t\t} else {\n\t\t\t// If it's already a Value object, use it directly\n\t\t\tinput\n\t\t};\n\n\t\t// Handle message as either string or object (convert object to string)\n\t\tlet optional_message = parsed_input.get(\"message\").map(|m| {\n\t\t\tif m.is_string() {\n\t\t\t\tm.as_str().unwrap_or(\"\").to_string()\n\t\t\t} else if m.is_object() {\n\t\t\t\tserde_json::to_string(m).unwrap_or_else(|_| \"{}\".to_string())\n\t\t\t} else {\n\t\t\t\tm.to_string()\n\t\t\t}\n\t\t});\n\n\t\tinfo!(target: \"orchestrator_tool\", tool = \"respond_to_user\", chat_id = chat_id, \"Responding to user - pipeline stopped\");\n\t\tdebug!(target: \"orchestrator_tool\", tool = \"respond_to_user\", input = %serde_json::to_string(\u0026parsed_input)?, \"Tool input\");\n\n\t\t// Get context to check for active_itinerary\n\t\tlet store_guard = self.context_store.read().await;\n\t\tlet context_data = store_guard\n\t\t\t.get(\u0026chat_id)\n\t\t\t.cloned()\n\t\t\t.unwrap_or_else(|| ContextData {\n\t\t\t\tchat_session_id: chat_id,\n\t\t\t\tuser_id: 0,\n\t\t\t\tuser_profile: None,\n\t\t\t\tchat_history: vec![],\n\t\t\t\ttrip_context: crate::agent::models::context::TripContext::default(),\n\t\t\t\tactive_itinerary: None,\n\t\t\t\tevents: vec![],\n\t\t\t\ttool_history: vec![],\n\t\t\t\tpipeline_stage: None,\n\t\t\t\tresearched_events: vec![],\n\t\t\t\tconstrained_events: vec![],\n\t\t\t\toptimized_events: vec![],\n\t\t\t\tconstraints: vec![],\n\t\t\t});\n\n\t\t// Check if we have an active itinerary\n\t\tlet has_itinerary = context_data.active_itinerary.is_some()\n\t\t\t\u0026\u0026 context_data\n\t\t\t\t.active_itinerary\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|it| {\n\t\t\t\t\t// Check if itinerary is not empty (has some structure)\n\t\t\t\t\t!it.is_null() \u0026\u0026 (!it.is_object() || !it.as_object().unwrap().is_empty())\n\t\t\t\t})\n\t\t\t\t.unwrap_or(false);\n\n\t\tlet (message_text, message_id) = if has_itinerary {\n\t\t\t// Parse and save the itinerary to database\n\t\t\tlet itinerary_json = context_data.active_itinerary.clone().unwrap();\n\n\t\t\t// Get user_id from chat_session\n\t\t\tlet user_id = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\tSELECT cs.account_id\n\t\t\tFROM chat_sessions cs\n\t\t\tWHERE cs.id = $1\n\t\t\t\"#,\n\t\t\t\tchat_id\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Failed to get user_id from chat_session: {}\", e))?\n\t\t\t.account_id;\n\n\t\t\t// Extract event IDs from the LLM-generated itinerary\n\t\t\tlet mut all_event_ids = Vec::new();\n\t\t\tif let Some(event_days) = itinerary_json.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\t\tfor day in event_days {\n\t\t\t\t\tfor time_block in \u0026[\"morning_events\", \"afternoon_events\", \"evening_events\"] {\n\t\t\t\t\t\tif let Some(events) = day.get(time_block).and_then(|v| v.as_array()) {\n\t\t\t\t\t\t\tfor event in events {\n\t\t\t\t\t\t\t\tif let Some(id) = event.get(\"id\").and_then(|v| v.as_i64()) {\n\t\t\t\t\t\t\t\t\tall_event_ids.push(id as i32);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif let Some(unassigned) = itinerary_json\n\t\t\t\t.get(\"unassigned_events\")\n\t\t\t\t.and_then(|v| v.as_array())\n\t\t\t{\n\t\t\t\tfor event in unassigned {\n\t\t\t\t\tif let Some(id) = event.get(\"id\").and_then(|v| v.as_i64()) {\n\t\t\t\t\t\tall_event_ids.push(id as i32);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fetch full event objects from database\n\t\t\tuse crate::http_models::event::Event as HttpEvent;\n\t\t\tlet full_events = if !all_event_ids.is_empty() {\n\t\t\t\tsqlx::query_as!(\n\t\t\t\t\tHttpEvent,\n\t\t\t\t\tr#\"\n\t\t\t\tSELECT \n\t\t\t\t\tid, event_name, event_description, street_address, city, country, postal_code,\n\t\t\t\t\tlat, lng, event_type, user_created, hard_start, hard_end, timezone, place_id,\n\t\t\t\t\twheelchair_accessible_parking, wheelchair_accessible_entrance,\n\t\t\t\t\twheelchair_accessible_restroom, wheelchair_accessible_seating,\n\t\t\t\t\tserves_vegetarian_food, price_level, utc_offset_minutes, website_uri, types,\n\t\t\t\t\tphoto_name, photo_width, photo_height, photo_author, photo_author_uri,\n\t\t\t\t\tphoto_author_photo_uri, weekday_descriptions, secondary_hours_type,\n\t\t\t\t\tnext_open_time, next_close_time, open_now,\n\t\t\t\t\tperiods as \"periods!: Vec\u003ccrate::sql_models::Period\u003e\",\n\t\t\t\t\tspecial_days,\n\t\t\t\t\tNULL::int4 as block_index\n\t\t\t\tFROM events\n\t\t\t\tWHERE id = ANY($1)\n\t\t\t\t\"#,\n\t\t\t\t\t\u0026all_event_ids\n\t\t\t\t)\n\t\t\t\t.fetch_all(\u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Failed to fetch full events: {}\", e))?\n\t\t\t} else {\n\t\t\t\tVec::new()\n\t\t\t};\n\n\t\t\t// Create a map of event ID -\u003e full event for quick lookup\n\t\t\tlet event_map: std::collections::HashMap\u003ci32, HttpEvent\u003e =\n\t\t\t\tfull_events.into_iter().map(|e| (e.id, e)).collect();\n\n\t\t\t// Helper function to hydrate events with full data from database\n\t\t\tlet hydrate_events = |partial_events: \u0026Value| -\u003e Vec\u003cHttpEvent\u003e {\n\t\t\t\tif let Some(events_arr) = partial_events.as_array() {\n\t\t\t\t\tevents_arr\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.filter_map(|e| {\n\t\t\t\t\t\t\te.get(\"id\")\n\t\t\t\t\t\t\t\t.and_then(|v| v.as_i64())\n\t\t\t\t\t\t\t\t.and_then(|id| event_map.get(\u0026(id as i32)).cloned())\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect()\n\t\t\t\t} else {\n\t\t\t\t\tVec::new()\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Parse itinerary structure (dates, title, days)\n\t\t\tuse crate::http_models::itinerary::EventDay as HttpEventDay;\n\t\t\tlet mut event_days = Vec::new();\n\t\t\tif let Some(days) = itinerary_json.get(\"event_days\").and_then(|v| v.as_array()) {\n\t\t\t\tfor day in days {\n\t\t\t\t\tlet date_str = day\n\t\t\t\t\t\t.get(\"date\")\n\t\t\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\t\t\tlet date = chrono::NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\")\n\t\t\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\n\t\t\t\t\tevent_days.push(HttpEventDay {\n\t\t\t\t\t\tmorning_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"morning_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tafternoon_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"afternoon_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tevening_events: hydrate_events(\n\t\t\t\t\t\t\t\u0026day.get(\"evening_events\").cloned().unwrap_or(json!([])),\n\t\t\t\t\t\t),\n\t\t\t\t\t\tdate,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet unassigned_events = hydrate_events(\n\t\t\t\t\u0026itinerary_json\n\t\t\t\t\t.get(\"unassigned_events\")\n\t\t\t\t\t.cloned()\n\t\t\t\t\t.unwrap_or(json!([])),\n\t\t\t);\n\n\t\t\t// Create HttpItinerary with hydrated events\n\t\t\tlet start_date_str = itinerary_json\n\t\t\t\t.get(\"start_date\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\tlet end_date_str = itinerary_json\n\t\t\t\t.get(\"end_date\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"2025-01-01\");\n\t\t\tlet start_date = chrono::NaiveDate::parse_from_str(start_date_str, \"%Y-%m-%d\")\n\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\t\t\tlet end_date = chrono::NaiveDate::parse_from_str(end_date_str, \"%Y-%m-%d\")\n\t\t\t\t.unwrap_or_else(|_| chrono::NaiveDate::from_ymd_opt(2025, 1, 1).unwrap());\n\t\t\tlet title = itinerary_json\n\t\t\t\t.get(\"title\")\n\t\t\t\t.and_then(|v| v.as_str())\n\t\t\t\t.unwrap_or(\"Trip Itinerary\")\n\t\t\t\t.to_string();\n\n\t\t\tlet mut itinerary = HttpItinerary {\n\t\t\t\tid: 0, // Temporary, will be set after insert\n\t\t\t\tstart_date,\n\t\t\t\tend_date,\n\t\t\t\tevent_days,\n\t\t\t\tchat_session_id: Some(chat_id),\n\t\t\t\ttitle,\n\t\t\t\tunassigned_events,\n\t\t\t};\n\n\t\t\t// Extract unassigned event IDs\n\t\t\tlet unassigned_event_ids: Vec\u003ci32\u003e =\n\t\t\t\titinerary.unassigned_events.iter().map(|e| e.id).collect();\n\n\t\t\t// Insert itinerary into database\n\t\t\tlet itinerary_id = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title, unassigned_event_ids)\n\t\t\tVALUES ($1, FALSE, $2, $3, $4, FALSE, $5, $6)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\tuser_id,\n\t\t\titinerary.start_date,\n\t\t\titinerary.end_date,\n\t\t\tchat_id,\n\t\t\titinerary.title,\n\t\t\t\u0026unassigned_event_ids\n\t\t)\n\t\t.fetch_one(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Failed to insert itinerary: {}\", e))?\n\t\t.id;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Created itinerary in database\"\n\t\t\t);\n\n\t\t\t// Update itinerary ID for insert_event_list\n\t\t\titinerary.id = itinerary_id;\n\n\t\t\t// Capture the number of days before moving itinerary\n\t\t\tlet num_days = itinerary.event_days.len();\n\n\t\t\t// Insert all events into event_list table\n\t\t\tinsert_event_list(itinerary, \u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Failed to insert event list: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Inserted event list for itinerary\"\n\t\t\t);\n\n\t\t\t// Create user-friendly message\n\t\t\tlet default_message = format!(\n\t\t\t\t\"I've created your travel itinerary! It includes {} days with events scheduled throughout. You can view and edit it in your saved itineraries.\",\n\t\t\t\tnum_days\n\t\t\t);\n\t\t\tlet message = optional_message\n\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t.unwrap_or(default_message);\n\n\t\t\t// Insert message with itinerary_id\n\t\t\tlet record = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, $2, FALSE, NOW(), $3)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\t\tchat_id,\n\t\t\t\titinerary_id,\n\t\t\t\tmessage\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_id = record.id,\n\t\t\t\titinerary_id = itinerary_id,\n\t\t\t\t\"Sent itinerary to user\"\n\t\t\t);\n\n\t\t\t(message, record.id)\n\t\t} else {\n\t\t\t// No itinerary - ask for more information\n\t\t\tlet default_message = \"I need more information to create your itinerary. Could you please provide:\\n- Your travel destination\\n- Travel dates (start and end)\\n- Budget\\n- Any preferences or constraints you have?\";\n\t\t\tlet message = optional_message.unwrap_or(default_message.to_string());\n\n\t\t\t// Insert message asking for more info\n\t\t\tlet record = sqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\t\t\tRETURNING id;\n\t\t\t\t\"#,\n\t\t\t\tchat_id,\n\t\t\t\tmessage\n\t\t\t)\n\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"respond_to_user\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_id = record.id,\n\t\t\t\t\"Asked user for more information\"\n\t\t\t);\n\n\t\t\t(message, record.id)\n\t\t};\n\n\t\t// Return a special marker that send_message_to_llm can detect\n\t\t// Format: \"MESSAGE_INSERTED:\u003cmessage_id\u003e:\u003cmessage_text\u003e\"\n\t\tlet result = format!(\"MESSAGE_INSERTED:{}:{}\", message_id, message_text);\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"respond_to_user\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\t// Track this tool execution\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"respond_to_user\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result)\n\t}\n}\n\n/// Tool: Update Trip Context\n/// Updates the trip context with new information from the user's latest message.\n/// This tool should be called AFTER retrieve_chat_context to incrementally fill in trip details.\n#[derive(Clone)]\npub struct UpdateTripContextTool {\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl UpdateTripContextTool {\n\tpub fn new(\n\t\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tllm,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for UpdateTripContextTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"update_trip_context\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Updates the trip context with new information extracted from the user's latest message in the chat history. Call this AFTER retrieve_chat_context to incrementally fill in destination, dates, budget, preferences. Automatically extracts the most recent user message from chat_history. Only updates fields that are present in the new information - existing fields are preserved. Returns the updated trip context showing what information we now have and what is still missing.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone();\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"update_trip_context\", status: \"start\");\n\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"Updating trip context from chat history\"\n\t\t);\n\n\t\t// Get current trip context AND extract the last 5 user messages from chat_history\n\t\t// We need multiple messages because user provides info across multiple turns\n\t\tlet (current_context, user_messages) = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tlet context_data = store_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.ok_or(\"Context not found for chat_id\")?;\n\n\t\t\t// Extract the last 5 user messages from chat_history (most recent first)\n\t\t\tlet recent_user_msgs: Vec\u003cString\u003e = context_data\n\t\t\t\t.chat_history\n\t\t\t\t.iter()\n\t\t\t\t.rev() // Start from the end (most recent)\n\t\t\t\t.filter(|msg| msg.get(\"role\").and_then(|r| r.as_str()) == Some(\"user\"))\n\t\t\t\t.take(5) // Get last 5 user messages\n\t\t\t\t.filter_map(|msg| {\n\t\t\t\t\tmsg.get(\"content\")\n\t\t\t\t\t\t.and_then(|c| c.as_str())\n\t\t\t\t\t\t.map(|s| s.to_string())\n\t\t\t\t})\n\t\t\t\t.collect();\n\n\t\t\t// Combine them into one string (most recent first)\n\t\t\tlet combined_messages = recent_user_msgs.join(\"\\n\");\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\ttool = \"update_trip_context\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tmessage_count = recent_user_msgs.len(),\n\t\t\t\tcombined_length = combined_messages.len(),\n\t\t\t\t\"Extracted recent user messages from chat history\"\n\t\t\t);\n\t\t\tdebug!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\tmessages = %combined_messages,\n\t\t\t\t\"Combined user messages for extraction\"\n\t\t\t);\n\n\t\t\t(context_data.trip_context.clone(), combined_messages)\n\t\t};\n\n\t\tinfo!(\n\t\t\ttarget: \"trip_context\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"BEFORE UPDATE - Current trip context\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tcurrent_destination = ?current_context.destination,\n\t\t\tcurrent_start_date = ?current_context.start_date,\n\t\t\tcurrent_end_date = ?current_context.end_date,\n\t\t\tcurrent_budget = ?current_context.budget,\n\t\t\tcurrent_preferences = ?current_context.preferences,\n\t\t\tcurrent_constraints = ?current_context.constraints,\n\t\t\t\"Current trip context details\"\n\t\t);\n\n\t\t// Use LLM to extract trip information from the messages\n\t\tlet extraction_prompt = format!(\n\t\t\tr#\"Extract trip planning information from these recent user messages. Return ONLY a JSON object.\n\nCurrent context (preserve these if not mentioned in new messages):\n- destination: {}\n- start_date: {}\n- end_date: {}\n- budget: {}\n- preferences: {}\n\nRecent user messages (newest first):\n\"{}\"\n\nIMPORTANT: Extract information from ALL the messages above, not just the first one.\n\nReturn JSON with the information found across all messages:\n{{\n  \"destination\": \"string or null\",\n  \"start_date\": \"YYYY-MM-DD or null\",\n  \"end_date\": \"YYYY-MM-DD or null\",\n  \"budget\": number or null,\n  \"preferences\": [\"array\", \"of\", \"strings\"] or [],\n  \"action\": \"create|modify|view|delete or null\"\n}}\n\nExamples:\n- \"Brazil\" + \"10/8 to 10/20\" → {{\"destination\": \"Brazil\", \"start_date\": \"2023-10-08\", \"end_date\": \"2023-10-20\"}}\n- \"no preferences\" → {{\"preferences\": []}}\n\nReturn valid JSON only.\"#,\n\t\t\tcurrent_context.destination.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context.start_date.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context.end_date.as_deref().unwrap_or(\"null\"),\n\t\t\tcurrent_context\n\t\t\t\t.budget\n\t\t\t\t.map(|b| b.to_string())\n\t\t\t\t.as_deref()\n\t\t\t\t.unwrap_or(\"null\"),\n\t\t\tserde_json::to_string(\u0026current_context.preferences)\n\t\t\t\t.unwrap_or_else(|_| \"[]\".to_string()),\n\t\t\tuser_messages\n\t\t);\n\n\t\tlet llm_response = self\n\t\t\t.llm\n\t\t\t.invoke(\u0026extraction_prompt)\n\t\t\t.await\n\t\t\t.map_err(|e| format!(\"LLM error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"trip_context\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\tchat_id = chat_id,\n\t\t\t\"LLM extraction response\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tllm_response = %llm_response,\n\t\t\t\"Raw LLM response for extraction\"\n\t\t);\n\n\t\t// Parse LLM response\n\t\tlet extracted: Value = serde_json::from_str(\u0026llm_response).unwrap_or_else(|e| {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"trip_context\",\n\t\t\t\terror = %e,\n\t\t\t\traw_response = %llm_response,\n\t\t\t\t\"Failed to parse LLM response as JSON, using empty object\"\n\t\t\t);\n\t\t\tjson!({})\n\t\t});\n\n\t\t// Merge with current context (only update non-null fields)\n\t\tlet mut updated_context = current_context;\n\n\t\tif let Some(dest) = extracted[\"destination\"].as_str() {\n\t\t\tupdated_context.destination = Some(dest.to_string());\n\t\t}\n\t\tif let Some(start) = extracted[\"start_date\"].as_str() {\n\t\t\tupdated_context.start_date = Some(start.to_string());\n\t\t}\n\t\tif let Some(end) = extracted[\"end_date\"].as_str() {\n\t\t\tupdated_context.end_date = Some(end.to_string());\n\t\t}\n\t\tif let Some(budget) = extracted[\"budget\"].as_f64() {\n\t\t\tupdated_context.budget = Some(budget);\n\t\t}\n\t\tif let Some(prefs) = extracted[\"preferences\"].as_array() {\n\t\t\tlet new_prefs: Vec\u003cString\u003e = prefs\n\t\t\t\t.iter()\n\t\t\t\t.filter_map(|v| v.as_str().map(|s| s.to_string()))\n\t\t\t\t.collect();\n\t\t\tif !new_prefs.is_empty() {\n\t\t\t\tupdated_context.preferences.extend(new_prefs);\n\t\t\t\tupdated_context.preferences.dedup();\n\t\t\t}\n\t\t}\n\t\tif let Some(action) = extracted[\"action\"].as_str() {\n\t\t\tupdated_context.action = Some(action.to_string());\n\t\t}\n\n\t\t// Save updated context\n\t\t{\n\t\t\tlet mut store_guard = self.context_store.write().await;\n\t\t\tif let Some(context_data) = store_guard.get_mut(\u0026chat_id) {\n\t\t\t\tcontext_data.trip_context = updated_context.clone();\n\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\ttool = \"update_trip_context\",\n\t\t\t\t\tchat_id = chat_id,\n\t\t\t\t\t\"AFTER UPDATE - Updated trip context saved\",\n\t\t\t\t);\n\t\t\t\tdebug!(\n\t\t\t\t\ttarget: \"trip_context\",\n\t\t\t\t\tupdated_destination = ?updated_context.destination,\n\t\t\t\t\tupdated_start_date = ?updated_context.start_date,\n\t\t\t\t\tupdated_end_date = ?updated_context.end_date,\n\t\t\t\t\tupdated_budget = ?updated_context.budget,\n\t\t\t\t\tupdated_preferences = ?updated_context.preferences,\n\t\t\t\t\tupdated_constraints = ?updated_context.constraints,\n\t\t\t\t\t\"Updated trip context details\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Determine what's still missing - ONLY require destination and dates\n\t\t// Budget, preferences, and constraints are ALL optional\n\t\tlet mut missing = Vec::new();\n\t\tif updated_context.destination.is_none() {\n\t\t\tmissing.push(\"destination\");\n\t\t}\n\t\tif updated_context.start_date.is_none() {\n\t\t\tmissing.push(\"start_date\");\n\t\t}\n\t\tif updated_context.end_date.is_none() {\n\t\t\tmissing.push(\"end_date\");\n\t\t}\n\t\t// Budget, preferences, and constraints are optional - don't add to missing\n\n\t\t// Check if we've asked clarification at least once\n\t\tlet has_asked_before = updated_context.asked_clarification;\n\n\t\t// Ready for pipeline only if:\n\t\t// 1. No missing required fields AND\n\t\t// 2. We've asked clarification at least once\n\t\tlet ready_for_pipeline = missing.is_empty() \u0026\u0026 has_asked_before;\n\n\t\tlet result = json!({\n\t\t\t\"trip_context\": updated_context,\n\t\t\t\"missing_info\": missing,\n\t\t\t\"ready_for_pipeline\": ready_for_pipeline,\n\t\t\t\"asked_clarification_before\": has_asked_before\n\t\t});\n\n\t\tlet result_str = serde_json::to_string(\u0026result)?;\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_trip_context\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\tchat_id = chat_id,\n\t\t\tmissing_count = missing.len(),\n\t\t\tready = missing.is_empty(),\n\t\t\t\"Trip context update complete - SUMMARY\",\n\t\t);\n\t\tdebug!(\n\t\t\ttarget: \"trip_context\",\n\t\t\tmissing_fields = ?missing,\n\t\t\t\"Missing information details\"\n\t\t);\n\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"update_trip_context\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result_str,\n\t\t)\n\t\t.await?;\n\n\t\tOk(result_str)\n\t}\n}\n\n/// Tool 6: Update Chat Title\n/// Automatically updates the chat session title based on trip context\n/// Only updates if the title is still \"New Chat\" (default)\n#[derive(Clone)]\npub struct UpdateChatTitleTool {\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n}\n\nimpl UpdateChatTitleTool {\n\tpub fn new(\n\t\tpool: PgPool,\n\t\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\t\tcontext_store: SharedContextStore,\n\t) -\u003e Self {\n\t\tSelf {\n\t\t\tpool,\n\t\t\tchat_session_id,\n\t\t\tcontext_store,\n\t\t}\n\t}\n}\n\n#[async_trait]\nimpl Tool for UpdateChatTitleTool {\n\tfn name(\u0026self) -\u003e String {\n\t\t\"update_chat_title\".to_string()\n\t}\n\n\tfn description(\u0026self) -\u003e String {\n\t\t\"Automatically updates the chat session title with destination and dates when trip context is available. Only updates if title is still 'New Chat'. Call this after update_trip_context when you have destination and dates. No parameters needed.\"\n\t\t\t.to_string()\n\t}\n\n\tfn parameters(\u0026self) -\u003e Value {\n\t\tjson!({\n\t\t\t\"type\": \"object\",\n\t\t\t\"properties\": {},\n\t\t\t\"required\": []\n\t\t})\n\t}\n\n\tasync fn run(\u0026self, input: Value) -\u003e Result\u003cString, Box\u003cdyn Error\u003e\u003e {\n\t\tlet start_time = Instant::now();\n\t\tlet input_clone = input.clone();\n\n\t\tcrate::tool_trace!(agent: \"task\", tool: \"update_chat_title\", status: \"start\");\n\n\t\tlet chat_id = self.chat_session_id.load(Ordering::Relaxed);\n\t\tif chat_id == 0 {\n\t\t\treturn Err(\"chat_session_id not set\".into());\n\t\t}\n\n\t\t// Get trip context\n\t\tlet trip_context = {\n\t\t\tlet store_guard = self.context_store.read().await;\n\t\t\tstore_guard\n\t\t\t\t.get(\u0026chat_id)\n\t\t\t\t.map(|ctx| ctx.trip_context.clone())\n\t\t\t\t.ok_or(\"Context not found\")?\n\t\t};\n\n\t\t// Check if we have enough info to make a title\n\t\tif trip_context.destination.is_none() {\n\t\t\treturn Ok(json!({\n\t\t\t\t\"updated\": false,\n\t\t\t\t\"reason\": \"No destination set yet\"\n\t\t\t})\n\t\t\t.to_string());\n\t\t}\n\n\t\t// Check current title - only update if it's \"New Chat\"\n\t\tlet current_title =\n\t\t\tsqlx::query!(r#\"SELECT title FROM chat_sessions WHERE id = $1\"#, chat_id)\n\t\t\t\t.fetch_one(\u0026self.pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(|e| format!(\"Database error: {}\", e))?\n\t\t\t\t.title;\n\n\t\tif current_title != \"New Chat\" {\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_tool\",\n\t\t\t\ttool = \"update_chat_title\",\n\t\t\t\tchat_id = chat_id,\n\t\t\t\tcurrent_title = %current_title,\n\t\t\t\t\"Title already set, skipping update\"\n\t\t\t);\n\t\t\treturn Ok(json!({\n\t\t\t\t\"updated\": false,\n\t\t\t\t\"reason\": \"Title already set\",\n\t\t\t\t\"current_title\": current_title\n\t\t\t})\n\t\t\t.to_string());\n\t\t}\n\n\t\t// Build new title from trip context\n\t\tlet mut title_parts = Vec::new();\n\n\t\tif let Some(dest) = \u0026trip_context.destination {\n\t\t\ttitle_parts.push(dest.clone());\n\t\t}\n\n\t\t// Format dates if we have both\n\t\tif let (Some(start), Some(end)) = (\u0026trip_context.start_date, \u0026trip_context.end_date) {\n\t\t\t// Try to format as \"MMM DD-DD\" if same month\n\t\t\tif let (Ok(start_date), Ok(end_date)) = (\n\t\t\t\tchrono::NaiveDate::parse_from_str(start, \"%Y-%m-%d\"),\n\t\t\t\tchrono::NaiveDate::parse_from_str(end, \"%Y-%m-%d\"),\n\t\t\t) {\n\t\t\t\tif start_date.month() == end_date.month() {\n\t\t\t\t\ttitle_parts.push(format!(\n\t\t\t\t\t\t\"{} {}-{}\",\n\t\t\t\t\t\tstart_date.format(\"%b\"),\n\t\t\t\t\t\tstart_date.day(),\n\t\t\t\t\t\tend_date.day()\n\t\t\t\t\t));\n\t\t\t\t} else {\n\t\t\t\t\ttitle_parts.push(format!(\n\t\t\t\t\t\t\"{} - {}\",\n\t\t\t\t\t\tstart_date.format(\"%b %d\"),\n\t\t\t\t\t\tend_date.format(\"%b %d\")\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet new_title = if title_parts.is_empty() {\n\t\t\t\"New Trip\".to_string()\n\t\t} else {\n\t\t\ttitle_parts.join(\", \")\n\t\t};\n\n\t\t// Update the title\n\t\tsqlx::query!(\n\t\t\tr#\"UPDATE chat_sessions SET title = $1 WHERE id = $2\"#,\n\t\t\tnew_title,\n\t\t\tchat_id\n\t\t)\n\t\t.execute(\u0026self.pool)\n\t\t.await\n\t\t.map_err(|e| format!(\"Database error: {}\", e))?;\n\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_chat_title\",\n\t\t\tchat_id = chat_id,\n\t\t\tnew_title = %new_title,\n\t\t\t\"Updated chat session title\"\n\t\t);\n\n\t\tlet result = json!({\n\t\t\t\"updated\": true,\n\t\t\t\"new_title\": new_title\n\t\t});\n\n\t\tlet elapsed = start_time.elapsed();\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_tool\",\n\t\t\ttool = \"update_chat_title\",\n\t\t\telapsed_ms = elapsed.as_millis() as u64,\n\t\t\t\"Tool completed\"\n\t\t);\n\n\t\ttrack_tool_execution(\n\t\t\t\u0026self.context_store,\n\t\t\t\u0026self.chat_session_id,\n\t\t\t\"update_chat_title\",\n\t\t\t\u0026input_clone,\n\t\t\t\u0026result.to_string(),\n\t\t)\n\t\t.await?;\n\n\t\tOk(result.to_string())\n\t}\n}\n\n/// Gets the tools used by the Task Agent to build planning context.\n/// These tools are focused on:\n/// - retrieving user profile\n/// - retrieving chat history/context\n/// - updating trip context incrementally\n/// - asking for clarification when information is missing\npub fn get_task_tools(\n\tllm: Arc\u003cdyn LLM + Send + Sync\u003e,\n\tpool: PgPool,\n\tchat_session_id: Arc\u003cAtomicI32\u003e,\n\tuser_id: Arc\u003cAtomicI32\u003e,\n\tcontext_store: SharedContextStore,\n) -\u003e Vec\u003cArc\u003cdyn Tool\u003e\u003e {\n\tvec![\n\t\tArc::new(ParseUserIntentTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RetrieveChatContextTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(RetrieveUserProfileTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tArc::clone(\u0026user_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(UpdateTripContextTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(UpdateChatTitleTool::new(\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t\tArc::new(AskForClarificationTool::new(\n\t\t\tArc::clone(\u0026llm),\n\t\t\tpool.clone(),\n\t\t\tArc::clone(\u0026chat_session_id),\n\t\t\tcontext_store.clone(),\n\t\t)),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","agent","tools","tsp.rs"],"content":"// tsp.rs - vibe coded so don't blame me for bugs\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Copy, Debug, Serialize, Deserialize)]\npub struct Pt\u003c'a\u003e {\n\tpub id: Option\u003c\u0026'a str\u003e,\n\tpub lat: f64,\n\tpub lng: f64,\n}\n\nfn dist(a: Pt, b: Pt) -\u003e f64 {\n\tlet dx = a.lat - b.lat;\n\tlet dy = a.lng - b.lng;\n\t(dx * dx + dy * dy).sqrt()\n}\n\n//\n// ---------------------------\n// Route Construction\n// ---------------------------\n//\n\nfn nearest_neighbor_cycle(points: \u0026[Pt], start: usize) -\u003e Vec\u003cusize\u003e {\n\tlet n = points.len();\n\tlet mut visited = vec![false; n];\n\tlet mut route = Vec::with_capacity(n + 1);\n\n\tlet mut current = start;\n\tvisited[current] = true;\n\troute.push(current);\n\n\tfor _ in 1..n {\n\t\tlet mut best = None;\n\t\tlet mut best_dist = f64::INFINITY;\n\t\tfor i in 0..n {\n\t\t\tif !visited[i] {\n\t\t\t\tlet d = dist(points[current], points[i]);\n\t\t\t\tif d \u003c best_dist {\n\t\t\t\t\tbest_dist = d;\n\t\t\t\t\tbest = Some(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet next = best.unwrap();\n\t\tvisited[next] = true;\n\t\troute.push(next);\n\t\tcurrent = next;\n\t}\n\n\t// Explicitly close the cycle by returning to start\n\troute.push(start);\n\n\troute\n}\n\nfn nearest_neighbor_path(points: \u0026[Pt], start: usize, end: usize) -\u003e Vec\u003cusize\u003e {\n\tlet n = points.len();\n\tlet mut visited = vec![false; n];\n\tlet mut route = Vec::with_capacity(n);\n\n\tvisited[start] = true;\n\t// Do NOT visit end early\n\tvisited[end] = false;\n\n\tlet mut current = start;\n\troute.push(start);\n\n\tfor _ in 0..n - 2 {\n\t\tlet mut best = None;\n\t\tlet mut best_dist = f64::INFINITY;\n\n\t\tfor i in 0..n {\n\t\t\tif i == end {\n\t\t\t\tcontinue; // don't pick end until last\n\t\t\t}\n\t\t\tif !visited[i] {\n\t\t\t\tlet d = dist(points[current], points[i]);\n\t\t\t\tif d \u003c best_dist {\n\t\t\t\t\tbest_dist = d;\n\t\t\t\t\tbest = Some(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet next = best.unwrap();\n\t\tvisited[next] = true;\n\t\troute.push(next);\n\t\tcurrent = next;\n\t}\n\n\t// Now put end last\n\troute.push(end);\n\n\troute\n}\n\n//\n// ---------------------------\n// 2-opt optimization\n// ---------------------------\n//\n\nfn two_opt_cycle(points: \u0026[Pt], route: \u0026mut Vec\u003cusize\u003e) {\n\tlet n = route.len();\n\tlet mut improved = true;\n\n\twhile improved {\n\t\timproved = false;\n\t\tfor i in 1..n - 2 {\n\t\t\tfor j in i + 1..n - 1 {\n\t\t\t\tlet a = route[i - 1];\n\t\t\t\tlet b = route[i];\n\t\t\t\tlet c = route[j];\n\t\t\t\tlet d = route[j + 1];\n\n\t\t\t\tlet before = dist(points[a], points[b]) + dist(points[c], points[d]);\n\t\t\t\tlet after = dist(points[a], points[c]) + dist(points[b], points[d]);\n\n\t\t\t\tif after \u003c before {\n\t\t\t\t\troute[i..=j].reverse();\n\t\t\t\t\timproved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn two_opt_path(points: \u0026[Pt], route: \u0026mut Vec\u003cusize\u003e) {\n\tlet n = route.len();\n\tlet mut improved = true;\n\n\t// route[0] and route[n-1] must not move\n\twhile improved {\n\t\timproved = false;\n\t\tfor i in 1..n - 3 {\n\t\t\tfor j in i + 1..n - 2 {\n\t\t\t\tlet a = route[i - 1];\n\t\t\t\tlet b = route[i];\n\t\t\t\tlet c = route[j];\n\t\t\t\tlet d = route[j + 1];\n\n\t\t\t\tlet before = dist(points[a], points[b]) + dist(points[c], points[d]);\n\t\t\t\tlet after = dist(points[a], points[c]) + dist(points[b], points[d]);\n\n\t\t\t\tif after \u003c before {\n\t\t\t\t\troute[i..=j].reverse();\n\t\t\t\t\timproved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//\n// ---------------------------\n// Public API\n// ---------------------------\n//\n\npub enum EndpointMode {\n\tCircle,\n\tPath,\n}\n\npub fn compute_route(points: \u0026[Pt], mode: EndpointMode) -\u003e Vec\u003cusize\u003e {\n\tmatch mode {\n\t\tEndpointMode::Circle =\u003e {\n\t\t\tlet mut route = nearest_neighbor_cycle(points, 0);\n\t\t\ttwo_opt_cycle(points, \u0026mut route);\n\t\t\troute\n\t\t}\n\t\tEndpointMode::Path =\u003e {\n\t\t\tlet mut route = nearest_neighbor_path(points, 0, points.len() - 1);\n\t\t\ttwo_opt_path(points, \u0026mut route);\n\t\t\troute\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","account.rs"],"content":"/*\n * src/controllers/account.rs\n *\n * File for Account Controller API Endpoints\n *\n * Purpose:\n *   Serve Account Related API Requests\n */\n\nuse argon2::{\n\tArgon2,\n\tpassword_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\nuse axum::{\n\tExtension, Json,\n\trouting::{get, post},\n};\n#[cfg(test)]\nuse tower_cookies::cookie::CookieJar;\n\nuse tower_cookies::{\n\tCookie, Cookies,\n\tcookie::{\n\t\tKey, SameSite,\n\t\ttime::{Duration, OffsetDateTime},\n\t},\n};\n\n#[cfg(test)]\nuse crate::global::TEST_COOKIE_EXP_SECONDS;\n\nuse sqlx::PgPool;\nuse tracing::debug;\nuse utoipa::OpenApi;\n\nuse crate::http_models::account::*;\nuse crate::middleware::{AuthUser, middleware_auth};\nuse crate::{\n\tcontrollers::AxumRouter,\n\terror::{ApiResult, AppError},\n\tsql_models::{BudgetBucket, RiskTolerence, account::AccountRow},\n\tswagger::SecurityAddon,\n};\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_signup,\n\t\tapi_login,\n\t\tapi_logout,\n\t\tapi_validate,\n\t\tapi_update,\n\t\tapi_current\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n    info(\n    \ttitle=\"Account Routes\",\n    \tdescription = \"API endpoints dealing with authentication and account info.\"\n    ),\n    tags((name=\"Account\"))\n)]\npub struct AccountApiDoc;\n\npub trait CookieStore {\n\tfn private_add(\u0026mut self, key: \u0026Key, cookie: Cookie\u003c'static\u003e);\n}\nimpl CookieStore for Cookies {\n\t#[inline(always)]\n\tfn private_add(\u0026mut self, key: \u0026Key, cookie: Cookie\u003c'static\u003e) {\n\t\tself.private(key).add(cookie)\n\t}\n}\n#[cfg(test)]\nimpl CookieStore for CookieJar {\n\t#[inline(always)]\n\tfn private_add(\u0026mut self, _key: \u0026Key, cookie: Cookie\u003c'static\u003e) {\n\t\tself.add(cookie)\n\t}\n}\n\n/// Creates and sets the cookie containing the hashed account id, expiration time, and other data.\n///\n/// Notes:\n/// - Token format is `user-\u003cid\u003e.\u003cexp\u003e.sign`, where `\u003cexp\u003e` is epoch seconds (UTC) ~3 days out.\n/// - Cookie name is `auth-token`; in development it uses `SameSite=Lax`, not `Secure`.\nfn set_cookie(account_id: i32, expired: bool, cookies: \u0026mut impl CookieStore, key: \u0026Key) {\n\t// Create token and set cookie as before\n\tlet domain = option_env!(\"DOMAIN\").unwrap_or(\"localhost\");\n\tlet app_env = option_env!(\"APP_ENV\").unwrap_or(\"development\");\n\tlet on_production = app_env == \"production\";\n\n\t// Create a token value (in a real app, this would be a JWT or similar)\n\t// Embed expiration epoch seconds inside the token for server-side validation\n\tlet (expires, max_age) = if expired {\n\t\t(OffsetDateTime::UNIX_EPOCH, Duration::days(0))\n\t} else {\n\t\t#[cfg(not(test))]\n\t\tlet age = Duration::days(3);\n\n\t\t// if tests start failing because the cookie expires too fast, just raise it by a little bit\n\t\t#[cfg(test)]\n\t\tlet age = Duration::seconds(TEST_COOKIE_EXP_SECONDS);\n\n\t\t(OffsetDateTime::now_utc() + age, age)\n\t};\n\tlet token_value = format!(\"user-{}.{}.sign\", account_id, expires.unix_timestamp());\n\n\tdebug!(\n\t\t\"INFO -\u003e\u003e Generated token: {}. Production is: {}\",\n\t\ttoken_value, on_production\n\t);\n\n\t// Build the cookie with enhanced security\n\t// Store encrypted (private) cookie so value is confidential and authenticated\n\tlet cookie = Cookie::build((\"auth-token\", token_value.clone()))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.expires(Some(expires))\n\t\t.max_age(max_age)\n\t\t.build();\n\n\t// encrypt/sign cookie (private cookie via CookieManagerLayer key)\n\tcookies.private_add(key, cookie);\n}\n\n/// Create a new user.\n///\n/// # Method\n/// `POST /api/account/signup`\n///\n/// # Request Body\n/// - `email`: A valid email address (string, required).\n/// - `first_name`: The user's first name (string, required).\n/// - 'last_name': The user's last name (string, required).\n/// - 'password': The user's password (string, required).\n///\n/// # Responses\n/// - `200 OK` - Signup successful\n/// - `400 BAD_REQUEST` - Validation failure (public error)\n/// - `409 CONFLICT` - Email already exists (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/signup\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///        \"email\": \"alice@example.com\",\n///        \"first_name\": \"alice\",\n///        \"last_name\": \"grace\",\n///        \"password\": \"password123.\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/signup\",\n\tsummary=\"Create a new account\",\n\tdescription=\"Inserts account details into db (if email isn't already taken), and returns with a cookie.\",\n\trequest_body(\n\t\tcontent=SignupRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Email must not already be taken. Password must be in plaintext.\",\n\t\texample=json!({\n\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\"first_name\": \"First\",\n\t\t\t\"last_name\": \"Last\",\n\t\t\t\"password\": \"Password_123\"\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Account successfully created\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=409, description=\"Email already in use\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n\ttag=\"Account\"\n)]\npub async fn api_signup\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(payload): Json\u003cSignupRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/signup 'api_signup' - Payload: {:?}\",\n\t\tpayload\n\t);\n\n\t// Validate input\n\tif let Err(validation_error) = payload.validate() {\n\t\treturn Err(AppError::Validation(validation_error));\n\t}\n\n\t// Check if user already exists\n\tlet existing_user_result =\n\t\tsqlx::query!(\"SELECT id FROM accounts WHERE email = $1\", payload.email)\n\t\t\t.fetch_optional(\u0026pool)\n\t\t\t.await;\n\n\tmatch existing_user_result {\n\t\tOk(Some(_)) =\u003e {\n\t\t\treturn Err(AppError::Conflict(\"email already exists\".to_string()));\n\t\t}\n\t\tErr(e) =\u003e {\n\t\t\treturn Err(AppError::from(e));\n\t\t}\n\t\tOk(None) =\u003e {\n\t\t\t// User doesn't exist, proceed with signup\n\t\t}\n\t}\n\n\t// Hash the password\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\tlet password_hash = argon2\n\t\t.hash_password(payload.password.as_bytes(), \u0026salt)\n\t\t.map_err(AppError::from)?\n\t\t.to_string();\n\n\t// Insert new user into database\n\tlet insert_result = sqlx::query!(\n\t\t\"INSERT INTO accounts (email, first_name, last_name, password)\n         VALUES ($1, $2, $3, $4)\n         RETURNING id\",\n\t\tpayload.email,\n\t\tpayload.first_name,\n\t\tpayload.last_name,\n\t\tpassword_hash\n\t)\n\t.fetch_one(\u0026pool)\n\t.await;\n\n\tmatch insert_result {\n\t\tOk(record) =\u003e {\n\t\t\tdebug!(\n\t\t\t\t\"INFO -\u003e\u003e /api/account/signup 'api_signup' - Created user with id: {}\",\n\t\t\t\trecord.id\n\t\t\t);\n\n\t\t\tset_cookie(record.id, false, cookies, \u0026key);\n\n\t\t\tOk(())\n\t\t}\n\t\tErr(e) =\u003e Err(AppError::from(e)),\n\t}\n}\n\n/// Attempt user login\n///\n/// # Method\n/// `POST /api/account/login`\n///\n/// # Request Body\n/// - `email`: A valid email address (string, required).\n/// - 'password': The user's password (string, required).\n///\n/// # Responses\n/// - `200 OK` - Login successful with private cookie set\n/// - `400 BAD_REQUEST` - Invalid credentials (public error)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/login\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///        \"email\": \"alice@example.com\",\n///        \"password\": \"password123.\"\n///       }'\n/// ```\n///\n/// Notes:\n/// - Token format is `user-\u003cid\u003e.\u003cexp\u003e.sign`, where `\u003cexp\u003e` is epoch seconds (UTC) ~3 days out.\n/// - Cookie name is `auth-token`; in development it uses `SameSite=Lax`, not `Secure`.\n#[utoipa::path(\n\tpost,\n\tpath=\"/login\",\n\tsummary=\"Attempt user login\",\n\tdescription=\"Attempts to login and return with a cookie.\",\n\trequest_body(\n\t\tcontent=LoginRequest,\n\t\tcontent_type=\"application/json\",\n\t\texample=json!({\n\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\"password\": \"Password_123\"\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Login succeeded\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n\ttag=\"Account\"\n)]\npub async fn api_login\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(payload): Json\u003cLoginRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/login 'api_login' - Payload: {:?}\",\n\t\tpayload\n\t);\n\n\t// Get user from database as Account\n\tlet user_result = sqlx::query_as!(\n\t\tAccountRow,\n\t\tr#\"\n        SELECT\n            id,\n            email,\n            password\n        FROM accounts\n        WHERE email = $1\n        \"#,\n\t\tpayload.email\n\t)\n\t.fetch_one(\u0026pool)\n\t.await;\n\n\tmatch user_result {\n\t\tOk(result) =\u003e {\n\t\t\t// Verify password\n\t\t\tlet parsed_hash = PasswordHash::new(\u0026result.password).map_err(AppError::from)?;\n\n\t\t\t// Attempt to match the password hashes\n\t\t\tif let Err(_) =\n\t\t\t\tArgon2::default().verify_password(payload.password.as_bytes(), \u0026parsed_hash)\n\t\t\t{\n\t\t\t\treturn Err(AppError::BadRequest(\"invalid credentials\".to_string()));\n\t\t\t}\n\n\t\t\tset_cookie(result.id, false, cookies, \u0026key);\n\n\t\t\treturn Ok(());\n\t\t}\n\t\tErr(_) =\u003e {\n\t\t\treturn Err(AppError::BadRequest(\"invalid credentials\".to_string()));\n\t\t}\n\t}\n}\n\n/// Returns whether the user has a valid auth token.\n/// Hit this route to validate the `auth-token` private cookie.\n///\n/// # Method\n/// `GET /api/account/validate`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - user has a valid auth token\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n#[utoipa::path(\n\tget,\n\tpath=\"/validate\",\n\tsummary=\"Whether the user has a valid auth-token\",\n\tdescription=\"Returns 200 if token is valid, or 401 if invalid or nonexistant.\",\n\tresponses(\n\t\t(status=200, description=\"User has a valid cookie\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_validate(Extension(user): Extension\u003cAuthUser\u003e) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/validate 'api_validate' - User ID: {}\",\n\t\tuser.id\n\t);\n\tOk(())\n}\n\n/// Get information about the user\n///\n/// # Method\n/// `GET /api/account/current`\n///\n/// # Responses\n/// - `200 OK` - with body: [CurrentResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/account/current\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/current\",\n\tsummary=\"Get account information\",\n\tdescription=\"Returns the user's non-sensitive account information.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"User's non-sensitive account information\",\n\t\t\tbody=CurrentResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\t\"first_name\": \"First\",\n\t\t\t\t\"last_name\": \"Last\",\n\t\t\t\t\"budget_preference\": \"MediumBudget\",\n\t\t\t\t\"risk_preference\": \"Adventurer\",\n\t\t\t\t\"food_allergies\": \"peanuts,vegetarian,pollen\",\n\t\t\t\t\"disabilities\": \"knee replacement\",\n\t\t\t\t\"profile_picture\": \"base64-txt\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_current(\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n) -\u003e ApiResult\u003cJson\u003cCurrentResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/current 'api_current' - User ID: {}\",\n\t\tuser.id\n\t);\n\t// Load current user's full account row\n\tlet account = sqlx::query_as!(\n\t\tCurrentResponse,\n\t\tr#\"\n        SELECT\n            email,\n            first_name,\n            last_name,\n            budget_preference as \"budget_preference: BudgetBucket\",\n            risk_preference as \"risk_preference: RiskTolerence\",\n            COALESCE(food_allergies, '') as \"food_allergies!: String\",\n            COALESCE(disabilities, '') as \"disabilities!: String\",\n\t\t\tCOALESCE(profile_picture, '') as \"profile_picture!: String\"\n        FROM accounts\n        WHERE id = $1\n        \"#,\n\t\tuser.id\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(Json(account))\n}\n\n/// Update information about the user\n///\n/// # Method\n/// `POST /api/account/update`\n///\n/// # Request Body\n/// - `email`: A valid email address (string).\n/// - 'first_name': The user's first name (string).\n/// - 'last_name': The user's last name (string).\n/// - 'password': The user's password (string).\n/// - 'budget_preference': The user's budget preference (string).\n/// - 'risk_preference': The user's risk preference (string).\n/// - 'food_allergies': The user's allergies (string).\n/// - 'disabilities': The user's disabilities (string).\n/// - 'profile_picture': The user's profile pic (string)\n///\n/// # Responses\n/// - `200 OK` - with body: [UpdateResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/account/update\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"email\": \"\",\n///         \"first_name\": \"\",\n///         \"last_name\": \"\",\n///         \"password\": \"\",\n///         \"budget_preference\": \"\",\n///         \"risk_preference\": \"\",\n///         \"food_allergies\": \"\",\n///         \"disabilities\": \"\",\n/// \t\t\"profile_picture\": \"\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/update\",\n\tsummary=\"Update information about the user\",\n\tdescription=\"Update account info with provided data.\",\n\trequest_body(\n\t\tcontent=UpdateRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Non-null fields will update that field. Null fields will not update that field.\",\n\t\texample=json!({\n\t\t\t\"budget_preference\": \"LowBudget\"\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Account info updated successfully\",\n\t\t\tbody=UpdateResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"email\": \"example@gmail.com\",\n\t\t\t\t\"first_name\": \"First\",\n\t\t\t\t\"last_name\": \"last\",\n\t\t\t\t\"budget_preference\": \"LowBudget\",\n\t\t\t\t\"risk_preference\": \"Adventurer\",\n\t\t\t\t\"food_allergies\": \"peanuts,vegetarian,pollen\",\n\t\t\t\t\"disabilities\": \"knee replacement\",\n\t\t\t\t\"profile_picture\": \"base64-txt\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_update(\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tJson(payload): Json\u003cUpdateRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cUpdateResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/update 'api_update' - User ID: {} Payload: {:?}\",\n\t\tuser.id, payload\n\t);\n\n\t// If password is being updated, verify current password first\n\tif let Some(_) = \u0026payload.password {\n\t\tif let Some(current_pw) = \u0026payload.current_password {\n\t\t\t// Get current password hash from database\n\t\t\tlet account_row =\n\t\t\t\tsqlx::query!(r#\"SELECT password FROM accounts WHERE id = $1\"#, user.id)\n\t\t\t\t\t.fetch_one(\u0026pool)\n\t\t\t\t\t.await\n\t\t\t\t\t.map_err(AppError::from)?;\n\n\t\t\t// Verify current password\n\t\t\tlet parsed_hash = PasswordHash::new(\u0026account_row.password).map_err(AppError::from)?;\n\t\t\tif let Err(_) = Argon2::default().verify_password(current_pw.as_bytes(), \u0026parsed_hash) {\n\t\t\t\treturn Err(AppError::BadRequest(\n\t\t\t\t\t\"Current password is incorrect\".to_string(),\n\t\t\t\t));\n\t\t\t}\n\t\t} else {\n\t\t\treturn Err(AppError::BadRequest(\n\t\t\t\t\"Current password is required to change password\".to_string(),\n\t\t\t));\n\t\t}\n\t}\n\n\t// If password provided, hash it before update\n\tlet hashed_password: Option\u003cString\u003e = if let Some(pw) = \u0026payload.password {\n\t\tlet salt = SaltString::generate(\u0026mut OsRng);\n\t\tlet argon2 = Argon2::default();\n\t\tSome(\n\t\t\targon2\n\t\t\t\t.hash_password(pw.as_bytes(), \u0026salt)\n\t\t\t\t.map_err(AppError::from)?\n\t\t\t\t.to_string(),\n\t\t)\n\t} else {\n\t\tNone\n\t};\n\n\tlet account = sqlx::query_as!(\n\t\tUpdateResponse,\n\t\tr#\"\n        UPDATE accounts SET\n            email = COALESCE($1, email),\n            first_name = COALESCE($2, first_name),\n            last_name = COALESCE($3, last_name),\n            password = COALESCE($4, password),\n            budget_preference = COALESCE($5, budget_preference),\n            risk_preference = COALESCE($6, risk_preference),\n            food_allergies = COALESCE($7, food_allergies),\n            disabilities = COALESCE($8, disabilities),\n\t\t\tprofile_picture = COALESCE($9, profile_picture)\n\t\t\t\n        WHERE id = $10\n        RETURNING\n            email,\n            first_name,\n            last_name,\n            budget_preference as \"budget_preference: BudgetBucket\",\n            risk_preference as \"risk_preference: RiskTolerence\",\n            food_allergies,\n            disabilities,\n\t\t\tprofile_picture\n        \"#,\n\t\tpayload.email,\n\t\tpayload.first_name,\n\t\tpayload.last_name,\n\t\thashed_password,\n\t\tpayload.budget_preference as Option\u003cBudgetBucket\u003e,\n\t\tpayload.risk_preference as Option\u003cRiskTolerence\u003e,\n\t\tpayload.food_allergies,\n\t\tpayload.disabilities,\n\t\tpayload.profile_picture,\n\t\tuser.id\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(Json(account))\n}\n\n/// Logout by setting cookie to expired.\n///\n/// # Method\n/// `GET /api/account/logout`\n///\n/// # Responses\n/// - `200 OK` - with body: [UpdateResponse]\n/// - `401 UNAUTHORIZED` - Invalid credentials (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/account/logout\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/logout\",\n\tsummary=\"Logout by returning with expired cookie\",\n\tdescription=\"Sets the HTTP-only cookie as expired, which deauthenticates the user.\",\n\tresponses(\n\t\t(status=200, description=\"Logged out successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Account\"\n)]\npub async fn api_logout\u003cC: CookieStore\u003e(\n\tcookies: \u0026mut C,\n\tExtension(key): Extension\u003cKey\u003e,\n\tExtension(user): Extension\u003cAuthUser\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/account/logout 'api_logout' - User ID: {}\",\n\t\tuser.id\n\t);\n\tset_cookie(user.id, true, cookies, \u0026key);\n\tOk(())\n}\n\n/// Create the account routes with authentication middleware.\n///\n/// # Routes\n/// ## Protected Routes (require authentication)\n/// - `POST /update` - Update user account information\n/// - `GET /current` - Get current user's account details\n/// - `POST /validate` - Validate authentication token\n/// - `GET /logout` - Logout by making cookie expired\n///\n/// ## Public Routes (no authentication required)\n/// - `POST /signup` - Create a new user account\n/// - `POST /login` - Authenticate user and set auth cookie\n///\n/// # Middleware\n/// Protected routes are secured by `middleware_auth` which validates the `auth-token` cookie.\n/// Public routes (signup/login) are accessible without authentication.\npub fn account_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/update\", post(api_update))\n\t\t.route(\"/current\", get(api_current))\n\t\t.route(\"/validate\", get(api_validate))\n\t\t.route(\n\t\t\t\"/logout\",\n\t\t\tget(|mut c, k, u| async move { api_logout::\u003cCookies\u003e(\u0026mut c, k, u).await }),\n\t\t)\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n\t\t.route(\n\t\t\t\"/signup\",\n\t\t\tpost(|mut c, k, p, b| async move { api_signup::\u003cCookies\u003e(\u0026mut c, k, p, b).await }),\n\t\t)\n\t\t.route(\n\t\t\t\"/login\",\n\t\t\tpost(|mut c, k, p, b| async move { api_login::\u003cCookies\u003e(\u0026mut c, k, p, b).await }),\n\t\t)\n}\n","traces":[{"line":73,"address":[41979568,41979815],"length":1,"stats":{"Line":1}},{"line":74,"address":[41979596,41979689],"length":1,"stats":{"Line":2}},{"line":90,"address":[37794897,37794903,37798001,37798007,37791824,37794928],"length":1,"stats":{"Line":2}},{"line":92,"address":[37794993,37791889],"length":1,"stats":{"Line":2}},{"line":93,"address":[37791951,37795055],"length":1,"stats":{"Line":2}},{"line":94,"address":[37791989,37795093],"length":1,"stats":{"Line":2}},{"line":98,"address":[37795304,37795133,37792029,37795392,37792200,37792288],"length":1,"stats":{"Line":6}},{"line":99,"address":[37795306,37792202],"length":1,"stats":{"Line":1}},{"line":108,"address":[37795159,37792055],"length":1,"stats":{"Line":2}},{"line":110,"address":[37795424,37792320],"length":1,"stats":{"Line":2}},{"line":112,"address":[37792565,37795669,37796135,37793031,37792644,37795748],"length":1,"stats":{"Line":5}},{"line":119,"address":[37797856,37794335,37797691,37797605,37794587,37797439,37794752,37792994,37794501,37796098],"length":1,"stats":{"Line":10}},{"line":120,"address":[37794509,37794441,37794460,37797564,37797545,37797979,37794875,37797613],"length":1,"stats":{"Line":4}},{"line":122,"address":[37794611,37797715],"length":1,"stats":{"Line":2}},{"line":124,"address":[37797750,37797768,37794674,37797778,37794664,37794646],"length":1,"stats":{"Line":6}},{"line":125,"address":[37794666,37797770],"length":1,"stats":{"Line":0}},{"line":127,"address":[37794656,37797760],"length":1,"stats":{"Line":2}},{"line":129,"address":[37794705,37797809],"length":1,"stats":{"Line":2}},{"line":130,"address":[37794792,37797896],"length":1,"stats":{"Line":2}},{"line":134,"address":[37797950,37794846],"length":1,"stats":{"Line":2}},{"line":195,"address":[37801280,37801408],"length":1,"stats":{"Line":2}},{"line":201,"address":[37802141,37801995,37810451,37809899,37802547,37810045],"length":1,"stats":{"Line":5}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[37810419,37802515,37811702,37803798],"length":1,"stats":{"Line":4}},{"line":208,"address":[37811791,37803887],"length":1,"stats":{"Line":1}},{"line":212,"address":[37804153,37804979,37811987,37804021,37804566,37804701,37804083,37812057,37804756,37811925,37812605,37812660,37812883,37812470],"length":1,"stats":{"Line":6}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[37812544,37804640],"length":1,"stats":{"Line":2}},{"line":215,"address":[37804686,37804818,37802053,37812722,37809957,37804734,37812976,37812590,37812638,37805072],"length":1,"stats":{"Line":8}},{"line":217,"address":[37812998,37805094,37805217,37813121],"length":1,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[37814810,37813135,37806906,37805231],"length":1,"stats":{"Line":2}},{"line":221,"address":[37813042,37805138],"length":1,"stats":{"Line":0}},{"line":222,"address":[37807035,37813103,37805199,37814939],"length":1,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[37805273,37813177],"length":1,"stats":{"Line":2}},{"line":231,"address":[37805303,37813207],"length":1,"stats":{"Line":2}},{"line":232,"address":[37813233,37805469,37805535,37806901,37813373,37814805,37813439,37805329],"length":1,"stats":{"Line":4}},{"line":233,"address":[37805346,37813250],"length":1,"stats":{"Line":2}},{"line":234,"address":[37805446,37805503,37813350,37813407],"length":1,"stats":{"Line":2}},{"line":238,"address":[37815387,37814783,37813795,37813610,37805891,37814725,37813725,37807483,37805706,37806638,37806879,37805821,37806821,37814542],"length":1,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[37814613,37806709],"length":1,"stats":{"Line":2}},{"line":248,"address":[38937746,38938306],"length":1,"stats":{"Line":8}},{"line":250,"address":[37807545,37815449],"length":1,"stats":{"Line":2}},{"line":251,"address":[37815560,37807656],"length":1,"stats":{"Line":2}},{"line":252,"address":[37808119,37816023,37815574,37807670],"length":1,"stats":{"Line":3}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[37808079,37815983],"length":1,"stats":{"Line":2}},{"line":259,"address":[37809274,37817178],"length":1,"stats":{"Line":2}},{"line":261,"address":[37817216,37815486,37809312,37807582],"length":1,"stats":{"Line":0}},{"line":317,"address":[37823136,37823008],"length":1,"stats":{"Line":2}},{"line":323,"address":[37824171,37828182,37823750,37828057,37828603,37823625],"length":1,"stats":{"Line":5}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[37828556,37825992,37826264,37825857,37829885,37830289,37830476,37826044,37825386,37830424,37829818,37824124,37825453,37830696],"length":1,"stats":{"Line":6}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[37825931,37830363],"length":1,"stats":{"Line":2}},{"line":342,"address":[38936932,38936612],"length":1,"stats":{"Line":8}},{"line":344,"address":[37826406,37830838],"length":1,"stats":{"Line":2}},{"line":345,"address":[37830909,37826477],"length":1,"stats":{"Line":2}},{"line":347,"address":[37826616,37826541,37830973,37831617,37831048,37827185],"length":1,"stats":{"Line":4}},{"line":350,"address":[37831384,37826952],"length":1,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[37831392,37827032,37826960,37831464],"length":1,"stats":{"Line":2}},{"line":356,"address":[37826999,37831431],"length":1,"stats":{"Line":1}},{"line":358,"address":[37831603,37827171],"length":1,"stats":{"Line":1}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[37826443,37831731,37830875,37827299],"length":1,"stats":{"Line":2}},{"line":395,"address":[42111264,42111268],"length":1,"stats":{"Line":4}},{"line":396,"address":[37835634,37836102,37835530],"length":1,"stats":{"Line":2}},{"line":400,"address":[37836024],"length":1,"stats":{"Line":1}},{"line":449,"address":[42116880],"length":1,"stats":{"Line":1}},{"line":453,"address":[37837904,37838325,37837778],"length":1,"stats":{"Line":3}},{"line":458,"address":[37840482,37839597,37838278,37840422,37840133,37840179,37840558,37840001,37839530],"length":1,"stats":{"Line":4}},{"line":475,"address":[37840075],"length":1,"stats":{"Line":1}},{"line":476,"address":[39101632],"length":1,"stats":{"Line":4}},{"line":477,"address":[37840526,37840459],"length":1,"stats":{"Line":1}},{"line":479,"address":[37840662],"length":1,"stats":{"Line":1}},{"line":558,"address":[42124560],"length":1,"stats":{"Line":1}},{"line":563,"address":[37845154,37844582,37844728],"length":1,"stats":{"Line":3}},{"line":569,"address":[37845102],"length":1,"stats":{"Line":1}},{"line":570,"address":[37846565,37846717],"length":1,"stats":{"Line":2}},{"line":572,"address":[37846724,37847867,37847471,37851245,37847278,37846795,37847968,37846865,37847413,37848035],"length":1,"stats":{"Line":4}},{"line":574,"address":[37847352],"length":1,"stats":{"Line":1}},{"line":575,"address":[39099167],"length":1,"stats":{"Line":4}},{"line":576,"address":[37847945,37848003],"length":1,"stats":{"Line":1}},{"line":579,"address":[37851240,37848140,37848219],"length":1,"stats":{"Line":2}},{"line":580,"address":[37848464],"length":1,"stats":{"Line":1}},{"line":581,"address":[37848644],"length":1,"stats":{"Line":0}},{"line":582,"address":[37848595],"length":1,"stats":{"Line":0}},{"line":586,"address":[37847499],"length":1,"stats":{"Line":0}},{"line":587,"address":[37846761],"length":1,"stats":{"Line":0}},{"line":593,"address":[37848868,37848812,37846635],"length":1,"stats":{"Line":3}},{"line":594,"address":[37848836],"length":1,"stats":{"Line":1}},{"line":595,"address":[37848873],"length":1,"stats":{"Line":1}},{"line":597,"address":[37849569,37849075,37849009],"length":1,"stats":{"Line":1}},{"line":598,"address":[37848900],"length":1,"stats":{"Line":1}},{"line":599,"address":[37849043,37848986],"length":1,"stats":{"Line":1}},{"line":600,"address":[37849212],"length":1,"stats":{"Line":1}},{"line":603,"address":[37848851],"length":1,"stats":{"Line":1}},{"line":606,"address":[37849446,37849292,37850983,37849417,37851166,37849574,37851505,37851218,37851442,37849644,37851581],"length":1,"stats":{"Line":6}},{"line":635,"address":[37849396],"length":1,"stats":{"Line":1}},{"line":636,"address":[37849425],"length":1,"stats":{"Line":1}},{"line":642,"address":[37851054],"length":1,"stats":{"Line":1}},{"line":643,"address":[37851452,37851151,37844661,37851199,37851258],"length":1,"stats":{"Line":4}},{"line":644,"address":[37851482,37851549],"length":1,"stats":{"Line":1}},{"line":646,"address":[37851685],"length":1,"stats":{"Line":1}},{"line":680,"address":[37858912],"length":1,"stats":{"Line":1}},{"line":685,"address":[37859253,37859357,37859768],"length":1,"stats":{"Line":2}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[37859731],"length":1,"stats":{"Line":1}},{"line":690,"address":[37860947],"length":1,"stats":{"Line":1}},{"line":709,"address":[42094644,42094619,42093648],"length":1,"stats":{"Line":1}},{"line":710,"address":[42093970,42094478,42093782,42094421,42093913,42094047,42094238,42094344,42093655,42094104,42094548,42093836,42094181,42094307],"length":1,"stats":{"Line":14}},{"line":711,"address":[42093741,42093841,42093734,42094715,42093795],"length":1,"stats":{"Line":3}},{"line":712,"address":[42094703,42093926,42093865,42093975,42093872],"length":1,"stats":{"Line":3}},{"line":713,"address":[42094109,42094060,42093999,42094691,42094006],"length":1,"stats":{"Line":3}},{"line":716,"address":[37798032,37798490,37798187,37798687,37798144,37798080],"length":1,"stats":{"Line":5}},{"line":718,"address":[42094259,42094667,42094349,42094320,42094266],"length":1,"stats":{"Line":3}},{"line":721,"address":[37799393,37798987,37798944,37799252,37798871,37798816,37799600],"length":1,"stats":{"Line":5}},{"line":725,"address":[37799783,37799856,37800257,37800458,37800119,37799899,37799728],"length":1,"stats":{"Line":5}}],"covered":102,"coverable":129},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","chat.rs"],"content":"use axum::{\n\tExtension, Json,\n\textract::Path,\n\trouting::{delete, get, post},\n};\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse utoipa::OpenApi;\n\nuse crate::{\n\tagent::configs::orchestrator::AgentType,\n\tcontrollers::{AxumRouter, itinerary::insert_event_list},\n\terror::{ApiResult, AppError},\n\tglobal::MESSAGE_PAGE_LEN,\n\thttp_models::{\n\t\tchat_session::{\n\t\t\tChatsResponse, NewChatResponse, ProgressRequest, ProgressResponse, RenameRequest,\n\t\t},\n\t\tevent::Event,\n\t\titinerary::{EventDay, Itinerary},\n\t\tmessage::{\n\t\t\tMessage, MessagePageRequest, MessagePageResponse, SendMessageRequest,\n\t\t\tSendMessageResponse, UpdateMessageRequest,\n\t\t},\n\t},\n\tmiddleware::{AuthUser, middleware_auth},\n\tsql_models::{\n\t\tLlmProgress,\n\t\tmessage::{ChatSessionRow, MessageRow},\n\t},\n\tswagger::SecurityAddon,\n};\n\nuse langchain_rust::chain::Chain;\nuse langchain_rust::prompt_args;\nuse tracing::{debug, error, info};\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_chats,\n\t\tapi_new_chat,\n\t\tapi_message_page,\n\t\tapi_send_message,\n\t\tapi_update_message,\n\t\tapi_delete_chat,\n\t\tapi_rename,\n\t\tapi_progress\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity((\"set-cookie\"=[])),\n    info(\n    \ttitle=\"Chat Routes\",\n    \tdescription = \"API endpoints dealing with chatting and the home page.\"\n    ),\n    tags((name=\"Chat\"))\n)]\npub struct ChatApiDoc;\n\n/// Sends message and latest itinerary in chat session to llm, and waits for response.\n///\n/// When the bot replies, it's message and itinerary are inserted into the db.\n/// # Warning!\n/// Assumes the user's message has already been inserted into the db.\nasync fn send_message_to_llm(\n\ttext: \u0026str,\n\taccount_id: i32,\n\tchat_session_id: i32,\n\titinerary_id: Option\u003ci32\u003e,\n\tpool: \u0026PgPool,\n\tagent: \u0026AgentType,\n\tchat_session_id_atomic: \u0026std::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e,\n\tcontext_store: \u0026crate::agent::models::context::SharedContextStore,\n) -\u003e ApiResult\u003cMessage\u003e {\n\t// Give the LLM an itinerary for context\n\tlet itinerary_id = match itinerary_id {\n\t\tSome(id) =\u003e Some(id), //use the provided itinerary\n\t\tNone =\u003e {\n\t\t\t//use the latest itinerary from the chat session\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tSELECT m.itinerary_id\n\t\t\t\tFROM messages m\n\t\t\t\tINNER JOIN chat_sessions c\n\t\t\t\tON m.chat_session_id=c.id\n\t\t\t\tWHERE\n\t\t\t\t\tc.account_id=$1 AND\n\t\t\t\t\tc.id=$2 AND\n\t\t\t\t\tm.itinerary_id IS NOT NULL\n\t\t\t\tORDER BY m.timestamp DESC\n\t\t\t\tLIMIT 1;\n\t\t\t\t\"#,\n\t\t\t\taccount_id,\n\t\t\t\tchat_session_id\n\t\t\t)\n\t\t\t.fetch_optional(pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.map(|record| record.itinerary_id.unwrap())\n\t\t}\n\t};\n\tlet _context_itinerary = match itinerary_id {\n\t\tSome(id) =\u003e Some(\n\t\t\tcrate::controllers::itinerary::api_get_itinerary(\n\t\t\t\tExtension(AuthUser { id: account_id }),\n\t\t\t\taxum::extract::Path(id),\n\t\t\t\tExtension(pool.clone()),\n\t\t\t)\n\t\t\t.await?,\n\t\t),\n\t\tNone =\u003e None,\n\t};\n\n\t// Always invoke the agent (it will use MockLLM when DEPLOY_LLM != \"1\")\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\taccount_id = account_id,\n\t\t\"Invoking orchestrator agent\"\n\t);\n\tdebug!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tuser_input = text,\n\t\t\"Orchestrator agent input\"\n\t);\n\n\t// We no longer persist live agent context in the database; all dynamic context\n\t// lives in the in-memory SharedContextStore. These DB-based context logs are\n\t// intentionally removed to avoid confusion.\n\n\t// Initialize context with chat_session_id and user_id BEFORE agent runs\n\t// This prevents race conditions from global atomics\n\t// IMPORTANT: Only initialize if context doesn't exist - preserve existing trip_context!\n\t{\n\t\tuse crate::agent::models::context::{ContextData, TripContext};\n\t\tlet mut store_guard = context_store.write().await;\n\n\t\t// Only insert if this chat_session doesn't have context yet\n\t\tif !store_guard.contains_key(\u0026chat_session_id) {\n\t\t\tstore_guard.insert(\n\t\t\t\tchat_session_id,\n\t\t\t\tContextData {\n\t\t\t\t\tchat_session_id,\n\t\t\t\t\tuser_id: account_id,\n\t\t\t\t\tuser_profile: None,\n\t\t\t\t\tchat_history: vec![],\n\t\t\t\t\ttrip_context: TripContext::default(),\n\t\t\t\t\tactive_itinerary: None,\n\t\t\t\t\tevents: vec![],\n\t\t\t\t\ttool_history: vec![],\n\t\t\t\t\tpipeline_stage: None,\n\t\t\t\t\tresearched_events: vec![],\n\t\t\t\t\tconstrained_events: vec![],\n\t\t\t\t\toptimized_events: vec![],\n\t\t\t\t\tconstraints: vec![],\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tchat_id = chat_session_id,\n\t\t\t\t\"Initialized new context for chat session\"\n\t\t\t);\n\t\t} else {\n\t\t\t// Context exists - just update user_id in case it changed\n\t\t\tif let Some(ctx) = store_guard.get_mut(\u0026chat_session_id) {\n\t\t\t\tctx.user_id = account_id;\n\t\t\t}\n\n\t\t\tinfo!(\n\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\tchat_id = chat_session_id,\n\t\t\t\t\"Reusing existing context for chat session\"\n\t\t\t);\n\t\t}\n\t}\n\n\t// Set the atomic so tools can look up the context\n\tuse std::sync::atomic::Ordering;\n\tchat_session_id_atomic.store(chat_session_id, Ordering::Relaxed);\n\n\t// Invoke the agent\n\tlet ai_text = {\n\t\tlet agent_guard = agent.lock().await;\n\n\t\tdebug!(\n\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\tchat_session_id = chat_session_id,\n\t\t\tinput_text = text,\n\t\t\t\"Invoking orchestrator agent\"\n\t\t);\n\n\t\tagent_guard\n\t\t\t.invoke(prompt_args! {\n\t\t\t\t\"input\" =\u003e text,\n\t\t\t})\n\t\t\t.await\n\t\t\t.map_err(|e| {\n\t\t\t\terror!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\terror = %e,\n\t\t\t\t\terror_debug = ?e,\n\t\t\t\t\t\"Orchestrator agent error - full details\"\n\t\t\t\t);\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\terror = %e,\n\t\t\t\t\t\"Orchestrator agent error\"\n\t\t\t\t);\n\t\t\t\tAppError::Internal(format!(\"AI agent error: {}\", e))\n\t\t\t})?\n\t};\n\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tresponse_length = ai_text.len(),\n\t\t\"Orchestrator agent completed\"\n\t);\n\tdebug!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\tresponse = ai_text,\n\t\t\"Orchestrator agent output\"\n\t);\n\n\t// Context state AFTER agent invocation is now entirely in-memory as well.\n\t//\n\t// SAFETY GUARD: If the orchestrator ever returns a user-visible string\n\t// that still contains the internal \"Ready for research\" phrase, treat it\n\t// as a pipeline-ready signal instead of sending it to the user.\n\tif ai_text.contains(\"Ready for research\") {\n\t\tinfo!(\n\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\tchat_session_id = chat_session_id,\n\t\t\t\"Detected 'Ready for research' sentinel in orchestrator output; refusing to return it directly to user\"\n\t\t);\n\n\t\t// Try to return the most recent non-user message instead (typically the\n\t\t// last clarification the user already saw). If none exists, fall\n\t\t// through and let normal handling occur.\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\tFROM messages\n\t\t\tWHERE chat_session_id = $1 AND is_user = FALSE\n\t\t\tORDER BY timestamp DESC\n\t\t\tLIMIT 1\n\t\t\t\"#,\n\t\t\tchat_session_id\n\t\t)\n\t\t.fetch_optional(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tif let Some(msg) = record {\n\t\t\treturn Ok(Message {\n\t\t\t\tid: msg.id,\n\t\t\t\tis_user: false,\n\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\ttext: msg.text,\n\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t});\n\t\t}\n\t}\n\n\t// Check if RespondToUserTool already inserted the message\n\t// Format: \"MESSAGE_INSERTED:\u003cmessage_id\u003e:\u003cmessage_text\u003e\"\n\tif ai_text.starts_with(\"MESSAGE_INSERTED:\") {\n\t\tlet parts: Vec\u003c\u0026str\u003e = ai_text.splitn(3, ':').collect();\n\t\tif parts.len() == 3 {\n\t\t\tif let Ok(message_id) = parts[1].parse::\u003ci32\u003e() {\n\t\t\t\t// Fetch the message that was already inserted by RespondToUserTool\n\t\t\t\tlet record = sqlx::query!(\n\t\t\t\t\tr#\"\n\t\t\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\t\t\tFROM messages\n\t\t\t\t\tWHERE id = $1 AND chat_session_id = $2\n\t\t\t\t\t\"#,\n\t\t\t\t\tmessage_id,\n\t\t\t\t\tchat_session_id\n\t\t\t\t)\n\t\t\t\t.fetch_optional(pool)\n\t\t\t\t.await\n\t\t\t\t.map_err(AppError::from)?;\n\n\t\t\t\tif let Some(msg) = record {\n\t\t\t\t\tinfo!(\n\t\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\t\tmessage_id = msg.id,\n\t\t\t\t\t\t\"Message already inserted by RespondToUserTool, returning it\"\n\t\t\t\t\t);\n\t\t\t\t\treturn Ok(Message {\n\t\t\t\t\t\tid: msg.id,\n\t\t\t\t\t\tis_user: false,\n\t\t\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\t\t\ttext: msg.text,\n\t\t\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the response is plain readable text (not JSON, not MESSAGE_INSERTED),\n\t// it's likely from ask_for_clarification tool which already inserted it\n\t// Fetch the most recent non-user message for this chat session\n\tif !ai_text.trim().starts_with('{')\n\t\t\u0026\u0026 !ai_text.trim().starts_with('[')\n\t\t\u0026\u0026 !ai_text.starts_with(\"MESSAGE_INSERTED:\")\n\t\t\u0026\u0026 !ai_text.starts_with(\"FINAL_ANSWER:\")\n\t{\n\t\t// This looks like plain readable text - tool already inserted it, so fetch it\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tSELECT id, timestamp, text, itinerary_id\n\t\t\tFROM messages\n\t\t\tWHERE chat_session_id = $1 AND is_user = FALSE\n\t\t\tORDER BY timestamp DESC\n\t\t\tLIMIT 1\n\t\t\t\"#,\n\t\t\tchat_session_id\n\t\t)\n\t\t.fetch_optional(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tif let Some(msg) = record {\n\t\t\t// Verify the text matches (tool just inserted it)\n\t\t\tif msg.text.trim() == ai_text.trim() {\n\t\t\t\tinfo!(\n\t\t\t\t\ttarget: \"orchestrator_pipeline\",\n\t\t\t\t\tchat_session_id = chat_session_id,\n\t\t\t\t\tmessage_id = msg.id,\n\t\t\t\t\t\"Found matching message inserted by tool, returning it\"\n\t\t\t\t);\n\t\t\t\treturn Ok(Message {\n\t\t\t\t\tid: msg.id,\n\t\t\t\t\tis_user: false,\n\t\t\t\t\ttimestamp: msg.timestamp,\n\t\t\t\t\ttext: msg.text,\n\t\t\t\t\titinerary_id: msg.itinerary_id,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if we're using MockLLM\n\tlet use_mock = std::env::var(\"DEPLOY_LLM\").unwrap_or_default() != \"1\";\n\n\tif use_mock {\n\t\t// MockLLM fallback: Create and insert a dummy itinerary\n\t\tlet mut ai_itinerary = Itinerary {\n\t\t\tid: 0,\n\t\t\tstart_date: NaiveDate::parse_from_str(\"2025-11-05\", \"%Y-%m-%d\").unwrap(),\n\t\t\tend_date: NaiveDate::parse_from_str(\"2025-11-06\", \"%Y-%m-%d\").unwrap(),\n\t\t\tevent_days: vec![\n\t\t\t\tEventDay {\n\t\t\t\t\tmorning_events: vec![Event {\n\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1114 Shannon Ln\")),\n\t\t\t\t\t\tpostal_code: Some(17013),\n\t\t\t\t\t\tcity: Some(String::from(\"Carlisle\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Hike\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"A beautiful stroll along a river in this cute small town.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Family Walking Path\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tafternoon_events: vec![Event {\n\t\t\t\t\t\tid: 3,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"200 E 42nd St\")),\n\t\t\t\t\t\tpostal_code: Some(10017),\n\t\t\t\t\t\tcity: Some(String::from(\"New York\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"World famous art museum with a focus on modern works, including Starry Starry Night by VanGough.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Museum of Modern Art- MoMA\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tevening_events: vec![Event {\n\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 S Broad St\")),\n\t\t\t\t\t\tpostal_code: Some(19107),\n\t\t\t\t\t\tcity: Some(String::from(\"Philadelphia\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Concert\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Music center which hosts local and national bands.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Jazz night at Broad Street\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tdate: NaiveDate::parse_from_str(\"2025-11-05\", \"%Y-%m-%d\").unwrap(),\n\t\t\t\t},\n\t\t\t\tEventDay {\n\t\t\t\t\tmorning_events: vec![Event {\n\t\t\t\t\t\tid: 5,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 Citizens Bank Way\")),\n\t\t\t\t\t\tpostal_code: Some(19148),\n\t\t\t\t\t\tcity: Some(String::from(\"Philadelphia\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"USA\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Sports\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"A Phillies baseball game is a must-do for locals and visitors alike.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Phillies Baseball Game\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tafternoon_events: vec![Event {\n\t\t\t\t\t\tid: 7,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"1 Rue de la Seine\")),\n\t\t\t\t\t\tpostal_code: Some(0),\n\t\t\t\t\t\tcity: Some(String::from(\"Paris\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"France\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Explore the beautiful landmark of Paris.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"Eiffel Tower\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tevening_events: vec![Event {\n\t\t\t\t\t\tid: 8,\n\t\t\t\t\t\tstreet_address: Some(String::from(\"3 Rue de la Museu\")),\n\t\t\t\t\t\tpostal_code: Some(0),\n\t\t\t\t\t\tcity: Some(String::from(\"Paris\")),\n\t\t\t\t\t\tcountry: Some(String::from(\"France\")),\n\t\t\t\t\t\tevent_type: Some(String::from(\"Museum\")),\n\t\t\t\t\t\tevent_description: Some(String::from(\n\t\t\t\t\t\t\t\"Wander the halls of the world famous art museum.\",\n\t\t\t\t\t\t)),\n\t\t\t\t\t\tevent_name: String::from(\"le Louvre\"),\n\t\t\t\t\t\t..Default::default()\n\t\t\t\t\t}],\n\t\t\t\t\tdate: NaiveDate::parse_from_str(\"2025-11-06\", \"%Y-%m-%d\").unwrap(),\n\t\t\t\t},\n\t\t\t],\n\t\t\tchat_session_id: None,\n\t\t\ttitle: String::from(\"World Tour 11/5-15 2025\"),\n\t\t\tunassigned_events: vec![],\n\t\t};\n\n\t\t// Insert generated itinerary into db\n\t\tlet inserted_itinerary_id = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title)\n\t\t\tVALUES ($1, FALSE, $2, $3, $4, FALSE, $5)\n\t\t\tRETURNING id;\n\t\t\t\"#,\n\t\t\taccount_id,\n\t\t\tai_itinerary.start_date,\n\t\t\tai_itinerary.end_date,\n\t\t\tchat_session_id,\n\t\t\tai_itinerary.title\n\t\t)\n\t\t.fetch_one(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.id;\n\n\t\tai_itinerary.id = inserted_itinerary_id;\n\n\t\t// Insert itinerary events\n\t\tinsert_event_list(ai_itinerary, pool).await?;\n\n\t\t// Insert bot message with itinerary\n\t\tlet record = sqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\t\tVALUES ($1, $2, FALSE, NOW(), $3)\n\t\t\tRETURNING id, timestamp;\n\t\t\t\"#,\n\t\t\tchat_session_id,\n\t\t\tinserted_itinerary_id,\n\t\t\tai_text.clone()\n\t\t)\n\t\t.fetch_one(pool)\n\t\t.await\n\t\t.map_err(AppError::from)?;\n\n\t\tlet (bot_message_id, timestamp) = (record.id, record.timestamp);\n\n\t\treturn Ok(Message {\n\t\t\tid: bot_message_id,\n\t\t\tis_user: false,\n\t\t\ttimestamp,\n\t\t\ttext: ai_text,\n\t\t\titinerary_id: Some(inserted_itinerary_id),\n\t\t});\n\t}\n\n\t// When using real LLM: The respond_to_user tool handles message insertion,\n\t// so we should never reach this point. If we do, insert a plain message without itinerary.\n\tinfo!(\n\t\ttarget: \"orchestrator_pipeline\",\n\t\tchat_session_id = chat_session_id,\n\t\t\"Fallback: Inserting message without itinerary (real LLM path)\"\n\t);\n\n\tlet record = sqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\tVALUES ($1, NULL, FALSE, NOW(), $2)\n\t\tRETURNING id, timestamp;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tai_text.clone()\n\t)\n\t.fetch_one(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet (bot_message_id, timestamp) = (record.id, record.timestamp);\n\n\tlet pool = pool.clone();\n\ttokio::spawn(async move {\n\t\t_ = sqlx::query!(\n\t\t\tr#\"UPDATE chat_sessions\n\t\tSET llm_progress=$1\n\t\tWHERE id=$2 AND account_id=$3;\"#,\n\t\t\tLlmProgress::Ready as _,\n\t\t\tchat_session_id,\n\t\t\taccount_id,\n\t\t)\n\t\t.execute(\u0026pool)\n\t\t.await;\n\t});\n\n\tOk(Message {\n\t\tid: bot_message_id,\n\t\tis_user: false,\n\t\ttimestamp,\n\t\ttext: ai_text,\n\t\titinerary_id: None,\n\t})\n}\n\n/// Fetch all the chat session ids belonging to the user to made the request\n///\n/// # Method\n/// `GET /api/chat/chats`\n///\n/// # Responses\n/// - `200 OK` - [ChatsResponse] - list of chat session ids\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/chat/chats\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/chats\",\n\tsummary=\"Fetch user's chat session IDs\",\n\tdescription=\"Fetches a list of all chat session IDs belonging to the user.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Successfully retrieved chat sessions\",\n\t\t\tbody=ChatsResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"chat_sessions\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"title\": \"Berlin, Germany\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 17,\n\t\t\t\t\t\t\"title\": \"Shanghai, China\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 41,\n\t\t\t\t\t\t\"title\": \"Miami, Florida, USA\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_chats(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cChatsResponse\u003e\u003e {\n\tOk(Json(ChatsResponse {\n\t\tchat_sessions: sqlx::query_as!(\n\t\t\tChatSessionRow,\n\t\t\tr#\"\n\t\t\tSELECT id, title from chat_sessions\n\t\t\tWHERE account_id=$1;\n\t\t\t\"#,\n\t\t\tuser.id\n\t\t)\n\t\t.fetch_all(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?,\n\t}))\n}\n\n/// Get a page of messages from this chat session belonging to the user who made the request\n///\n/// # Method\n/// `POST /api/chat/messagePage`\n///\n/// # Request Body\n/// - [MessagePageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [MessagePageResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// Fetch latest massages\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/messagePage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 3\n///       }'\n/// ```\n/// Fetch messages ending with specific message\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/messagePage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 3,\n///         \"message_id\": 6\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/messagePage\",\n\tsummary=\"Fetch a page of messages from a chat session\",\n\tdescription=\"If no message id is provided, this fetches the latest messages from the chat session. If a message id is provided, that message and messages preceeding it will be fetched.\",\n\trequest_body(\n\t\tcontent=MessagePageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Message id may be omitted to get the latest messages\",\n\t\texamples(\n\t\t\t(\"Latest Messages\"=(\n\t\t\t\tsummary=\"Fetch the latest messages from a chat session\",\n\t\t\t\tvalue=json!({\n\t\t\t\t\t\"chat_session_id\": 4\n\t\t\t\t})\n\t\t\t)),\n\t\t\t(\"Specific Messages\"=(\n\t\t\t\tsummary=\"Fetch a specific page of messages from a chat session\",\n\t\t\t\tvalue=json!({\n\t\t\t\t\t\"chat_session_id\": 4,\n\t\t\t\t\t\"message_id\": 4\n\t\t\t\t})\n\t\t\t))\n\t\t)\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Messages retrieved successfully\",\n\t\t\tbody=MessagePageResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texamples(\n\t\t\t\t(\"Latest Messages\"=(\n\t\t\t\t\tsummary=\"The latest messages from a chat session\",\n\t\t\t\t\tvalue=json!({\n\t\t\t\t\t\t\"message_page\": [\n\t\t\t\t\t\t\t{\"id\": 6, \"is_user\": true, \"timestamp\": \"2025-10-14 11-34-19\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 10, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-24\", \"text\": \"Bot reply\", \"itinerary_id\": 2},\n\t\t\t\t\t\t\t{\"id\": 12, \"is_user\": true, \"timestamp\": \"2025-10-14 11-34-42\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 22, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-56\", \"text\": \"Bot reply\", \"itinerary_id\": 5},\n\t\t\t\t\t\t\t{\"id\": 26, \"is_user\": true, \"timestamp\": \"2025-10-14 11-35-10\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 33, \"is_user\": false, \"timestamp\": \"2025-10-14 11-35-19\", \"text\": \"Bot reply\", \"itinerary_id\": 9},\n\t\t\t\t\t\t\t{\"id\": 39, \"is_user\": true, \"timestamp\": \"2025-10-14 11-35-31\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 44, \"is_user\": false, \"timestamp\": \"2025-10-14 11-35-54\", \"text\": \"Bot reply\", \"itinerary_id\": 14},\n\t\t\t\t\t\t\t{\"id\": 61, \"is_user\": true, \"timestamp\": \"2025-10-14 11-36-24\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 72, \"is_user\": false, \"timestamp\": \"2025-10-14 11-36-29\", \"text\": \"Bot reply\", \"itinerary_id\": 27}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"prev_message_id\": 4\n\t\t\t\t\t})\n\t\t\t\t)),\n\t\t\t\t(\"Specific Messages\"=(\n\t\t\t\t\tsummary=\"A specific page of messages from a chat session\",\n\t\t\t\t\tvalue=json!({\n\t\t\t\t\t\t\"message_page\": [\n\t\t\t\t\t\t\t{\"id\": 1, \"is_user\": true, \"timestamp\": \"2025-10-14 11-33-21\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 2, \"is_user\": false, \"timestamp\": \"2025-10-14 11-33-35\", \"text\": \"Bot reply\", \"itinerary_id\": 1},\n\t\t\t\t\t\t\t{\"id\": 3, \"is_user\": true, \"timestamp\": \"2025-10-14 11-33-45\", \"text\": \"User message\"},\n\t\t\t\t\t\t\t{\"id\": 4, \"is_user\": false, \"timestamp\": \"2025-10-14 11-34-01\", \"text\": \"Bot reply\", \"itinerary_id\": 1},\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"prev_message_id\": null\n\t\t\t\t\t})\n\t\t\t\t))\n\t\t\t)\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_message_page(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(MessagePageRequest {\n\t\tchat_session_id,\n\t\tmessage_id,\n\t}): Json\u003cMessagePageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cMessagePageResponse\u003e\u003e {\n\tlet mut message_page: Vec\u003cMessage\u003e = sqlx::query_as!(\n\t\tMessageRow,\n\t\tr#\"\n\t\tSELECT\n\t\t\tm.id,\n\t\t\tm.chat_session_id,\n\t\t\tm.itinerary_id,\n\t\t\tm.is_user,\n\t\t\tm.timestamp,\n\t\t\tm.text\n\t\tFROM messages m\n\t\tINNER JOIN chat_sessions c\n\t\tON m.chat_session_id=c.id\n\t\tWHERE\n\t\t\tc.id=$1 AND\n\t\t\tc.account_id=$2 AND\n\t\t\t(\n\t\t\t\t$3::int IS NULL OR\n\t\t\t\tm.timestamp \u003c= (SELECT timestamp FROM messages WHERE id=$3)\n\t\t\t)\n\t\tORDER BY m.timestamp DESC\n\t\tLIMIT $4 + 1;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id,\n\t\tmessage_id,\n\t\tMESSAGE_PAGE_LEN\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.into_iter()\n\t.rev()\n\t.map(|msg_row| Message {\n\t\tid: msg_row.id,\n\t\tis_user: msg_row.is_user,\n\t\ttimestamp: msg_row.timestamp,\n\t\ttext: msg_row.text,\n\t\titinerary_id: msg_row.itinerary_id,\n\t})\n\t.collect();\n\n\tlet prev_message_id = if message_page.len() == MESSAGE_PAGE_LEN as usize + 1 {\n\t\t// there might be a better way to do this, but it should work, and it's only O(MESSAGE_PAGE_LEN) time complexity\n\t\tSome(message_page.remove(0).id)\n\t} else {\n\t\tNone\n\t};\n\n\tOk(Json(MessagePageResponse {\n\t\tmessage_page,\n\t\tprev_message_id,\n\t}))\n}\n\n/// Update an existing message with new text, and get a message back from the LLM\n///\n/// # Method\n/// `POST /api/chat/updateMessage`\n///\n/// # Request Body\n/// - [UpdateMessageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [Message] - message from LLM\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided message id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/updateMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"message_id\": 3,\n///         \"new_text\": \"Updated message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/updateMessage\",\n\tsummary=\"Update the text of a message and wait for a reply from the LLM\",\n\tdescription=\"Updating a message deletes all proceeding messages, updates the text of the given message, and returns a response from the LLM.\",\n\trequest_body(\n\t\tcontent=UpdateMessageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Itinerary id is optional and is used to give context to the LLM.\",\n\t\texample=json!({\n\t\t\t\"message_id\": 41,\n\t\t\t\"new_text\": \"Updated message content\",\n\t\t\t\"itinerary_id\": 17\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Message updated, and LLM replied successfully\",\n\t\t\tbody=Message,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"id\": 43,\n\t\t\t\t\"is_user\": false,\n\t\t\t\t\"timestamp\": \"2025-10-14 11-38-52\",\n\t\t\t\t\"text\": \"Bot reply\",\n\t\t\t\t\"itinerary_id\": 19\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Message not found in this chat session for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_update_message(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(agent): Extension\u003cAgentType\u003e,\n\tExtension(chat_session_id_atomic): Extension\u003cstd::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e\u003e,\n\tExtension(context_store): Extension\u003ccrate::agent::models::context::SharedContextStore\u003e,\n\tJson(UpdateMessageRequest {\n\t\tmessage_id,\n\t\tnew_text,\n\t\titinerary_id,\n\t}): Json\u003cUpdateMessageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cMessage\u003e\u003e {\n\tif new_text.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\"Text cannot be empty\")));\n\t}\n\n\t// Get the message and verify ownership in one query\n\tlet message_info = sqlx::query!(\n\t\tr#\"\n\t\tSELECT m.chat_session_id, m.timestamp\n\t\tFROM messages m\n\t\tINNER JOIN chat_sessions c ON m.chat_session_id = c.id\n\t\tWHERE m.id = $1 AND c.account_id = $2 AND m.is_user = TRUE;\n\t\t\"#,\n\t\tmessage_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tlet chat_session_id = message_info.chat_session_id;\n\tlet message_timestamp = message_info.timestamp;\n\n\t// Delete future messages in this chat session only\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM messages\n\t\tWHERE chat_session_id = $1\n\t\t  AND timestamp \u003e $2\n\t\t  AND id != $3;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tmessage_timestamp,\n\t\tmessage_id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Update the user message\n\tsqlx::query!(\n\t\tr#\"\n\t\tUPDATE messages\n\t\tSET text = $1, timestamp = NOW()\n\t\tWHERE id = $2;\n\t\t\"#,\n\t\tnew_text,\n\t\tmessage_id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Call LLM and insert bot response\n\tlet bot_message = send_message_to_llm(\n\t\tnew_text.as_str(),\n\t\tuser.id,\n\t\tchat_session_id,\n\t\titinerary_id,\n\t\t\u0026pool,\n\t\t\u0026agent,\n\t\t\u0026chat_session_id_atomic,\n\t\t\u0026context_store,\n\t)\n\t.await?;\n\n\tOk(Json(bot_message))\n}\n\n/// Send a new message, and get a message back from the LLM\n///\n/// # Method\n/// `POST /api/chat/sendMessage`\n///\n/// # Request Body\n/// - [SendMessageRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [SendMessageResponse] - contains message from LLM\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/sendMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 6,\n///         \"text\": \"New message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/sendMessage\",\n\tsummary=\"Send a message and wait for a reply from the LLM\",\n\tdescription=\"Ask the LLM to generate an itinerary and it should respond with one.\",\n\trequest_body(\n\t\tcontent=SendMessageRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Itinerary id is optional and is used to give context to the LLM.\",\n\t\texample=json!({\n\t\t\t\"chat_session_id\": 12,\n\t\t\t\"text\": \"Make an itinerary\",\n\t\t\t\"itinerary_id\": 13\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Message sent, and LLM replied successfully\",\n\t\t\tbody=SendMessageResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"user_message_id\": 52,\n\t\t\t\t\"bot_message\": {\n\t\t\t\t\t\"id\": 53,\n\t\t\t\t\t\"is_user\": false,\n\t\t\t\t\t\"timestamp\": \"2025-10-14 11-39-10\",\n\t\t\t\t\t\"text\": \"Bot reply\",\n\t\t\t\t\t\"itinerary_id\": 14\n\t\t\t\t}\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_send_message(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tExtension(agent): Extension\u003cAgentType\u003e,\n\tExtension(chat_session_id_atomic): Extension\u003cstd::sync::Arc\u003cstd::sync::atomic::AtomicI32\u003e\u003e,\n\tExtension(context_store): Extension\u003ccrate::agent::models::context::SharedContextStore\u003e,\n\tJson(SendMessageRequest {\n\t\tchat_session_id,\n\t\ttext,\n\t\titinerary_id,\n\t}): Json\u003cSendMessageRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cSendMessageResponse\u003e\u003e {\n\tif text.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\"Text cannot be empty\")));\n\t}\n\n\t// verify the given chat session belongs to this user\n\tsqlx::query!(\n\t\tr#\"\n\t\tSELECT id FROM chat_sessions\n\t\tWHERE id=$1 AND account_id=$2;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\t// insert user message into db\n\tlet user_message_id = sqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO messages (chat_session_id, itinerary_id, is_user, timestamp, text)\n\t\tVALUES ($1, NULL, TRUE, NOW(), $2)\n\t\tRETURNING id;\n\t\t\"#,\n\t\tchat_session_id,\n\t\ttext\n\t)\n\t.fetch_one(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.id;\n\n\t// call llm and insert bot response into db\n\tlet bot_message = send_message_to_llm(\n\t\ttext.as_str(),\n\t\tuser.id,\n\t\tchat_session_id,\n\t\titinerary_id,\n\t\t\u0026pool,\n\t\t\u0026agent,\n\t\t\u0026chat_session_id_atomic,\n\t\t\u0026context_store,\n\t)\n\t.await?;\n\n\tOk(Json(SendMessageResponse {\n\t\tuser_message_id,\n\t\tbot_message,\n\t}))\n}\n\n/// Get an empty chat session id belonging to this user, or create one if one doesn't exist\n///\n/// # Method\n/// `GET /api/chat/newChat`\n///\n/// # Responses\n/// - `200 OK` - with body: [NewChatResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/sendMessage\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 6,\n///         \"text\": \"New message\",\n///         \"itinerary_id\": 7\n///       }'\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/newChat\",\n\tsummary=\"Get the chat session id for an empty chat\",\n\tdescription=\"Creates a new empty chat session for this user if one doesn't already exist, and returns its chat session id.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"New chat session retrieved successfully\",\n\t\t\tbody=NewChatResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"chat_session_id\": 13\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_new_chat(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cNewChatResponse\u003e\u003e {\n\t// check to see if there's already an empty chat session before making a new one\n\tlet chat_sessions = sqlx::query!(\n\t\tr#\"\n\t\tSELECT c.id\n\t\tFROM chat_sessions c\n\t\tWHERE\n\t\t\tc.account_id=$1\n\t\t\tAND NOT EXISTS (\n\t\t\t\tSELECT 1\n\t\t\t\tFROM messages m\n\t\t\t\tWHERE m.chat_session_id=c.id\n\t\t\t);\n\t\t\"#,\n\t\tuser.id\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet chat_session_id = match chat_sessions.first() {\n\t\tSome(record) =\u003e record.id,\n\t\tNone =\u003e {\n\t\t\t// make a new chat session\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO chat_sessions (account_id, title)\n\t\t\t\tVALUES ($1, 'New Chat')\n\t\t\t\tRETURNING id\n\t\t\t\t\"#,\n\t\t\t\tuser.id\n\t\t\t)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.id\n\t\t}\n\t};\n\n\tOk(Json(NewChatResponse { chat_session_id }))\n}\n\n/// Delete the chat session with the given ID\n///\n/// # Method\n/// `DELETE /api/chat/:id`\n///\n/// # Responses\n/// - `200 OK` - chat session and associated messages and unsaved itineraries successfully deleted\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X DELETE http://localhost:3001/api/chat/7\n///   -H \"Content-Type: application/json\"\n/// ```\n#[utoipa::path(\n\tdelete,\n\tpath=\"/{id}\",\n\tsummary=\"Delete the given chat session\",\n\tdescription=\"Deletes a chat session and its associated messages and unsaved, private itineraries if it belongs to the user making the request.\",\n\tresponses(\n\t\t(status=200, description=\"Chat session and associated messages and unsaved, private itineraries deleted successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be DELETE\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_delete_chat(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tPath(chat_session_id): Path\u003ci32\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// itineraries do not cascade, so we delete manually\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM itineraries\n\t\tWHERE\n\t\t\tchat_session_id=$1 AND\n\t\t\taccount_id=$2 AND\n\t\t\tis_public=FALSE AND\n\t\t\tsaved=FALSE;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// messages will cascade\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM chat_sessions\n\t\tWHERE id=$1 AND account_id=$2\n\t\tRETURNING id;\n\t\t\"#,\n\t\tchat_session_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tOk(())\n}\n\n/// Rename a chat session\n///\n/// # Method\n/// `POST /api/chat/rename`\n///\n/// # Request Body\n/// - [RenameRequest]\n///\n/// # Responses\n/// - `200 OK`\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/rename\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"new_title\": \"Tokio, Japan (lmao)\",\n///         \"id\": 16\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/rename\",\n\tsummary=\"Rename a chat session\",\n\tdescription=\"Renames a chat session that belongs to this user with the given ID to the given title.\",\n\trequest_body(\n\t\tcontent=RenameRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Chat session ID must belong to the user who sent the request. New Title must not be empty string.\",\n\t\texample=json!({\n\t\t\t\"new_title\": \"Tokio, Japan (lmao)\",\n\t\t\t\"id\": 16\n\t\t})\n\t),\n\tresponses(\n\t\t(status=200, description=\"Chat renamed successfully\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_rename(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(RenameRequest { new_title, id }): Json\u003cRenameRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// no empty titles\n\tif new_title.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\n\t\t\t\"New title must not be empty\",\n\t\t)));\n\t}\n\n\t// verify chat session belongs to this user\n\tsqlx::query!(\n\t\tr#\"SELECT id from chat_sessions WHERE id=$1 AND account_id=$2\"#,\n\t\tid,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\t//change name\n\tsqlx::query!(\n\t\tr#\"UPDATE chat_sessions SET title=$1 WHERE id=$2\"#,\n\t\tnew_title,\n\t\tid\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(())\n}\n\n/// Fetches the progress of the llm pipeline for this chat session\n///\n/// # Method\n/// `POST /api/chat/progress`\n///\n/// # Request Body\n/// - [ProgressRequest]\n///\n/// # Responses\n/// - `200 OK` - [ProgressResponse] - status of the llm pipeline\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided chat session id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/chat/progress\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"chat_session_id\": 4\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/progress\",\n\tsummary=\"Get status of LLM pipeline\",\n\tdescription=\"Fetches the progress of the llm pipeline for this chat session.\",\n\trequest_body(\n\t\tcontent=ProgressRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"Chat session ID must belong to the user who sent the request. New Title must not be empty string.\",\n\t\texample=json!({\n\t\t\t\"chat_session_id\": 4\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The status of the LLM pipeline for the quested chat session\",\n\t\t\tbody=ProgressResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"progress\": \"Ready\",\n\t\t\t\t\"title\": \"Possibly Updated Chat Title\"\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Chat session not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Chat\"\n)]\npub async fn api_progress(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(ProgressRequest { chat_session_id }): Json\u003cProgressRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cProgressResponse\u003e\u003e {\n\tlet row = sqlx::query!(\n\t\tr#\"SELECT llm_progress as \"llm_progress: LlmProgress\", title\n\t\tFROM chat_sessions\n\t\tWHERE account_id=$1 AND id=$2;\"#,\n\t\tuser.id,\n\t\tchat_session_id,\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\tOk(Json(ProgressResponse {\n\t\tprogress: row.llm_progress,\n\t\ttitle: row.title,\n\t}))\n}\n\n/// Create the chat routes with authentication middleware.\n///\n/// # Routes\n/// - `GET /chats` - Get metadata for all the user's chat sessions (protected)\n/// - `POST /messagePage` - Gets a page of messages in the session, ending with message_id or the latest message (protected)\n/// - `POST /updateMessage` - Updates a user's message and waits for a bot reply (protected)\n/// - `POST /sendMessage` - Sends a user's message and waits for a bot reply (protected)\n/// - `GET /newChat` - Gets a chat session id for an empty chat (protected)\n/// - `DELETE /:id` - Delete a chat session and associated messages (protected)\n/// - `POST /rename` - Renames the title of a chat session (protected)\n/// - `POST /progress` - Fetches the progress of the llm pipeline for this chat session (protected)\n///\n/// # Middleware\n/// All routes are protected by `middleware_auth` which validates the `auth-token` cookie.\npub fn chat_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/chats\", get(api_chats))\n\t\t.route(\"/messagePage\", post(api_message_page))\n\t\t.route(\"/updateMessage\", post(api_update_message))\n\t\t.route(\"/sendMessage\", post(api_send_message))\n\t\t.route(\"/newChat\", get(api_new_chat))\n\t\t.route(\"/{id}\", delete(api_delete_chat))\n\t\t.route(\"/rename\", post(api_rename))\n\t\t.route(\"/progress\", post(api_progress))\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n}\n","traces":[{"line":59,"address":[41817920],"length":1,"stats":{"Line":1}},{"line":70,"address":[42627519],"length":1,"stats":{"Line":1}},{"line":71,"address":[42627817],"length":1,"stats":{"Line":0}},{"line":74,"address":[42629104,42627925,42628750,42629527,42629267,42628695,42628516,42629171,42629003,42627995,42627862],"length":1,"stats":{"Line":5}},{"line":90,"address":[42628587],"length":1,"stats":{"Line":1}},{"line":91,"address":[38913938],"length":1,"stats":{"Line":4}},{"line":92,"address":[42629081,42629139],"length":1,"stats":{"Line":1}},{"line":93,"address":[38914190,38914218],"length":1,"stats":{"Line":3}},{"line":96,"address":[42628778],"length":1,"stats":{"Line":1}},{"line":98,"address":[42629472,42629887,42629963,42629434,42634545,42629761],"length":1,"stats":{"Line":4}},{"line":99,"address":[42629315],"length":1,"stats":{"Line":1}},{"line":101,"address":[42629328],"length":1,"stats":{"Line":1}},{"line":103,"address":[42627594,42629457,42629505,42629857,42629931,42629594],"length":1,"stats":{"Line":4}},{"line":105,"address":[42629359],"length":1,"stats":{"Line":1}},{"line":109,"address":[42629373,42630512,42630108],"length":1,"stats":{"Line":3}},{"line":115,"address":[42632681,42630474,42632278],"length":1,"stats":{"Line":3}},{"line":131,"address":[42632652,42634452,42627615,42634558],"length":1,"stats":{"Line":2}},{"line":134,"address":[42634805,42634876],"length":1,"stats":{"Line":2}},{"line":135,"address":[42634918,42635900],"length":1,"stats":{"Line":2}},{"line":136,"address":[42634980],"length":1,"stats":{"Line":1}},{"line":137,"address":[42635497],"length":1,"stats":{"Line":1}},{"line":139,"address":[42634967],"length":1,"stats":{"Line":1}},{"line":140,"address":[42635000],"length":1,"stats":{"Line":1}},{"line":141,"address":[42635008],"length":1,"stats":{"Line":1}},{"line":142,"address":[42635079],"length":1,"stats":{"Line":1}},{"line":143,"address":[42635127],"length":1,"stats":{"Line":1}},{"line":144,"address":[42635143],"length":1,"stats":{"Line":1}},{"line":145,"address":[42635202],"length":1,"stats":{"Line":1}},{"line":146,"address":[42635256],"length":1,"stats":{"Line":1}},{"line":147,"address":[42635272],"length":1,"stats":{"Line":1}},{"line":148,"address":[42635331],"length":1,"stats":{"Line":1}},{"line":149,"address":[42635383],"length":1,"stats":{"Line":1}},{"line":150,"address":[42635427],"length":1,"stats":{"Line":1}},{"line":154,"address":[42635922,42636348],"length":1,"stats":{"Line":2}},{"line":161,"address":[42634941,42637848],"length":1,"stats":{"Line":2}},{"line":162,"address":[42637941],"length":1,"stats":{"Line":1}},{"line":165,"address":[42637953],"length":1,"stats":{"Line":1}},{"line":175,"address":[42639826],"length":1,"stats":{"Line":1}},{"line":179,"address":[38914001],"length":1,"stats":{"Line":2}},{"line":181,"address":[42640358,42640276,42640764],"length":1,"stats":{"Line":3}},{"line":188,"address":[42640732,42642991,42643479,42643412,42643244],"length":1,"stats":{"Line":4}},{"line":189,"address":[42642643,42642519,42643039,42642569],"length":1,"stats":{"Line":1}},{"line":192,"address":[42643013,42627657,42643340,42642940,42643069],"length":1,"stats":{"Line":3}},{"line":193,"address":[42687840,42692851,42643366],"length":1,"stats":{"Line":1}},{"line":194,"address":[42687887,42687966,42688347],"length":1,"stats":{"Line":0}},{"line":201,"address":[42690556,42688316,42690932],"length":1,"stats":{"Line":0}},{"line":207,"address":[42690922,42692670],"length":1,"stats":{"Line":0}},{"line":211,"address":[42645710,42643686,42643603,42644090,42645006],"length":1,"stats":{"Line":3}},{"line":217,"address":[42646350,42644052,42645936],"length":1,"stats":{"Line":3}},{"line":229,"address":[42646310,42648125],"length":1,"stats":{"Line":2}},{"line":230,"address":[42648665,42648209],"length":1,"stats":{"Line":0}},{"line":239,"address":[42650186,42650787,42652994,42648618,42651212,42650116,42650600,42650732,42651136,42651035],"length":1,"stats":{"Line":0}},{"line":249,"address":[42650674],"length":1,"stats":{"Line":0}},{"line":250,"address":[38914047],"length":1,"stats":{"Line":0}},{"line":251,"address":[42651180,42651113],"length":1,"stats":{"Line":0}},{"line":253,"address":[42651271],"length":1,"stats":{"Line":0}},{"line":254,"address":[42651437],"length":1,"stats":{"Line":0}},{"line":255,"address":[42651338],"length":1,"stats":{"Line":0}},{"line":257,"address":[42651345],"length":1,"stats":{"Line":0}},{"line":258,"address":[42651375],"length":1,"stats":{"Line":0}},{"line":259,"address":[42651423],"length":1,"stats":{"Line":0}},{"line":266,"address":[42648176,42651612],"length":1,"stats":{"Line":2}},{"line":267,"address":[42651704],"length":1,"stats":{"Line":0}},{"line":268,"address":[42651822,42651907],"length":1,"stats":{"Line":0}},{"line":269,"address":[42651921,42651996,42653573],"length":1,"stats":{"Line":0}},{"line":271,"address":[42653275,42652228,42657322,42652158,42652753,42652972,42652113,42653351,42652917,42653174],"length":1,"stats":{"Line":0}},{"line":280,"address":[42652824],"length":1,"stats":{"Line":0}},{"line":281,"address":[38914068],"length":1,"stats":{"Line":0}},{"line":282,"address":[42653319,42653252],"length":1,"stats":{"Line":0}},{"line":284,"address":[42653444],"length":1,"stats":{"Line":0}},{"line":285,"address":[42653625,42653537,42654238],"length":1,"stats":{"Line":0}},{"line":291,"address":[42654093],"length":1,"stats":{"Line":0}},{"line":292,"address":[42653994],"length":1,"stats":{"Line":0}},{"line":294,"address":[42654001],"length":1,"stats":{"Line":0}},{"line":295,"address":[42654031],"length":1,"stats":{"Line":0}},{"line":296,"address":[42654079],"length":1,"stats":{"Line":0}},{"line":306,"address":[42656112,42657904,42651663],"length":1,"stats":{"Line":3}},{"line":307,"address":[42656195,42656275],"length":1,"stats":{"Line":2}},{"line":308,"address":[42656358],"length":1,"stats":{"Line":1}},{"line":309,"address":[42656459],"length":1,"stats":{"Line":1}},{"line":312,"address":[42657603,42657502,42657081,42656667,42656597,42656560,42657300,42657245,42657679,42684188],"length":1,"stats":{"Line":4}},{"line":322,"address":[42657152],"length":1,"stats":{"Line":1}},{"line":323,"address":[42657335,42657278,42657230,42657550,42627720],"length":1,"stats":{"Line":4}},{"line":324,"address":[42657647,42657580],"length":1,"stats":{"Line":1}},{"line":326,"address":[42657772],"length":1,"stats":{"Line":1}},{"line":328,"address":[42657965,42657873],"length":1,"stats":{"Line":2}},{"line":329,"address":[42658908,42658295,42658194],"length":1,"stats":{"Line":3}},{"line":335,"address":[42658763],"length":1,"stats":{"Line":1}},{"line":336,"address":[42658664],"length":1,"stats":{"Line":1}},{"line":338,"address":[42658671],"length":1,"stats":{"Line":1}},{"line":339,"address":[42658701],"length":1,"stats":{"Line":1}},{"line":340,"address":[42658749],"length":1,"stats":{"Line":1}},{"line":347,"address":[42660703,42656225],"length":1,"stats":{"Line":2}},{"line":349,"address":[42660845],"length":1,"stats":{"Line":1}},{"line":353,"address":[42660879,42663766],"length":1,"stats":{"Line":2}},{"line":354,"address":[42663835],"length":1,"stats":{"Line":1}},{"line":355,"address":[42684183,42673028,42682655,42682695,42677772,42683259,42664029,42683336,42682972,42683364,42684166,42663965,42682363,42670893,42682313,42683666,42683012,42683299,42683928,42683945,42683641,42666164],"length":1,"stats":{"Line":2}},{"line":442,"address":[42678070],"length":1,"stats":{"Line":1}},{"line":443,"address":[42678142],"length":1,"stats":{"Line":1}},{"line":447,"address":[42684365,42681576,42681763,42684813,42684466,42680672,42680742,42684533,42680531,42681708],"length":1,"stats":{"Line":4}},{"line":459,"address":[42681650],"length":1,"stats":{"Line":1}},{"line":460,"address":[42681741,42684201,42681693,42684413,42627741],"length":1,"stats":{"Line":4}},{"line":461,"address":[42684501,42684443],"length":1,"stats":{"Line":1}},{"line":464,"address":[42684594],"length":1,"stats":{"Line":1}},{"line":467,"address":[38914131],"length":1,"stats":{"Line":2}},{"line":470,"address":[42685957,42686125,42686376,42686177,42685259,42685282,42685363,42685174,42686477,42686935,42686544],"length":1,"stats":{"Line":5}},{"line":478,"address":[42685218],"length":1,"stats":{"Line":1}},{"line":480,"address":[42686067],"length":1,"stats":{"Line":1}},{"line":481,"address":[42686110,42686158,42627783,42686424,42686212],"length":1,"stats":{"Line":4}},{"line":482,"address":[42686454,42686512],"length":1,"stats":{"Line":1}},{"line":484,"address":[42686617],"length":1,"stats":{"Line":1}},{"line":486,"address":[42686793],"length":1,"stats":{"Line":1}},{"line":490,"address":[42686735],"length":1,"stats":{"Line":1}},{"line":491,"address":[42686787],"length":1,"stats":{"Line":1}},{"line":497,"address":[42660851,42660932,42661374],"length":1,"stats":{"Line":0}},{"line":503,"address":[42687283,42687350,42662856,42663694,42662943,42663636,42687182,42687735,42661306,42662833,42663468],"length":1,"stats":{"Line":0}},{"line":510,"address":[42661331],"length":1,"stats":{"Line":0}},{"line":512,"address":[42663578],"length":1,"stats":{"Line":0}},{"line":513,"address":[38914173],"length":1,"stats":{"Line":0}},{"line":514,"address":[42687318,42687260],"length":1,"stats":{"Line":0}},{"line":516,"address":[42687407],"length":1,"stats":{"Line":0}},{"line":518,"address":[42687562],"length":1,"stats":{"Line":0}},{"line":522,"address":[42687525],"length":1,"stats":{"Line":0}},{"line":579,"address":[41832000],"length":1,"stats":{"Line":1}},{"line":583,"address":[42709168],"length":1,"stats":{"Line":1}},{"line":584,"address":[42707992,42708055,42708520,42709098,42708688,42708731,42708933,42708119,42709031],"length":1,"stats":{"Line":4}},{"line":592,"address":[42708588],"length":1,"stats":{"Line":1}},{"line":593,"address":[39092976],"length":1,"stats":{"Line":4}},{"line":594,"address":[42709066,42709008],"length":1,"stats":{"Line":1}},{"line":703,"address":[41858176],"length":1,"stats":{"Line":1}},{"line":711,"address":[42711948,42711516,42711731,42710774,42712113,42711685,42712046,42710838,42710680],"length":1,"stats":{"Line":4}},{"line":739,"address":[42711603],"length":1,"stats":{"Line":1}},{"line":740,"address":[42710761,42711793,42711715,42711996,42711670],"length":1,"stats":{"Line":4}},{"line":741,"address":[42712023,42712081],"length":1,"stats":{"Line":1}},{"line":744,"address":[42712800,42712867,42712240],"length":1,"stats":{"Line":3}},{"line":745,"address":[42712811],"length":1,"stats":{"Line":1}},{"line":746,"address":[42712815],"length":1,"stats":{"Line":1}},{"line":747,"address":[42712819],"length":1,"stats":{"Line":1}},{"line":748,"address":[42712835],"length":1,"stats":{"Line":1}},{"line":749,"address":[42712861],"length":1,"stats":{"Line":1}},{"line":753,"address":[42712398,42712278,42712330],"length":1,"stats":{"Line":3}},{"line":755,"address":[42712624,42712400],"length":1,"stats":{"Line":2}},{"line":757,"address":[42712387],"length":1,"stats":{"Line":1}},{"line":760,"address":[42712491],"length":1,"stats":{"Line":1}},{"line":761,"address":[42712445],"length":1,"stats":{"Line":1}},{"line":762,"address":[42712477],"length":1,"stats":{"Line":1}},{"line":830,"address":[41865712],"length":1,"stats":{"Line":1}},{"line":842,"address":[42716158,42716336],"length":1,"stats":{"Line":2}},{"line":843,"address":[42717252,42716413],"length":1,"stats":{"Line":2}},{"line":847,"address":[42716350,42717725,42717034,42717224,42717166,42717624,42719043,42717900,42716513,42717792,42716443,42717967],"length":1,"stats":{"Line":7}},{"line":857,"address":[42717108],"length":1,"stats":{"Line":1}},{"line":858,"address":[42717199,42717151,42717454,42717672,42716205],"length":1,"stats":{"Line":4}},{"line":859,"address":[42717702,42717760],"length":1,"stats":{"Line":1}},{"line":860,"address":[38912765,38912737],"length":1,"stats":{"Line":2}},{"line":862,"address":[42718024],"length":1,"stats":{"Line":1}},{"line":863,"address":[42718055],"length":1,"stats":{"Line":1}},{"line":866,"address":[42719021,42718154,42720249,42718969,42719329,42718224,42718860,42718101,42719228,42719396],"length":1,"stats":{"Line":4}},{"line":877,"address":[42718911],"length":1,"stats":{"Line":1}},{"line":878,"address":[38912465],"length":1,"stats":{"Line":4}},{"line":879,"address":[42719306,42719364],"length":1,"stats":{"Line":1}},{"line":882,"address":[42720530,42719571,42720175,42719453,42720066,42720865,42720597,42719507,42720227,42720429],"length":1,"stats":{"Line":4}},{"line":891,"address":[42720117],"length":1,"stats":{"Line":1}},{"line":892,"address":[38912486],"length":1,"stats":{"Line":4}},{"line":893,"address":[42720507,42720565],"length":1,"stats":{"Line":1}},{"line":897,"address":[42720654],"length":1,"stats":{"Line":1}},{"line":898,"address":[42720693],"length":1,"stats":{"Line":1}},{"line":899,"address":[42720700],"length":1,"stats":{"Line":1}},{"line":900,"address":[42720707],"length":1,"stats":{"Line":1}},{"line":901,"address":[42720721],"length":1,"stats":{"Line":1}},{"line":902,"address":[42720728],"length":1,"stats":{"Line":1}},{"line":903,"address":[42720735],"length":1,"stats":{"Line":1}},{"line":904,"address":[42720742],"length":1,"stats":{"Line":1}},{"line":906,"address":[38912507],"length":1,"stats":{"Line":4}},{"line":908,"address":[42721320],"length":1,"stats":{"Line":1}},{"line":978,"address":[41874016],"length":1,"stats":{"Line":1}},{"line":990,"address":[42725203,42725046],"length":1,"stats":{"Line":2}},{"line":991,"address":[42726116,42725280],"length":1,"stats":{"Line":2}},{"line":995,"address":[42725380,42725217,42726485,42726586,42726832,42726653,42725310,42725901,42726088,42726033,42727707,42726765],"length":1,"stats":{"Line":7}},{"line":1003,"address":[42725975],"length":1,"stats":{"Line":1}},{"line":1004,"address":[39105260],"length":1,"stats":{"Line":4}},{"line":1005,"address":[42726621,42726563],"length":1,"stats":{"Line":1}},{"line":1006,"address":[42726714,42726800],"length":1,"stats":{"Line":2}},{"line":1009,"address":[42728332,42727633,42727892,42726887,42727501,42726942,42727685,42727006,42727993,42728060],"length":1,"stats":{"Line":4}},{"line":1018,"address":[42727575],"length":1,"stats":{"Line":1}},{"line":1019,"address":[42727618,42727940,42727666,42725114,42727725],"length":1,"stats":{"Line":4}},{"line":1020,"address":[42727970,42728028],"length":1,"stats":{"Line":1}},{"line":1025,"address":[42728121],"length":1,"stats":{"Line":1}},{"line":1026,"address":[42728160],"length":1,"stats":{"Line":1}},{"line":1027,"address":[42728167],"length":1,"stats":{"Line":1}},{"line":1028,"address":[42728174],"length":1,"stats":{"Line":1}},{"line":1029,"address":[42728188],"length":1,"stats":{"Line":1}},{"line":1030,"address":[42728195],"length":1,"stats":{"Line":1}},{"line":1031,"address":[42728202],"length":1,"stats":{"Line":1}},{"line":1032,"address":[42728209],"length":1,"stats":{"Line":1}},{"line":1034,"address":[39105302],"length":1,"stats":{"Line":4}},{"line":1036,"address":[42728793],"length":1,"stats":{"Line":1}},{"line":1037,"address":[42728787],"length":1,"stats":{"Line":1}},{"line":1087,"address":[41878160],"length":1,"stats":{"Line":1}},{"line":1092,"address":[42732547,42732039,42732207,42732250,42732449,42732614,42733610,42731493,42731638,42731574],"length":1,"stats":{"Line":4}},{"line":1106,"address":[42732107],"length":1,"stats":{"Line":1}},{"line":1107,"address":[42732195,42732497,42731543,42732234,42732309],"length":1,"stats":{"Line":4}},{"line":1108,"address":[42732524,42732582],"length":1,"stats":{"Line":1}},{"line":1110,"address":[42732715,42732783],"length":1,"stats":{"Line":2}},{"line":1111,"address":[42732839],"length":1,"stats":{"Line":1}},{"line":1114,"address":[42733543,42733877,42733944,42732874,42732970,42733779,42732906,42733498,42733372],"length":1,"stats":{"Line":4}},{"line":1122,"address":[42733443],"length":1,"stats":{"Line":1}},{"line":1123,"address":[42733640,42733486,42733827,42733525,42731561],"length":1,"stats":{"Line":4}},{"line":1124,"address":[42733854,42733912],"length":1,"stats":{"Line":1}},{"line":1125,"address":[42733998],"length":1,"stats":{"Line":1}},{"line":1129,"address":[42733570],"length":1,"stats":{"Line":1}},{"line":1166,"address":[41881424],"length":1,"stats":{"Line":1}},{"line":1172,"address":[42737683,42736761,42735626,42736663,42735715,42736270,42736828,42736415,42736458,42735779],"length":1,"stats":{"Line":4}},{"line":1184,"address":[42736315],"length":1,"stats":{"Line":1}},{"line":1185,"address":[39103752],"length":1,"stats":{"Line":4}},{"line":1186,"address":[42736796,42736738],"length":1,"stats":{"Line":1}},{"line":1189,"address":[42737956,42737661,42738405,42736882,42738023,42737619,42736934,42738202,42736998,42738135,42737493,42737858],"length":1,"stats":{"Line":5}},{"line":1198,"address":[42737564],"length":1,"stats":{"Line":1}},{"line":1199,"address":[39103768],"length":1,"stats":{"Line":4}},{"line":1200,"address":[42737991,42737933],"length":1,"stats":{"Line":1}},{"line":1201,"address":[42738170,42738084],"length":1,"stats":{"Line":1}},{"line":1203,"address":[42738254],"length":1,"stats":{"Line":1}},{"line":1256,"address":[41886224],"length":1,"stats":{"Line":1}},{"line":1262,"address":[42740188,42740309],"length":1,"stats":{"Line":2}},{"line":1263,"address":[42740375,42741169],"length":1,"stats":{"Line":2}},{"line":1269,"address":[42741092,42742691,42741849,42741141,42740405,42741603,42740469,42741782,42741670,42741505,42740323,42740960],"length":1,"stats":{"Line":5}},{"line":1274,"address":[42741034],"length":1,"stats":{"Line":1}},{"line":1275,"address":[39094220],"length":1,"stats":{"Line":4}},{"line":1276,"address":[42741580,42741638],"length":1,"stats":{"Line":1}},{"line":1277,"address":[42741731,42741817],"length":1,"stats":{"Line":1}},{"line":1280,"address":[42743025,42742515,42742860,42742624,42741904,42742958,42741956,42742020,42743307,42742669],"length":1,"stats":{"Line":4}},{"line":1285,"address":[42742566],"length":1,"stats":{"Line":1}},{"line":1286,"address":[39094236],"length":1,"stats":{"Line":4}},{"line":1287,"address":[42742993,42742935],"length":1,"stats":{"Line":1}},{"line":1289,"address":[42743082],"length":1,"stats":{"Line":1}},{"line":1305,"address":[41819191,41819216,41818064],"length":1,"stats":{"Line":1}},{"line":1306,"address":[41819019,41818885,41818617,41818540,41818212,41818808,41819076,41818751,41818483,41818272,41818942,41819138,41818071,41818349,41818406,41818674],"length":1,"stats":{"Line":16}},{"line":1307,"address":[41819302,41818228,41818164,41818277,41818171],"length":1,"stats":{"Line":3}},{"line":1308,"address":[41819287,41818362,41818301,41818411,41818308],"length":1,"stats":{"Line":3}},{"line":1309,"address":[41818435,41818442,41818545,41819275,41818496],"length":1,"stats":{"Line":3}},{"line":1310,"address":[41818576,41818630,41819263,41818679,41818569],"length":1,"stats":{"Line":3}},{"line":1311,"address":[41819251,41818710,41818703,41818813,41818764],"length":1,"stats":{"Line":3}},{"line":1312,"address":[41818844,41819239,41818947,41818898,41818837],"length":1,"stats":{"Line":3}},{"line":1313,"address":[41819081,41819032,41818978,41819227,41818971],"length":1,"stats":{"Line":3}},{"line":1314,"address":[41819151,41819209,41819097,41819104],"length":1,"stats":{"Line":2}}],"covered":206,"coverable":244},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","itinerary.rs"],"content":"/*\n * src/controllers/itinerary.rs\n *\n * File for Itinerary Controller API Endpoints\n *\n * Purpose:\n *   Serve Itinerary Related API Requests\n */\n\nuse axum::routing::{delete, post};\nuse axum::{Extension, Json, extract::Path, routing::get};\nuse chrono::NaiveDate;\nuse sqlx::PgPool;\nuse tracing::debug;\nuse utoipa::OpenApi;\n\nuse crate::controllers::AxumRouter;\nuse crate::error::{ApiResult, AppError};\nuse crate::global::EVENT_SEARCH_RESULT_LEN;\nuse crate::http_models::event::{\n\tEvent, SearchEventRequest, SearchEventResponse, UserEventRequest, UserEventResponse,\n};\nuse crate::http_models::itinerary::*;\nuse crate::middleware::{AuthUser, middleware_auth};\nuse crate::sql_models::event_list::EventListJoinRow;\nuse crate::sql_models::itinerary::ItineraryRow;\nuse crate::sql_models::{Period, TimeOfDay};\nuse crate::swagger::SecurityAddon;\n\n#[derive(OpenApi)]\n#[openapi(\n\tpaths(\n\t\tapi_get_itinerary,\n\t\tapi_saved_itineraries,\n\t\tapi_save,\n\t\tapi_unsave,\n\t\tapi_user_event,\n\t\tapi_search_event,\n\t\tapi_delete_user_event\n\t),\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity((\"set-cookie\"=[])),\n    info(\n    \ttitle=\"Itinerary Routes\",\n    \tdescription = \"API endpoints dealing with managing and viewing itineraries.\"\n    ),\n    tags((name=\"Itinerary\"))\n)]\npub struct ItineraryApiDoc;\n\n/// Returns the [EventDay]s associated with this itinerary\n/// Returns only the days that exist in event_list (including empty days with NULL event_id)\nasync fn itinerary_events(\n\titinerary_id: i32,\n\t_start_date: NaiveDate,\n\t_end_date: NaiveDate,\n\tpool: \u0026PgPool,\n) -\u003e ApiResult\u003cVec\u003cEventDay\u003e\u003e {\n\t// First, get all dates that have entries (including NULL event_id for empty days)\n\tlet all_dates: Vec\u003cNaiveDate\u003e = sqlx::query_scalar!(\n\t\tr#\"\n\t\tSELECT DISTINCT date\n\t\tFROM event_list\n\t\tWHERE itinerary_id = $1\n\t\tORDER BY date\n\t\t\"#,\n\t\titinerary_id\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Now get all events (excluding placeholders with NULL event_id)\n\tlet event_list: Vec\u003cEventListJoinRow\u003e = sqlx::query_as!(\n\t\tEventListJoinRow,\n\t\tr#\"\n\t\tSELECT\n\t\t\te.id,\n\t\t\tel.time_of_day as \"time_of_day: TimeOfDay\",\n\t\t\tel.date,\n\t\t\te.street_address,\n\t\t\te.postal_code,\n\t\t\te.city,\n\t\t\te.country,\n\t\t\te.lat,\n\t\t\te.lng,\n\t\t\te.event_type,\n\t\t\te.event_description,\n\t\t\te.event_name,\n\t\t\te.user_created,\n\t\t\te.hard_start,\n\t\t\te.hard_end,\n\t\t\te.timezone,\n\t\t\te.place_id,\n\t\t\te.wheelchair_accessible_parking,\n\t\t\te.wheelchair_accessible_entrance,\n\t\t\te.wheelchair_accessible_restroom,\n\t\t\te.wheelchair_accessible_seating,\n\t\t\te.serves_vegetarian_food,\n\t\t\te.price_level,\n\t\t\te.utc_offset_minutes,\n\t\t\te.website_uri,\n\t\t\te.types,\n\t\t\te.photo_name,\n\t\t\te.photo_width,\n\t\t\te.photo_height,\n\t\t\te.photo_author,\n\t\t\te.photo_author_uri,\n\t\t\te.photo_author_photo_uri,\n\t\t\te.weekday_descriptions,\n\t\t\te.secondary_hours_type,\n\t\t\te.next_open_time,\n\t\t\te.next_close_time,\n\t\t\te.open_now,\n\t\t\te.periods as \"periods: Vec\u003cPeriod\u003e\",\n\t\t\te.special_days,\n\t\t\tel.block_index\n\t\tFROM event_list el\n\t\tJOIN events e ON e.id = el.event_id\n\t\tWHERE el.itinerary_id = $1 AND el.event_id IS NOT NULL\n\t\tORDER BY el.date, el.time_of_day\n\t\t\"#,\n\t\titinerary_id\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\t// Create a map of date -\u003e events for quick lookup\n\tuse std::collections::HashMap;\n\tlet mut events_by_date: HashMap\u003cNaiveDate, Vec\u003c\u0026EventListJoinRow\u003e\u003e = HashMap::new();\n\tfor event in event_list.iter() {\n\t\tevents_by_date.entry(event.date).or_default().push(event);\n\t}\n\n\t// Create EventDay for each date that exists in event_list\n\tlet mut event_days = Vec::new();\n\n\tfor date in all_dates {\n\t\tlet mut morning_events = Vec::new();\n\t\tlet mut afternoon_events = Vec::new();\n\t\tlet mut evening_events = Vec::new();\n\n\t\t// If there are events for this date, populate them\n\t\tif let Some(day_events) = events_by_date.get(\u0026date) {\n\t\t\tfor event in day_events {\n\t\t\t\tmatch event.time_of_day {\n\t\t\t\t\tTimeOfDay::Morning =\u003e morning_events.push((*event).into()),\n\t\t\t\t\tTimeOfDay::Afternoon =\u003e afternoon_events.push((*event).into()),\n\t\t\t\t\tTimeOfDay::Evening =\u003e evening_events.push((*event).into()),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#[cfg(not(tarpaulin_include))]\n\t\tfn sort(a: \u0026Event, b: \u0026Event) -\u003e std::cmp::Ordering {\n\t\t\ta.block_index\n\t\t\t\t.unwrap_or(i32::MAX)\n\t\t\t\t.cmp(\u0026b.block_index.unwrap_or(i32::MAX))\n\t\t}\n\t\tmorning_events.sort_by(sort);\n\t\tafternoon_events.sort_by(sort);\n\t\tevening_events.sort_by(sort);\n\n\t\tevent_days.push(EventDay {\n\t\t\tmorning_events,\n\t\t\tafternoon_events,\n\t\t\tevening_events,\n\t\t\tdate,\n\t\t});\n\t}\n\n\tOk(event_days)\n}\n\n/// Returns the unassigned events for this itinerary\nasync fn unassigned_events(event_ids: \u0026[i32], pool: \u0026PgPool) -\u003e ApiResult\u003cVec\u003cEvent\u003e\u003e {\n\tif event_ids.is_empty() {\n\t\treturn Ok(Vec::new());\n\t}\n\n\tlet events = sqlx::query_as!(\n\t\tEvent,\n\t\tr#\"\n\t\tSELECT\n\t\t\tid,\n\t\t\tstreet_address,\n\t\t\tpostal_code,\n\t\t\tcity,\n\t\t\tcountry,\n\t\t\tlat,\n\t\t\tlng,\n\t\t\tevent_type,\n\t\t\tevent_description,\n\t\t\tevent_name,\n\t\t\tuser_created,\n\t\t\thard_start,\n\t\t\thard_end,\n\t\t\ttimezone,\n\t\t\tplace_id,\n\t\t\twheelchair_accessible_parking,\n\t\t\twheelchair_accessible_entrance,\n\t\t\twheelchair_accessible_restroom,\n\t\t\twheelchair_accessible_seating,\n\t\t\tserves_vegetarian_food,\n\t\t\tprice_level,\n\t\t\tutc_offset_minutes,\n\t\t\twebsite_uri,\n\t\t\ttypes,\n\t\t\tphoto_name,\n\t\t\tphoto_width,\n\t\t\tphoto_height,\n\t\t\tphoto_author,\n\t\t\tphoto_author_uri,\n\t\t\tphoto_author_photo_uri,\n\t\t\tweekday_descriptions,\n\t\t\tsecondary_hours_type,\n\t\t\tnext_open_time,\n\t\t\tnext_close_time,\n\t\t\topen_now,\n\t\t\tperiods as \"periods: Vec\u003cPeriod\u003e\",\n\t\t\tspecial_days,\n\t\t\tNULL::int AS block_index\n\t\tFROM events\n\t\tWHERE id = ANY($1)\n\t\t\"#,\n\t\tevent_ids\n\t)\n\t.fetch_all(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(events)\n}\n\n/// Inserts the events associated with this itinerary into the `event_list` table.\n/// Assumes the itinerary was already inserted into `itineraries` table.\n/// Also inserts placeholder entries (event_id = NULL) for empty days to preserve them.\npub async fn insert_event_list(itinerary: Itinerary, pool: \u0026PgPool) -\u003e ApiResult\u003c()\u003e {\n\tlet mut cap = 0;\n\tfor day in itinerary.event_days.iter() {\n\t\tcap += day.morning_events.len();\n\t\tcap += day.afternoon_events.len();\n\t\tcap += day.evening_events.len();\n\t\t// Add 1 for empty days (we'll insert a placeholder)\n\t\tif day.morning_events.is_empty()\n\t\t\t\u0026\u0026 day.afternoon_events.is_empty()\n\t\t\t\u0026\u0026 day.evening_events.is_empty()\n\t\t{\n\t\t\tcap += 1;\n\t\t}\n\t}\n\n\tlet mut times = Vec::with_capacity(cap);\n\tlet mut dates = Vec::with_capacity(cap);\n\tlet mut events: Vec\u003cOption\u003ci32\u003e\u003e = Vec::with_capacity(cap);\n\tlet mut indices: Vec\u003cOption\u003ci32\u003e\u003e = Vec::with_capacity(cap);\n\n\tfor day in itinerary.event_days.into_iter() {\n\t\tlet morning_len = day.morning_events.len();\n\t\tlet afternoon_len = day.afternoon_events.len();\n\t\tlet evening_len = day.evening_events.len();\n\t\tlet is_empty_day = morning_len == 0 \u0026\u0026 afternoon_len == 0 \u0026\u0026 evening_len == 0;\n\n\t\tif is_empty_day {\n\t\t\t// Insert a placeholder entry with NULL event_id to preserve the empty day\n\t\t\ttimes.push(TimeOfDay::Morning);\n\t\t\tdates.push(day.date);\n\t\t\tevents.push(None);\n\t\t\tindices.push(None);\n\t\t} else {\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Morning, morning_len));\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Afternoon, afternoon_len));\n\t\t\ttimes.extend(std::iter::repeat_n(TimeOfDay::Evening, evening_len));\n\n\t\t\tdates.extend(std::iter::repeat_n(\n\t\t\t\tday.date,\n\t\t\t\tmorning_len + afternoon_len + evening_len,\n\t\t\t));\n\n\t\t\tevents.extend(day.morning_events.iter().map(|event| Some(event.id)));\n\t\t\tevents.extend(day.afternoon_events.iter().map(|event| Some(event.id)));\n\t\t\tevents.extend(day.evening_events.iter().map(|event| Some(event.id)));\n\n\t\t\tindices.extend(\n\t\t\t\tday.morning_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t\tindices.extend(\n\t\t\t\tday.afternoon_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t\tindices.extend(\n\t\t\t\tday.evening_events\n\t\t\t\t\t.into_iter()\n\t\t\t\t\t.map(|event| event.block_index),\n\t\t\t);\n\t\t}\n\t}\n\n\tsqlx::query!(\n\t\tr#\"\n\t\tINSERT INTO event_list (itinerary_id, event_id, time_of_day, date, block_index)\n\t\tSELECT $1, events, times, dates, indices\n\t\tFROM UNNEST($2::int4[], $3::time_of_day[], $4::date[], $5::int4[]) as u(events, times, dates, indices);\n\t\t\"#,\n\t\titinerary.id,\n\t\tevents.as_slice() as \u0026[Option\u003ci32\u003e],\n\t\ttimes.as_slice() as \u0026[TimeOfDay],\n\t\tdates.as_slice(),\n\t\tindices.as_slice() as \u0026[Option\u003ci32\u003e],\n\t)\n\t.execute(pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tOk(())\n}\n\n/// Get all saved itineraries for the authenticated user.\n///\n/// # Method\n/// `GET /api/itinerary/saved`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - JSON body `{ \"itineraries\": [Itinerary] }` containing user's saved itineraries with eventlist\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/itinerary/saved\n///   -H \"Cookie: auth-token=...\"\n/// ```\n///\n#[utoipa::path(\n\tget,\n\tpath=\"/saved\",\n\tsummary=\"Fetch all the saved itineraries from this user\",\n\tdescription=\"Fetches all the itineraries from this user that are marked as saved.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"An array of itineraries\",\n\t\t\tbody=SavedResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_saved_itineraries(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cSavedResponse\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/itinerary/saved 'api_saved_itineraries' - User ID: {}\",\n\t\tuser.id\n\t);\n\n\t// Fetch all itineraries for the user\n\tlet itineraries: Vec\u003cItineraryRow\u003e = sqlx::query_as!(\n\t\tItineraryRow,\n\t\tr#\"SELECT\n        \tid,\n         \taccount_id,\n          \tstart_date,\n           \tend_date,\n            chat_session_id,\n            title,\n            unassigned_event_ids\n        FROM itineraries WHERE account_id=$1 AND saved=TRUE\"#,\n\t\tuser.id\n\t)\n\t.fetch_all(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tlet mut res = Vec::with_capacity(itineraries.len());\n\tfor itinerary in itineraries.into_iter() {\n\t\tlet unassigned_ids = itinerary.unassigned_event_ids.unwrap_or_default();\n\t\tres.push(Itinerary {\n\t\t\tid: itinerary.id,\n\t\t\tstart_date: itinerary.start_date,\n\t\t\tend_date: itinerary.end_date,\n\t\t\tevent_days: itinerary_events(\n\t\t\t\titinerary.id,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\t\u0026pool,\n\t\t\t)\n\t\t\t.await?,\n\t\t\tchat_session_id: itinerary.chat_session_id,\n\t\t\ttitle: itinerary.title,\n\t\t\tunassigned_events: unassigned_events(\u0026unassigned_ids, \u0026pool).await?,\n\t\t});\n\t}\n\n\tOk(Json(SavedResponse { itineraries: res }))\n}\n\n/// Get a single saved itinerary either from the user or a public one\n///\n/// # Method\n/// `GET /api/itinerary/{id}`\n///\n/// # Auth\n/// Protected by `auth_middleware` which validates the `auth-token` private cookie,\n/// checks expiration, and injects `Extension\u003cAuthUser\u003e`.\n///\n/// # Responses\n/// - `200 OK` - JSON body `{ \"itinerary\": Itinerary }` containing itinerary metadata\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - When itinerary doesn't exist or doesn't belong to user\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X GET http://localhost:3001/api/itinerary/123\n///   -H \"Cookie: auth-token=...\"\n/// ```\n#[utoipa::path(\n\tget,\n\tpath=\"/saved/{id}\",\n\tsummary=\"Fetch a specific itinerary\",\n\tdescription=\"Fetches the specified itinerary if it belongs to this user or is public.\",\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The desired itinerary\",\n\t\t\tbody=Itinerary,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Itinerary not found\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be GET\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_get_itinerary(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tPath(itinerary_id): Path\u003ci32\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n) -\u003e ApiResult\u003cJson\u003cItinerary\u003e\u003e {\n\tdebug!(\n\t\t\"HANDLER -\u003e\u003e /api/itinerary/{} 'api_get_itinerary' - User ID: {}\",\n\t\titinerary_id, user.id\n\t);\n\n\t// Fetch the itinerary - from user or public\n\tlet itinerary: ItineraryRow = sqlx::query_as!(\n\t\tItineraryRow,\n\t\tr#\"SELECT\n        \tid,\n         \taccount_id,\n          \tstart_date,\n           \tend_date,\n            chat_session_id,\n            title,\n            unassigned_event_ids\n        FROM itineraries WHERE id = $1 AND (account_id = $2 OR is_public=TRUE)\"#,\n\t\titinerary_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tlet unassigned_ids = itinerary.unassigned_event_ids.unwrap_or_default();\n\tOk(Json(Itinerary {\n\t\tid: itinerary.id,\n\t\tstart_date: itinerary.start_date,\n\t\tend_date: itinerary.end_date,\n\t\tevent_days: itinerary_events(\n\t\t\titinerary_id,\n\t\t\titinerary.start_date,\n\t\t\titinerary.end_date,\n\t\t\t\u0026pool,\n\t\t)\n\t\t.await?,\n\t\tchat_session_id: itinerary.chat_session_id,\n\t\ttitle: itinerary.title,\n\t\tunassigned_events: unassigned_events(\u0026unassigned_ids, \u0026pool).await?,\n\t}))\n}\n\n/// Update an existing or save a new itinerary for the user\n///\n/// # Method\n/// `POST /api/itinerary/save`\n///\n/// # Request Body\n/// - [Itinerary]\n///\n/// # Responses\n/// - `200 OK` - with body: [SaveResponse]\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/save\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"id\": 3,\n///         \"start_date\": \"2025-07-15\",\n///         \"end_date\": \"2025-07-21\",\n///         \"event_days\": [\n///           {\n///             \"morning_events\": [],\n///             \"afternoon_events\": [\n///               {\n///                 \"id\": 4,\n///                 \"street_address\": \"3399 North Rd\",\n///                 \"postal_code\": 12601,\n///                 \"city\": \"Poughkeepsie\",\n///                 \"event_type\": \"Park\",\n///                 \"event_description\": \"Take a tour of Marist University\",\n///                 \"event_name\": \"Marist University\"\n///               }\n///             ],\n///             \"evening_events\": [],\n///             \"date\": \"2025-07-21\"\n///           }\n///         ],\n///         \"chat_session_id\": 4,\n///         \"title\": \"Poughkeepsie 7/15-21 2025\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/save\",\n\tsummary=\"Save a new or update an existing itinerary\",\n\tdescription=\"If the itinerary id is already saved for this user, it's updated with the provided values. Otherwise a new one is created.\",\n\trequest_body(\n\t\tcontent=Itinerary,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"The itinerary to save for the user.\",\n\t\t//TODO example\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"The id of the itinerary that was just saved. It may be the same as the id passed in the request.\",\n\t\t\tbody=SaveResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\t//TODO example\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_save(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(itinerary): Json\u003cItinerary\u003e,\n) -\u003e ApiResult\u003cJson\u003cSaveResponse\u003e\u003e {\n\t// check if itinerary id already exists for this user\n\tlet id_opt = sqlx::query!(\n\t\tr#\"SELECT id FROM itineraries WHERE id=$1 AND account_id=$2\"#,\n\t\titinerary.id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.map(|record| record.id);\n\n\t// Extract unassigned event IDs\n\tlet unassigned_event_ids: Vec\u003ci32\u003e = itinerary.unassigned_events.iter().map(|e| e.id).collect();\n\n\t// if it doesn't exist, insert a new one\n\tlet id = match id_opt {\n\t\tSome(id) =\u003e {\n\t\t\t// UPDATE existing itinerary and set saved=TRUE\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tUPDATE itineraries\n\t\t\t\tSET start_date = $1, end_date = $2, title = $3, chat_session_id = $4, saved = TRUE, unassigned_event_ids = $7\n\t\t\t\tWHERE id = $5 AND account_id = $6;\n\t\t\t\t\"#,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\titinerary.title,\n\t\t\t\titinerary.chat_session_id,\n\t\t\t\tid,\n\t\t\t\tuser.id,\n\t\t\t\t\u0026unassigned_event_ids\n\t\t\t)\n\t\t\t.execute(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?;\n\n\t\t\tid\n\t\t}\n\t\tNone =\u003e {\n\t\t\tsqlx::query!(\n\t\t\t\tr#\"\n\t\t\t\tINSERT INTO itineraries (account_id, is_public, start_date, end_date, chat_session_id, saved, title, unassigned_event_ids)\n\t\t\t\tVALUES ($1, FALSE, $2, $3, $4, TRUE, $5, $6)\n\t\t\t\tRETURNING id;\n\t\t\t\t\"#,\n\t\t\t\tuser.id,\n\t\t\t\titinerary.start_date,\n\t\t\t\titinerary.end_date,\n\t\t\t\titinerary.chat_session_id,\n\t\t\t\titinerary.title,\n\t\t\t\t\u0026unassigned_event_ids\n\t\t\t)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.map_err(AppError::from)?\n\t\t\t.id\n\t\t}\n\t};\n\n\t// delete event_list for this itinerary and make a new one\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM event_list\n\t\tWHERE itinerary_id=$1;\n\t\t\"#,\n\t\tid\n\t)\n\t.execute(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?;\n\n\tinsert_event_list(itinerary, \u0026pool).await?;\n\n\tOk(Json(SaveResponse { id }))\n}\n\n/// Unsave an existing itinerary for the user\n///\n/// # Method\n/// `POST /api/itinerary/unsave`\n///\n/// # Request Body\n/// - [UnsaveRequest]\n///\n/// # Responses\n/// - `200 OK` - Successfully unsaved itinerary for this user\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - Itinerary not found or doesn't belong to user (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/unsave\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"id\": 3\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/unsave\",\n\tsummary=\"Unsave an existing itinerary\",\n\tdescription=\"Sets the saved field to false for the given itinerary. Verifies the itinerary belongs to the user.\",\n\trequest_body(\n\t\tcontent=UnsaveRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"The itinerary id to unsave.\"\n\t),\n\tresponses(\n\t\t(status=200, description=\"Successfully unsaved itinerary\"),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"Itinerary not found or doesn't belong to user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_unsave(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(UnsaveRequest { id }): Json\u003cUnsaveRequest\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\t// Update the itinerary to set saved=FALSE\n\tsqlx::query!(\n\t\tr#\"\n\t\tUPDATE itineraries\n\t\tSET saved = FALSE\n\t\tWHERE id = $1 AND account_id = $2\n\t\tRETURNING id;\n\t\t\"#,\n\t\tid,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\n\tOk(())\n}\n\n/// Insert or update a user-created custom event\n///\n/// # Method\n/// `POST /api/itinerary/userEvent`\n///\n/// # Request Body\n/// - [UserEventRequest]\n///\n/// # Responses\n/// - `200 OK` - with body: [UserEventResponse] - event id that was just inserted or updated\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `404 NOT_FOUND` - The provided event id does not belong to the user or does not exist (public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Examples\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/userEvent\n///   -H \"Content-Type: application/json\"\n///   -d '{\n///         \"event_name\": \"Custom Event\",\n///\t        \"event_description\": \"I want to do something and it's easier to make a custom event than to tell the LLM exactly how I want it.\"\n///       }'\n/// ```\n#[utoipa::path(\n\tpost,\n\tpath=\"/userEvent\",\n\tsummary=\"Insert or update a user-created custom event\",\n\tdescription=\"Insert a new or updates an existing user-created event with the values passed in the request, returning the event id.\",\n\trequest_body(\n\t\tcontent=UserEventRequest,\n\t\tcontent_type=\"application/json\",\n\t\tdescription=\"If id is provided, the event will be updated, otherwise it is inserted. The event name is required.\",\n\t\texample=json!({\n\t\t\t\"event_name\": \"Custom Event\",\n\t\t\t\"event_description\": \"I want to do something and it's easier to make a custom event than to tell the LLM exactly how I want it.\"\n\t\t})\n\t),\n\tresponses(\n\t\t(\n\t\t\tstatus=200,\n\t\t\tdescription=\"Contains the id of the event that was just inserted or updated.\",\n\t\t\tbody=UserEventResponse,\n\t\t\tcontent_type=\"application/json\",\n\t\t\texample=json!({\n\t\t\t\t\"id\": 43\n\t\t\t})\n\t\t),\n\t\t(status=400, description=\"Bad Request\"),\n\t\t(status=401, description=\"User has an invalid cookie/no cookie\"),\n\t\t(status=404, description=\"User-event not found for this user\"),\n\t\t(status=405, description=\"Method Not Allowed - Must be POST\"),\n\t\t(status=408, description=\"Request Timed Out\"),\n\t\t(status=500, description=\"Internal Server Error\")\n\t),\n\tsecurity((\"set-cookie\"=[])),\n\ttag=\"Itinerary\"\n)]\npub async fn api_user_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(event): Json\u003cUserEventRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cUserEventResponse\u003e\u003e {\n\tif event.event_name.is_empty() {\n\t\treturn Err(AppError::BadRequest(String::from(\n\t\t\t\"Event name must not be empty\",\n\t\t)));\n\t}\n\tlet id = if let Some(id) = event.id {\n\t\tsqlx::query!(\n\t\t\tr#\"\n\t\t\tUPDATE events\n\t\t\tSET\n\t\t\t\tstreet_address    = $1,\n\t\t\t\tpostal_code       = $2,\n\t\t\t\tcity              = $3,\n\t\t\t\tcountry           = $4,\n\t\t\t\tevent_type        = $5,\n\t\t\t\tevent_description = $6,\n\t\t\t\tevent_name        = $7,\n\t\t\t\thard_start        = $8,\n\t\t\t\thard_end          = $9,\n\t\t\t\ttimezone          = $10,\n\t\t\t\tphoto_name        = $11\n\t\t\tWHERE id=$12 AND user_created=TRUE AND account_id=$13\n\t\t\tRETURNING id\n\t\t\t\"#,\n\t\t\tevent.street_address,\n\t\t\tevent.postal_code,\n\t\t\tevent.city,\n\t\t\tevent.country,\n\t\t\tevent.event_type,\n\t\t\tevent.event_description,\n\t\t\tevent.event_name,\n\t\t\tevent.hard_start,\n\t\t\tevent.hard_end,\n\t\t\tevent.timezone,\n\t\t\tevent.photo_name,\n\t\t\tid,\n\t\t\tuser.id,\n\t\t)\n\t\t.fetch_optional(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.ok_or(AppError::NotFound)?;\n\t\tid\n\t} else {\n\t\tsqlx::query!(\n\t\t\tr#\"\n\t\t\tINSERT INTO events(\n\t\t\t\tstreet_address, postal_code, city, country,\n\t\t\t\tevent_type, event_description, event_name,\n\t\t\t\tuser_created, account_id, hard_start, hard_end,\n\t\t\t\ttimezone, photo_name\n\t\t\t)\n\t\t\tVALUES($1, $2, $3, $4, $5, $6, $7, TRUE, $8, $9, $10, $11, $12)\n\t\t\tRETURNING id\n\t\t\t\"#,\n\t\t\tevent.street_address,\n\t\t\tevent.postal_code,\n\t\t\tevent.city,\n\t\t\tevent.country,\n\t\t\tevent.event_type,\n\t\t\tevent.event_description,\n\t\t\tevent.event_name,\n\t\t\tuser.id,\n\t\t\tevent.hard_start,\n\t\t\tevent.hard_end,\n\t\t\tevent.timezone,\n\t\t\tevent.photo_name,\n\t\t)\n\t\t.fetch_one(\u0026pool)\n\t\t.await\n\t\t.map_err(AppError::from)?\n\t\t.id\n\t};\n\tOk(Json(UserEventResponse { id }))\n}\n\n/// Searches for events that match the filter and returns a list of possible events\n///\n/// # Method\n/// `POST /api/itinerary/searchEvent`\n///\n/// # Request Body\n/// - [SearchEventRequest]\n///   - Example filters:\n///     - `event_name`: Partial name of the event (case-insensitive)\n///     - `city`: Partial city name\n///     - `event_type`: Type of event\n///     - `hard_start_after`: ISO 8601 timestamp to filter events starting after this time\n///     - `hard_start_before`: ISO 8601 timestamp to filter events starting before this time\n///\n/// # Responses\n/// - `200 OK` - with body: [SearchEventResponse] - the best matching events for the query\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Example Request\n/// ```bash\n/// curl -X POST http://localhost:3001/api/itinerary/searchEvent \\\n///   -H \"Content-Type: application/json\" \\\n///   -d '{\n///         \"event_name\": \"Music Festival\",\n///         \"city\": \"New York\",\n///         \"event_type\": \"Concert\",\n///         \"hard_start_after\": \"2025-11-01T00:00:00\",\n///         \"hard_start_before\": \"2025-11-30T23:59:59\"\n///       }'\n/// ```\n///\n/// # Example Response\n/// ```json\n/// {\n///   \"events\": [\n///     {\n///       \"id\": 1,\n///       \"street_address\": \"123 Main St\",\n///       \"postal_code\": 10001,\n///       \"city\": \"New York\",\n///       \"event_type\": \"Concert\",\n///       \"event_description\": \"Annual music festival in the park\",\n///       \"event_name\": \"NY Music Festival\",\n///       \"user_created\": false,\n///       \"account_id\": 2,\n///       \"hard_start\": \"2025-11-15T18:00:00\",\n///       \"hard_end\": \"2025-11-15T23:00:00\",\n///       \"timezone\": \"America/New_York\"\n///     },\n///     {\n///       \"id\": 2,\n///       \"street_address\": \"456 Broadway\",\n///       \"postal_code\": 10002,\n///       \"city\": \"New York\",\n///       \"event_type\": \"Concert\",\n///       \"event_description\": \"Indie music showcase\",\n///       \"event_name\": \"Indie Night\",\n///       \"user_created\": true,\n///       \"account_id\": 3,\n///       \"hard_start\": \"2025-11-20T19:00:00\",\n///       \"hard_end\": \"2025-11-20T22:00:00\",\n///       \"timezone\": \"America/New_York\"\n///     }\n///   ]\n/// }\n/// ```\n#[utoipa::path(\n    post,\n    path=\"/searchEvent\",\n    summary=\"Search for events with the given filters and return a list of the best matching events\",\n    description=\"Returns a limited number of events that best match the filters provided in the request.\",\n    request_body(\n        content=SearchEventRequest,\n        content_type=\"application/json\",\n        description=\"Uses the filters, if provided, to search for the best matching events.\",\n        example=json!({\n            \"event_name\": \"Music Festival\",\n            \"city\": \"New York\",\n            \"event_type\": \"Concert\",\n            \"hard_start_after\": \"2025-11-01T00:00:00\",\n            \"hard_start_before\": \"2025-11-30T23:59:59\",\n            \"timezone\": \"America/New_York\"\n        })\n    ),\n    responses(\n        (\n            status=200,\n            description=\"A list of the best matching events for the given filters.\",\n            body=SearchEventResponse,\n            content_type=\"application/json\",\n            example=json!({\n                \"events\": [\n                    {\n                        \"id\": 1,\n                        \"street_address\": \"123 Main St\",\n                        \"postal_code\": 10001,\n                        \"city\": \"New York\",\n                        \"event_type\": \"Concert\",\n                        \"event_description\": \"Annual music festival in the park\",\n                        \"event_name\": \"NY Music Festival\",\n                        \"user_created\": false,\n                        \"account_id\": 2,\n                        \"hard_start\": \"2025-11-15T18:00:00\",\n                        \"hard_end\": \"2025-11-15T23:00:00\",\n                        \"timezone\": \"America/New_York\"\n                    },\n                    {\n                        \"id\": 2,\n                        \"street_address\": \"456 Broadway\",\n                        \"postal_code\": 10002,\n                        \"city\": \"New York\",\n                        \"event_type\": \"Concert\",\n                        \"event_description\": \"Indie music showcase\",\n                        \"event_name\": \"Indie Night\",\n                        \"user_created\": true,\n                        \"account_id\": 3,\n                        \"hard_start\": \"2025-11-20T19:00:00\",\n                        \"hard_end\": \"2025-11-20T22:00:00\",\n                        \"timezone\": \"America/New_York\"\n                    }\n                ]\n            })\n        ),\n        (status=400, description=\"Bad Request\"),\n        (status=401, description=\"User has an invalid cookie/no cookie\"),\n        (status=405, description=\"Method Not Allowed - Must be POST\"),\n        (status=408, description=\"Request Timed Out\"),\n        (status=500, description=\"Internal Server Error\")\n    ),\n    security((\"set-cookie\"=[])),\n    tag=\"Itinerary\"\n)]\npub async fn api_search_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tJson(query): Json\u003cSearchEventRequest\u003e,\n) -\u003e ApiResult\u003cJson\u003cSearchEventResponse\u003e\u003e {\n\tlet mut qb = sqlx::QueryBuilder::new(\n\t\t\"SELECT *, NULL::int as block_index FROM events WHERE (user_created=FALSE OR account_id=\",\n\t);\n\tqb.push_bind(user.id).push(\")\");\n\t// Dynamically add filters if present\n\tif let Some(id) = query.id {\n\t\tqb.push(\" AND id = \").push_bind(id);\n\t}\n\tif let Some(street_address) = query.street_address {\n\t\tqb.push(\" AND street_address ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", street_address));\n\t}\n\tif let Some(postal_code) = query.postal_code {\n\t\tqb.push(\" AND postal_code = \").push_bind(postal_code);\n\t}\n\tif let Some(city) = query.city {\n\t\tqb.push(\" AND city ILIKE \").push_bind(format!(\"%{}%\", city));\n\t}\n\tif let Some(country) = query.country {\n\t\tqb.push(\" AND country ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", country));\n\t}\n\tif let Some(event_type) = query.event_type {\n\t\tqb.push(\" AND event_type ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_type));\n\t}\n\tif let Some(event_description) = query.event_description {\n\t\tqb.push(\" AND event_description ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_description));\n\t}\n\tif let Some(event_name) = query.event_name {\n\t\tqb.push(\" AND event_name ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", event_name));\n\t}\n\tif let Some(hard_start_before) = query.hard_start_before {\n\t\tqb.push(\" AND hard_start \u003c \").push_bind(hard_start_before);\n\t}\n\tif let Some(hard_start_after) = query.hard_start_after {\n\t\tqb.push(\" AND hard_start \u003e \").push_bind(hard_start_after);\n\t}\n\tif let Some(hard_end_before) = query.hard_end_before {\n\t\tqb.push(\" AND hard_end \u003c \").push_bind(hard_end_before);\n\t}\n\tif let Some(hard_end_after) = query.hard_end_after {\n\t\tqb.push(\" AND hard_end \u003e \").push_bind(hard_end_after);\n\t}\n\tif let Some(timezone) = query.timezone {\n\t\tqb.push(\" AND timezone ILIKE \")\n\t\t\t.push_bind(format!(\"%{}%\", timezone));\n\t}\n\tqb.push(\" ORDER BY hard_start ASC LIMIT \")\n\t\t.push_bind(EVENT_SEARCH_RESULT_LEN);\n\tOk(Json(SearchEventResponse {\n\t\tevents: qb.build_query_as().fetch_all(\u0026pool).await?,\n\t}))\n}\n\n/// Deletes a user-created event from the db\n///\n/// # Method\n/// `DELETE /api/itinerary/userEvent/:id`\n///\n/// # Responses\n/// - `200 OK` - User-created event deleted successfully\n/// - `400 BAD_REQUEST` - Request payload contains invalid data (public error)\n/// - `404 NOT_FOUND` - User-created event was not found or does not belong to this user (public error)\n/// - `401 UNAUTHORIZED` - When authentication fails (handled in middleware, public error)\n/// - `500 INTERNAL_SERVER_ERROR` - Internal error (private)\n///\n/// # Example Request\n/// ```bash\n/// curl -X DELETE http://localhost:3001/api/itinerary/userEvent/:14 \\\n///   -H \"Content-Type: application/json\" \\\n/// ```\n#[utoipa::path(\n    delete,\n    path=\"/userEvent/{id}\",\n    summary=\"Deletes a user-event from the DB\",\n    description=\"Deletes the user-created event from the DB using the provided event ID. Event must have been created by this user.\",\n    responses(\n        (status=200, description=\"User-created event successfully deleted\"),\n        (status=400, description=\"Bad Request\"),\n        (status=401, description=\"User has an invalid cookie/no cookie\"),\n        (status=404, description=\"User-event not found or does not belong to this user\"),\n        (status=405, description=\"Method Not Allowed - Must be POST\"),\n        (status=408, description=\"Request Timed Out\"),\n        (status=500, description=\"Internal Server Error\")\n    ),\n    security((\"set-cookie\"=[])),\n    tag=\"Itinerary\"\n)]\npub async fn api_delete_user_event(\n\tExtension(user): Extension\u003cAuthUser\u003e,\n\tExtension(pool): Extension\u003cPgPool\u003e,\n\tPath(event_id): Path\u003ci32\u003e,\n) -\u003e ApiResult\u003c()\u003e {\n\tsqlx::query!(\n\t\tr#\"\n\t\tDELETE FROM events\n\t\tWHERE\n\t\t\tid=$1 AND\n\t\t\taccount_id=$2 AND\n\t\t\tuser_created=TRUE\n\t\tRETURNING id;\n\t\t\"#,\n\t\tevent_id,\n\t\tuser.id\n\t)\n\t.fetch_optional(\u0026pool)\n\t.await\n\t.map_err(AppError::from)?\n\t.ok_or(AppError::NotFound)?;\n\tOk(())\n}\n\n/// Create the itinerary routes with authentication middleware.\n///\n/// # Routes\n/// - `GET /saved` - Get user's saved itineraries (protected)\n/// - `POST /save` - Inserts into or updates the user's itinerary in the db (protected)\n/// - `GET /{id}` - Get single itinerary metadata (protected)\n/// - `POST /userEvent` - Insert or update a user-created custom event (protected)\n/// - `POST /searchEvent` - queries the DB for an event that matches the provided filters (protected)\n/// - `DELETE /userEvent/{id}` - Deletes the user-created event from the db (protected)\n///\n/// # Middleware\n/// All routes are protected by `middleware_auth` which validates the `auth-token` cookie.\npub fn itinerary_routes() -\u003e AxumRouter {\n\tAxumRouter::new()\n\t\t.route(\"/saved\", get(api_saved_itineraries))\n\t\t.route(\"/save\", post(api_save))\n\t\t.route(\"/unsave\", post(api_unsave))\n\t\t.route(\"/{id}\", get(api_get_itinerary))\n\t\t.route(\"/userEvent\", post(api_user_event))\n\t\t.route(\"/searchEvent\", post(api_search_event))\n\t\t.route(\"/userEvent/{id}\", delete(api_delete_user_event))\n\t\t.route_layer(axum::middleware::from_fn(middleware_auth))\n}\n","traces":[{"line":53,"address":[41886400],"length":1,"stats":{"Line":1}},{"line":60,"address":[42418941,42419510,42418784,42419559,42419776,42419941,42419354,42419874,42420805,42418871],"length":1,"stats":{"Line":4}},{"line":69,"address":[42419402],"length":1,"stats":{"Line":1}},{"line":70,"address":[42419495,42419824,42418837,42419621,42419540],"length":1,"stats":{"Line":4}},{"line":71,"address":[42419851,42419909],"length":1,"stats":{"Line":1}},{"line":74,"address":[42420147,42420561,42420734,42420042,42420077,42421152,42420987,42421085,42420783],"length":1,"stats":{"Line":4}},{"line":125,"address":[42420632],"length":1,"stats":{"Line":1}},{"line":126,"address":[38919297],"length":1,"stats":{"Line":4}},{"line":127,"address":[42421062,42421120],"length":1,"stats":{"Line":1}},{"line":131,"address":[42421257],"length":1,"stats":{"Line":1}},{"line":132,"address":[42421388,42421312],"length":1,"stats":{"Line":2}},{"line":133,"address":[42423275,42421573],"length":1,"stats":{"Line":2}},{"line":137,"address":[42421613],"length":1,"stats":{"Line":1}},{"line":139,"address":[42421846,42421628,42423208,42421719],"length":1,"stats":{"Line":4}},{"line":140,"address":[42421902],"length":1,"stats":{"Line":1}},{"line":141,"address":[42422163],"length":1,"stats":{"Line":1}},{"line":142,"address":[42422232],"length":1,"stats":{"Line":1}},{"line":145,"address":[42422301,42422380],"length":1,"stats":{"Line":2}},{"line":146,"address":[42422490,42422435],"length":1,"stats":{"Line":2}},{"line":147,"address":[42422591],"length":1,"stats":{"Line":1}},{"line":148,"address":[42422633,42422718],"length":1,"stats":{"Line":2}},{"line":149,"address":[42422753,42422663],"length":1,"stats":{"Line":2}},{"line":150,"address":[42422693,42422788],"length":1,"stats":{"Line":2}},{"line":160,"address":[42422460,42422833],"length":1,"stats":{"Line":2}},{"line":161,"address":[42422848],"length":1,"stats":{"Line":1}},{"line":162,"address":[42422890],"length":1,"stats":{"Line":1}},{"line":164,"address":[42423044],"length":1,"stats":{"Line":1}},{"line":165,"address":[42422924],"length":1,"stats":{"Line":1}},{"line":166,"address":[42422964],"length":1,"stats":{"Line":1}},{"line":167,"address":[42423004],"length":1,"stats":{"Line":1}},{"line":172,"address":[42421927],"length":1,"stats":{"Line":1}},{"line":176,"address":[41886578,41886560],"length":1,"stats":{"Line":4}},{"line":177,"address":[42423622,42423512],"length":1,"stats":{"Line":2}},{"line":178,"address":[42424333,42423670],"length":1,"stats":{"Line":2}},{"line":181,"address":[42424729,42424930,42424790,42424260,42424634,42423680,42424138,42423633,42423737,42424305],"length":1,"stats":{"Line":0}},{"line":228,"address":[42424225],"length":1,"stats":{"Line":0}},{"line":229,"address":[38921321],"length":1,"stats":{"Line":0}},{"line":230,"address":[42424709,42424761],"length":1,"stats":{"Line":0}},{"line":232,"address":[42424865],"length":1,"stats":{"Line":0}},{"line":238,"address":[42430828,42424944,42427754,42430208,42424999,42425231],"length":1,"stats":{"Line":4}},{"line":239,"address":[42425196],"length":1,"stats":{"Line":1}},{"line":240,"address":[42425208,42425338],"length":1,"stats":{"Line":2}},{"line":241,"address":[42429831,42425526,42429886],"length":1,"stats":{"Line":2}},{"line":242,"address":[42429870,42429912,42429967],"length":1,"stats":{"Line":2}},{"line":243,"address":[42429951,42429993,42430043],"length":1,"stats":{"Line":2}},{"line":245,"address":[42430182,42430032,42430068],"length":1,"stats":{"Line":2}},{"line":246,"address":[42430085],"length":1,"stats":{"Line":0}},{"line":247,"address":[42430121],"length":1,"stats":{"Line":0}},{"line":249,"address":[42430149,42430187],"length":1,"stats":{"Line":0}},{"line":253,"address":[42425552],"length":1,"stats":{"Line":1}},{"line":254,"address":[42425589],"length":1,"stats":{"Line":1}},{"line":255,"address":[42425677],"length":1,"stats":{"Line":1}},{"line":256,"address":[42425762],"length":1,"stats":{"Line":1}},{"line":258,"address":[42429647,42426091,42425843,42425957],"length":1,"stats":{"Line":4}},{"line":259,"address":[42426244,42427809],"length":1,"stats":{"Line":2}},{"line":260,"address":[42427817],"length":1,"stats":{"Line":1}},{"line":261,"address":[42427856],"length":1,"stats":{"Line":1}},{"line":262,"address":[42427903],"length":1,"stats":{"Line":1}},{"line":264,"address":[42427957],"length":1,"stats":{"Line":1}},{"line":266,"address":[42428029],"length":1,"stats":{"Line":0}},{"line":267,"address":[42429397],"length":1,"stats":{"Line":0}},{"line":268,"address":[42429437],"length":1,"stats":{"Line":0}},{"line":269,"address":[42429468],"length":1,"stats":{"Line":0}},{"line":271,"address":[42427983,42428078],"length":1,"stats":{"Line":2}},{"line":272,"address":[42428111],"length":1,"stats":{"Line":1}},{"line":273,"address":[42428208],"length":1,"stats":{"Line":1}},{"line":275,"address":[42428313,42428494,42428428],"length":1,"stats":{"Line":3}},{"line":276,"address":[42428328],"length":1,"stats":{"Line":1}},{"line":277,"address":[42428450,42428342],"length":1,"stats":{"Line":1}},{"line":280,"address":[42431258,42431248,42428516],"length":1,"stats":{"Line":3}},{"line":281,"address":[42431280,42431290,42428685],"length":1,"stats":{"Line":3}},{"line":282,"address":[42428854,42431312,42431322],"length":1,"stats":{"Line":3}},{"line":284,"address":[42428987,42429089],"length":1,"stats":{"Line":2}},{"line":285,"address":[42428998],"length":1,"stats":{"Line":1}},{"line":286,"address":[42429054],"length":1,"stats":{"Line":1}},{"line":287,"address":[42429077,42431364,42431344],"length":1,"stats":{"Line":3}},{"line":289,"address":[42429119,42429221],"length":1,"stats":{"Line":2}},{"line":290,"address":[42429130],"length":1,"stats":{"Line":1}},{"line":291,"address":[42429186],"length":1,"stats":{"Line":1}},{"line":292,"address":[42431408,42429209,42431428],"length":1,"stats":{"Line":3}},{"line":294,"address":[42429251,42429353],"length":1,"stats":{"Line":2}},{"line":295,"address":[42429262],"length":1,"stats":{"Line":1}},{"line":296,"address":[42429318],"length":1,"stats":{"Line":1}},{"line":297,"address":[42431492,42429341,42431472],"length":1,"stats":{"Line":3}},{"line":302,"address":[42426731,42426661,42426285,42426560,42426638,42427732,42426474,42427674,42430504,42427569,42430571,42426388,42430403],"length":1,"stats":{"Line":8}},{"line":309,"address":[42426310],"length":1,"stats":{"Line":1}},{"line":310,"address":[42426396],"length":1,"stats":{"Line":1}},{"line":311,"address":[42426482],"length":1,"stats":{"Line":1}},{"line":312,"address":[42426568],"length":1,"stats":{"Line":1}},{"line":314,"address":[42427636],"length":1,"stats":{"Line":1}},{"line":315,"address":[38920800],"length":1,"stats":{"Line":4}},{"line":316,"address":[42430481,42430539],"length":1,"stats":{"Line":1}},{"line":318,"address":[42430628],"length":1,"stats":{"Line":1}},{"line":363,"address":[41896496],"length":1,"stats":{"Line":1}},{"line":367,"address":[42460005,42459831,42460426],"length":1,"stats":{"Line":3}},{"line":373,"address":[42461710,42460379,42462661,42461643,42462340,42463160,42462114,42462728,42462288,42462560],"length":1,"stats":{"Line":4}},{"line":386,"address":[42462185],"length":1,"stats":{"Line":1}},{"line":387,"address":[38927967],"length":1,"stats":{"Line":4}},{"line":388,"address":[42462696,42462638],"length":1,"stats":{"Line":1}},{"line":390,"address":[42462848,42462921],"length":1,"stats":{"Line":2}},{"line":391,"address":[42463988,42464041,42463073,42462950],"length":1,"stats":{"Line":3}},{"line":392,"address":[42464141],"length":1,"stats":{"Line":0}},{"line":393,"address":[42464526,42463665],"length":1,"stats":{"Line":0}},{"line":394,"address":[42464542],"length":1,"stats":{"Line":0}},{"line":395,"address":[42464556],"length":1,"stats":{"Line":0}},{"line":396,"address":[42464570],"length":1,"stats":{"Line":0}},{"line":397,"address":[42465429,42464658,42464899,42464845,42464620,42464994],"length":1,"stats":{"Line":0}},{"line":398,"address":[42464584],"length":1,"stats":{"Line":0}},{"line":399,"address":[42464591],"length":1,"stats":{"Line":0}},{"line":400,"address":[42464598],"length":1,"stats":{"Line":0}},{"line":401,"address":[42464605],"length":1,"stats":{"Line":0}},{"line":403,"address":[42464877,42464696,42459913,42463206,42464643,42464683,42464964],"length":1,"stats":{"Line":0}},{"line":404,"address":[42465095],"length":1,"stats":{"Line":0}},{"line":405,"address":[42465119],"length":1,"stats":{"Line":0}},{"line":406,"address":[42465248,42463236,42463525,42465334,42463263,42465151,42459934],"length":1,"stats":{"Line":0}},{"line":410,"address":[42464219],"length":1,"stats":{"Line":1}},{"line":456,"address":[41900752],"length":1,"stats":{"Line":1}},{"line":461,"address":[42469269,42468653,42468824],"length":1,"stats":{"Line":3}},{"line":467,"address":[42470707,42471207,42470640,42471663,42472044,42472618,42471796,42472660,42471437,42469198,42471872,42471385,42472120],"length":1,"stats":{"Line":7}},{"line":481,"address":[42471278],"length":1,"stats":{"Line":1}},{"line":482,"address":[38920092],"length":1,"stats":{"Line":4}},{"line":483,"address":[42471840,42471773],"length":1,"stats":{"Line":1}},{"line":484,"address":[42471985,42472088],"length":1,"stats":{"Line":2}},{"line":486,"address":[42472314],"length":1,"stats":{"Line":1}},{"line":487,"address":[42473859],"length":1,"stats":{"Line":1}},{"line":488,"address":[42472420],"length":1,"stats":{"Line":1}},{"line":489,"address":[42472431],"length":1,"stats":{"Line":1}},{"line":490,"address":[42472442],"length":1,"stats":{"Line":1}},{"line":491,"address":[42472879,42473415,42472566,42472825,42472480,42472974],"length":1,"stats":{"Line":4}},{"line":492,"address":[42472453],"length":1,"stats":{"Line":1}},{"line":493,"address":[42472460],"length":1,"stats":{"Line":1}},{"line":494,"address":[42472464],"length":1,"stats":{"Line":1}},{"line":495,"address":[42472468],"length":1,"stats":{"Line":1}},{"line":497,"address":[42472670,42472551,42472599,42468735,42472944,42472857],"length":1,"stats":{"Line":4}},{"line":498,"address":[42473075],"length":1,"stats":{"Line":1}},{"line":499,"address":[42473093],"length":1,"stats":{"Line":1}},{"line":500,"address":[42468756,42473719,42473451,42473215,42473298,42473121],"length":1,"stats":{"Line":4}},{"line":576,"address":[41905600],"length":1,"stats":{"Line":1}},{"line":582,"address":[42479329,42479500,42479228,42478773,42479005,42478006,42479396,42478182,42478252,42478950,42482657],"length":1,"stats":{"Line":5}},{"line":587,"address":[42478844],"length":1,"stats":{"Line":1}},{"line":588,"address":[42478085,42479067,42478983,42478935,42479276],"length":1,"stats":{"Line":4}},{"line":589,"address":[42479306,42479364],"length":1,"stats":{"Line":1}},{"line":590,"address":[39099787,39099759],"length":1,"stats":{"Line":3}},{"line":593,"address":[42485514,42479514,42485504],"length":1,"stats":{"Line":1}},{"line":596,"address":[42479660],"length":1,"stats":{"Line":1}},{"line":597,"address":[42479687],"length":1,"stats":{"Line":1}},{"line":599,"address":[42482851,42479718,42479878,42481382,42482635,42482474,42481452,42483019,42482583,42483130,42482952],"length":1,"stats":{"Line":5}},{"line":611,"address":[42479856],"length":1,"stats":{"Line":1}},{"line":613,"address":[42482525],"length":1,"stats":{"Line":1}},{"line":614,"address":[39099604],"length":1,"stats":{"Line":4}},{"line":615,"address":[42482987,42482929],"length":1,"stats":{"Line":1}},{"line":617,"address":[42483073],"length":1,"stats":{"Line":1}},{"line":620,"address":[42484213,42480157,42480064,42481302,42483498,42481360,42481122,42479912,42483431,42483330,42480087],"length":1,"stats":{"Line":5}},{"line":631,"address":[42480042],"length":1,"stats":{"Line":1}},{"line":633,"address":[42481193],"length":1,"stats":{"Line":1}},{"line":634,"address":[42481287,42483169,42478127,42481335,42483378],"length":1,"stats":{"Line":4}},{"line":635,"address":[42483408,42483466],"length":1,"stats":{"Line":1}},{"line":636,"address":[42483559],"length":1,"stats":{"Line":1}},{"line":641,"address":[42483628,42484030,42483564,42484485,42483093,42484191,42484813,42484552,42484384,42484139],"length":1,"stats":{"Line":4}},{"line":648,"address":[42484081],"length":1,"stats":{"Line":1}},{"line":649,"address":[42484172,42484432,42478148,42484226,42484124],"length":1,"stats":{"Line":4}},{"line":650,"address":[42484520,42484462],"length":1,"stats":{"Line":1}},{"line":652,"address":[39099667],"length":1,"stats":{"Line":2}},{"line":654,"address":[42485145],"length":1,"stats":{"Line":1}},{"line":702,"address":[41909744],"length":1,"stats":{"Line":1}},{"line":708,"address":[42491393,42492297,42492395,42492629,42491329,42492851,42492095,42491258,42492052,42492829,42491884,42492462,42492571],"length":1,"stats":{"Line":7}},{"line":718,"address":[42491952],"length":1,"stats":{"Line":1}},{"line":719,"address":[39104016],"length":1,"stats":{"Line":4}},{"line":720,"address":[42492372,42492430],"length":1,"stats":{"Line":1}},{"line":721,"address":[39104109,39104063],"length":1,"stats":{"Line":2}},{"line":723,"address":[42492678],"length":1,"stats":{"Line":1}},{"line":784,"address":[41916240],"length":1,"stats":{"Line":1}},{"line":789,"address":[42494235,42494103],"length":1,"stats":{"Line":2}},{"line":790,"address":[42494268,42498847],"length":1,"stats":{"Line":0}},{"line":794,"address":[42494249,42500051,42494306],"length":1,"stats":{"Line":3}},{"line":795,"address":[42494354,42499538,42499471,42499191,42497001,42499292,42496943,42499654,42496808,42499359,42495074,42495004],"length":1,"stats":{"Line":5}},{"line":827,"address":[42496882],"length":1,"stats":{"Line":1}},{"line":828,"address":[42499239,42499030,42496976,42496928,42494147],"length":1,"stats":{"Line":4}},{"line":829,"address":[42499327,42499269],"length":1,"stats":{"Line":1}},{"line":830,"address":[42499420,42499506],"length":1,"stats":{"Line":1}},{"line":831,"address":[42499590],"length":1,"stats":{"Line":1}},{"line":833,"address":[42497029,42498636,42497099,42499930,42499997,42500266,42499829,42498825,42498771,42494678],"length":1,"stats":{"Line":4}},{"line":857,"address":[42498710],"length":1,"stats":{"Line":1}},{"line":858,"address":[42498804,42499672,42494168,42499877,42498756],"length":1,"stats":{"Line":4}},{"line":859,"address":[42499907,42499965],"length":1,"stats":{"Line":1}},{"line":862,"address":[42499611],"length":1,"stats":{"Line":1}},{"line":999,"address":[41929968],"length":1,"stats":{"Line":1}},{"line":1007,"address":[42509184,42509099],"length":1,"stats":{"Line":2}},{"line":1009,"address":[42509215],"length":1,"stats":{"Line":1}},{"line":1010,"address":[42509254,42509350],"length":1,"stats":{"Line":2}},{"line":1012,"address":[42509371,42509300],"length":1,"stats":{"Line":2}},{"line":1013,"address":[42509408],"length":1,"stats":{"Line":1}},{"line":1014,"address":[42509518],"length":1,"stats":{"Line":1}},{"line":1016,"address":[42509701,42509451],"length":1,"stats":{"Line":2}},{"line":1017,"address":[42509808,42509718],"length":1,"stats":{"Line":2}},{"line":1019,"address":[42509829,42509761],"length":1,"stats":{"Line":2}},{"line":1020,"address":[42509866,42509998],"length":1,"stats":{"Line":2}},{"line":1022,"address":[42510175,42509909],"length":1,"stats":{"Line":2}},{"line":1023,"address":[42510212],"length":1,"stats":{"Line":1}},{"line":1024,"address":[42510344],"length":1,"stats":{"Line":1}},{"line":1026,"address":[42510255,42510521],"length":1,"stats":{"Line":2}},{"line":1027,"address":[42510558],"length":1,"stats":{"Line":1}},{"line":1028,"address":[42510690],"length":1,"stats":{"Line":1}},{"line":1030,"address":[42510601,42510867],"length":1,"stats":{"Line":2}},{"line":1031,"address":[42510904],"length":1,"stats":{"Line":1}},{"line":1032,"address":[42511036],"length":1,"stats":{"Line":1}},{"line":1034,"address":[42511213,42510947],"length":1,"stats":{"Line":2}},{"line":1035,"address":[42511250],"length":1,"stats":{"Line":1}},{"line":1036,"address":[42511372],"length":1,"stats":{"Line":1}},{"line":1038,"address":[42511293,42511549],"length":1,"stats":{"Line":2}},{"line":1039,"address":[42511653,42511577],"length":1,"stats":{"Line":2}},{"line":1041,"address":[42511708,42511620],"length":1,"stats":{"Line":2}},{"line":1042,"address":[42511812,42511736],"length":1,"stats":{"Line":2}},{"line":1044,"address":[42511779,42511867],"length":1,"stats":{"Line":2}},{"line":1045,"address":[42511971,42511895],"length":1,"stats":{"Line":2}},{"line":1047,"address":[42512026,42511938],"length":1,"stats":{"Line":2}},{"line":1048,"address":[42512143,42512054],"length":1,"stats":{"Line":2}},{"line":1050,"address":[42512097,42512198],"length":1,"stats":{"Line":2}},{"line":1051,"address":[42512235],"length":1,"stats":{"Line":1}},{"line":1052,"address":[42512360],"length":1,"stats":{"Line":1}},{"line":1054,"address":[42512278],"length":1,"stats":{"Line":1}},{"line":1055,"address":[42512534],"length":1,"stats":{"Line":1}},{"line":1056,"address":[42513134],"length":1,"stats":{"Line":1}},{"line":1057,"address":[38918183],"length":1,"stats":{"Line":2}},{"line":1095,"address":[41933104],"length":1,"stats":{"Line":1}},{"line":1100,"address":[42514481,42515449,42514410,42515247,42515036,42515204,42514545,42515723,42515614,42516003,42515981,42515781,42515547],"length":1,"stats":{"Line":5}},{"line":1112,"address":[42515104],"length":1,"stats":{"Line":1}},{"line":1113,"address":[38927728],"length":1,"stats":{"Line":4}},{"line":1114,"address":[42515582,42515524],"length":1,"stats":{"Line":1}},{"line":1115,"address":[38927821,38927775],"length":1,"stats":{"Line":1}},{"line":1116,"address":[42515830],"length":1,"stats":{"Line":1}},{"line":1131,"address":[41887815,41886688,41887840],"length":1,"stats":{"Line":1}},{"line":1132,"address":[41887762,41887107,41887432,41887030,41886896,41887643,41887164,41887375,41887566,41887241,41886695,41887298,41887509,41886836,41886973,41887700],"length":1,"stats":{"Line":16}},{"line":1133,"address":[41886852,41886795,41886901,41887926,41886788],"length":1,"stats":{"Line":3}},{"line":1134,"address":[41886925,41887035,41886932,41886986,41887911],"length":1,"stats":{"Line":3}},{"line":1135,"address":[41887059,41887899,41887169,41887120,41887066],"length":1,"stats":{"Line":3}},{"line":1136,"address":[41887254,41887303,41887193,41887200,41887887],"length":1,"stats":{"Line":3}},{"line":1137,"address":[41887437,41887875,41887388,41887327,41887334],"length":1,"stats":{"Line":3}},{"line":1138,"address":[41887571,41887461,41887522,41887468,41887863],"length":1,"stats":{"Line":3}},{"line":1139,"address":[41887656,41887705,41887602,41887851,41887595],"length":1,"stats":{"Line":3}},{"line":1140,"address":[41887775,41887721,41887728,41887833],"length":1,"stats":{"Line":2}}],"covered":214,"coverable":241},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","controllers","mod.rs"],"content":"pub mod account;\npub mod chat;\npub mod itinerary;\n\n/// A regular [axum::Router] in test and release builds, or [utoipa_axum::router::OpenApiRouter] in non-test or dev builds\n#[cfg(any(test, not(debug_assertions)))]\npub type AxumRouter = axum::Router;\n/// A regular [axum::Router] in test and release builds, or [utoipa_axum::router::OpenApiRouter] in non-test or dev builds\n#[cfg(all(not(test), debug_assertions))]\npub type AxumRouter = utoipa_axum::router::OpenApiRouter;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","db.rs"],"content":"// src/db/pool.rs\nuse sqlx::{PgPool, postgres::PgPoolOptions};\nuse std::env;\n// Pgpool- A pool of PostgreSQL connections\n// PgPoolOptions - The \"configuration options\" for creating a pool (the max number of connections).\n\npub async fn create_pool() -\u003e PgPool {\n\t// Retrieve the database URL from an environment variable\n\tlet database_url = env::var(\"DATABASE_URL\")\n\t\t//\"Panic\" if no url is found\n\t\t.expect(\"DATABASE_URL must be set in .env or environment\");\n\n\t// Creates a connection pool with up to 5 connections\n\tPgPoolOptions::new()\n\t\t.max_connections(5)\n\t\t.connect(\u0026database_url)\n\t\t.await\n\t\t.expect(\"Failed to create database pool\")\n}\n","traces":[{"line":7,"address":[37750448,37750451],"length":1,"stats":{"Line":5}},{"line":9,"address":[40945616],"length":1,"stats":{"Line":1}},{"line":14,"address":[40945775,40946313,40945942,40946055],"length":1,"stats":{"Line":4}},{"line":16,"address":[40946099,40945794,40945950,40945891,40945874],"length":1,"stats":{"Line":2}},{"line":17,"address":[39080759],"length":1,"stats":{"Line":4}}],"covered":5,"coverable":5},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","error.rs"],"content":"use axum::http::StatusCode;\nuse axum::response::{IntoResponse, Response};\nuse std::fmt;\nuse tracing::error;\n\n// Unified API result type\n#[cfg(not(tarpaulin_include))]\npub type ApiResult\u003cT\u003e = std::result::Result\u003cT, AppError\u003e;\n\n// Single unified error for the API\n#[derive(Debug)]\n#[cfg(not(tarpaulin_include))]\npub enum AppError {\n\tValidation(String),\n\tBadRequest(String),\n\tUnauthorized,\n\tNotFound,\n\tConflict(String),\n\tInternal(String),\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl AppError {\n\tpub fn status_code(\u0026self) -\u003e StatusCode {\n\t\tmatch self {\n\t\t\tAppError::Validation(_) =\u003e StatusCode::BAD_REQUEST,\n\t\t\tAppError::BadRequest(_) =\u003e StatusCode::BAD_REQUEST,\n\t\t\tAppError::Unauthorized =\u003e StatusCode::UNAUTHORIZED,\n\t\t\tAppError::NotFound =\u003e StatusCode::NOT_FOUND,\n\t\t\tAppError::Conflict(_) =\u003e StatusCode::CONFLICT,\n\t\t\tAppError::Internal(_) =\u003e StatusCode::INTERNAL_SERVER_ERROR,\n\t\t}\n\t}\n\n\tpub fn log(\u0026self) {\n\t\tmatch self {\n\t\t\tAppError::Validation(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"validation\", message = %m)\n\t\t\t}\n\t\t\tAppError::BadRequest(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"bad_request\", message = %m)\n\t\t\t}\n\t\t\tAppError::Unauthorized =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"unauthorized\")\n\t\t\t}\n\t\t\tAppError::NotFound =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"not_found\")\n\t\t\t}\n\t\t\tAppError::Conflict(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"conflict\", message = %m)\n\t\t\t}\n\t\t\tAppError::Internal(m) =\u003e {\n\t\t\t\terror!(target: \"api_error\", prefix = \"ERROR -\u003e\u003e\", kind = \"internal\", message = %m)\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl fmt::Display for AppError {\n\tfn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tAppError::Validation(m) =\u003e write!(f, \"validation error: {m}\"),\n\t\t\tAppError::BadRequest(m) =\u003e write!(f, \"bad request: {m}\"),\n\t\t\tAppError::Unauthorized =\u003e write!(f, \"unauthorized\"),\n\t\t\tAppError::NotFound =\u003e write!(f, \"not found\"),\n\t\t\tAppError::Conflict(m) =\u003e write!(f, \"conflict: {m}\"),\n\t\t\tAppError::Internal(m) =\u003e write!(f, \"internal error: {m}\"),\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl std::error::Error for AppError {}\n\n// Convert common error types into unified Internal errors\n#[cfg(not(tarpaulin_include))]\nimpl From\u003csqlx::Error\u003e for AppError {\n\tfn from(e: sqlx::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"db error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cargon2::password_hash::Error\u003e for AppError {\n\tfn from(e: argon2::password_hash::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"password hash error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cserde_json::Error\u003e for AppError {\n\tfn from(e: serde_json::Error) -\u003e Self {\n\t\tAppError::Internal(format!(\"json error: {e:?}\"))\n\t}\n}\n#[cfg(not(tarpaulin_include))]\nimpl From\u003cstd::env::VarError\u003e for AppError {\n\tfn from(e: std::env::VarError) -\u003e Self {\n\t\tAppError::Internal(format!(\"env error: {e:?}\"))\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl IntoResponse for AppError {\n\tfn into_response(self) -\u003e Response {\n\t\t// Always log; return only status code\n\t\tself.log();\n\t\tself.status_code().into_response()\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","global.rs"],"content":"pub const LOG_DIR: \u0026str = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/logs\");\npub const CRASH_LOG: \u0026str = \"crash.log\";\npub const LATEST_LOG: \u0026str = \"latest.log\";\npub const TOOLS_LOG: \u0026str = \"tools.log\";\npub const DIST_DIR: \u0026str = \"frontend/dist\";\npub const MESSAGE_PAGE_LEN: i32 = 10;\npub const EVENT_SEARCH_RESULT_LEN: i32 = 10;\npub const GOOGLE_MAPS_API_KEY: \u0026str = \"GOOGLE_MAPS_PRIVATE_API_KEY\";\n\n#[cfg(test)]\npub const TEST_COOKIE_EXP_SECONDS: i64 = 60;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","account.rs"],"content":"/*\n * src/models/account.rs\n *\n * File for Account table models and related payload/response types\n *\n * Purpose:\n *   Strongly-typed models for the `accounts` table\n */\n\nuse crate::sql_models::{BudgetBucket, RiskTolerence};\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\n/// Request payload for POST `/api/account/login`.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct LoginRequest {\n\t/// Account email\n\tpub email: String,\n\t/// Plaintext password submitted by the user\n\tpub password: String,\n}\n\n/// Request payload for POST `/api/account/signup`.\n/// Validated server-side before insert.\n#[derive(Debug, Deserialize, Clone, ToSchema)]\npub struct SignupRequest {\n\t/// Account email\n\tpub email: String,\n\tpub first_name: String,\n\tpub last_name: String,\n\t/// Plaintext password submitted by the user\n\tpub password: String,\n}\n\n/// Request payload for POST `/api/account/update`.\n/// - Only `Some` fields are updated.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UpdateRequest {\n\t/// Optional new email\n\tpub email: Option\u003cString\u003e,\n\t/// Optional new first name\n\tpub first_name: Option\u003cString\u003e,\n\t/// Optional new last name\n\tpub last_name: Option\u003cString\u003e,\n\t/// Optional new plaintext password\n\tpub password: Option\u003cString\u003e,\n\t/// Current password (required if password is being updated)\n\tpub current_password: Option\u003cString\u003e,\n\t/// Optional new budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional new risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional new food and allergies preferences\n\t/// * String is a comma-separated list of preferences\n\tpub food_allergies: Option\u003cString\u003e,\n\t/// Optional new disabilites\n\t/// * String is a comma-separated list of preferences\n\tpub disabilities: Option\u003cString\u003e,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\n/// API route response for POST `/api/account/update`.\n/// - Contains full updated account profile for convenience.\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct UpdateResponse {\n\t/// Current email\n\tpub email: String,\n\t/// Current first name\n\tpub first_name: String,\n\t/// Current last name\n\tpub last_name: String,\n\t/// Optional budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional food and allergies preferences\n\t/// * String is a comma-separated list of preferences\n\tpub food_allergies: String,\n\t/// Optional disabilites\n\t/// * String is a comma-separated list of preferences\n\tpub disabilities: String,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\n/// API route response for GET `/api/account/current`.\n/// - Safe-to-return account profile for current user\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct CurrentResponse {\n\t/// Email\n\tpub email: String,\n\t/// First name\n\tpub first_name: String,\n\t/// Last name\n\tpub last_name: String,\n\t/// Optional budget enum\n\tpub budget_preference: Option\u003cBudgetBucket\u003e,\n\t/// Optional risk enum\n\tpub risk_preference: Option\u003cRiskTolerence\u003e,\n\t/// Optional food and allergies preferences\n\t/// should this have option encoded...\n\tpub food_allergies: String,\n\t/// Optional food and allergies preferences\n\t/// should this have option encoded...\n\tpub disabilities: String,\n\t/// Optional new profile pic\n\tpub profile_picture: Option\u003cString\u003e,\n}\n\nimpl SignupRequest {\n\t/// Validate email format using regex.\n\t/// Validate email format using regex\n\tpub fn validate_email(email: \u0026str) -\u003e bool {\n\t\tlet email_regex = Regex::new(r\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\").unwrap();\n\t\temail_regex.is_match(email)\n\t}\n\n\t/// Validate password strength\n\t/// - Minimum 8 characters\n\t/// - Maximum 128 characters\n\t/// - At least one uppercase letter\n\t/// - At least one lowercase letter\n\t/// - At least one number\n\t/// - Only ASCII characters allowed (for security and compatibility)\n\tpub fn validate_password(password: \u0026str) -\u003e Result\u003c(), String\u003e {\n\t\tif password.len() \u003c 8 {\n\t\t\treturn Err(\"Password must be at least 8 characters long\".to_string());\n\t\t}\n\n\t\tif password.len() \u003e 128 {\n\t\t\treturn Err(\"Password must be 128 characters or less\".to_string());\n\t\t}\n\n\t\t// Only allow ASCII characters (prevents potential encoding issues)\n\t\tif !password.is_ascii() {\n\t\t\treturn Err(\"Password must contain only ASCII characters\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_uppercase()) {\n\t\t\treturn Err(\"Password must contain at least one uppercase letter\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_lowercase()) {\n\t\t\treturn Err(\"Password must contain at least one lowercase letter\".to_string());\n\t\t}\n\n\t\tif !password.chars().any(|c| c.is_numeric()) {\n\t\t\treturn Err(\"Password must contain at least one number\".to_string());\n\t\t}\n\n\t\tOk(())\n\t}\n\n\t/// Validate the entire signup payload\n\tpub fn validate(\u0026self) -\u003e Result\u003c(), String\u003e {\n\t\t// Validate email (trim before checking)\n\t\tlet email_trimmed = self.email.trim();\n\t\tif email_trimmed.is_empty() {\n\t\t\treturn Err(\"Email is required\".to_string());\n\t\t}\n\n\t\tif !Self::validate_email(email_trimmed) {\n\t\t\treturn Err(\"Invalid email format\".to_string());\n\t\t}\n\n\t\t// Validate first name (trim before checking)\n\t\tlet first_name_trimmed = self.first_name.trim();\n\t\tif first_name_trimmed.is_empty() {\n\t\t\treturn Err(\"First name is required\".to_string());\n\t\t}\n\n\t\tif first_name_trimmed.len() \u003e 50 {\n\t\t\treturn Err(\"First name must be 50 characters or less\".to_string());\n\t\t}\n\n\t\t// Validate last name (trim before checking)\n\t\tlet last_name_trimmed = self.last_name.trim();\n\t\tif last_name_trimmed.is_empty() {\n\t\t\treturn Err(\"Last name is required\".to_string());\n\t\t}\n\n\t\tif last_name_trimmed.len() \u003e 50 {\n\t\t\treturn Err(\"Last name must be 50 characters or less\".to_string());\n\t\t}\n\n\t\t// Validate password\n\t\tSelf::validate_password(\u0026self.password)?;\n\n\t\tOk(())\n\t}\n}\n","traces":[{"line":115,"address":[40877536,40877709,40877715],"length":1,"stats":{"Line":1}},{"line":116,"address":[40877563],"length":1,"stats":{"Line":1}},{"line":117,"address":[40877638],"length":1,"stats":{"Line":1}},{"line":127,"address":[40877728],"length":1,"stats":{"Line":1}},{"line":128,"address":[40877787],"length":1,"stats":{"Line":1}},{"line":129,"address":[40877823],"length":1,"stats":{"Line":1}},{"line":132,"address":[40877808],"length":1,"stats":{"Line":1}},{"line":133,"address":[40877903],"length":1,"stats":{"Line":1}},{"line":137,"address":[40877892],"length":1,"stats":{"Line":1}},{"line":138,"address":[40877959],"length":1,"stats":{"Line":1}},{"line":141,"address":[37367288,37367264],"length":1,"stats":{"Line":3}},{"line":142,"address":[40878069],"length":1,"stats":{"Line":1}},{"line":145,"address":[37367312,37367336],"length":1,"stats":{"Line":3}},{"line":146,"address":[40878185],"length":1,"stats":{"Line":1}},{"line":149,"address":[37367384,37367360],"length":1,"stats":{"Line":3}},{"line":150,"address":[40878304],"length":1,"stats":{"Line":1}},{"line":153,"address":[40878380],"length":1,"stats":{"Line":1}},{"line":157,"address":[40878400],"length":1,"stats":{"Line":1}},{"line":159,"address":[40878438],"length":1,"stats":{"Line":1}},{"line":160,"address":[40878486],"length":1,"stats":{"Line":1}},{"line":161,"address":[40878516],"length":1,"stats":{"Line":1}},{"line":164,"address":[40878505],"length":1,"stats":{"Line":1}},{"line":165,"address":[40878572],"length":1,"stats":{"Line":1}},{"line":169,"address":[40878633],"length":1,"stats":{"Line":1}},{"line":170,"address":[40878685],"length":1,"stats":{"Line":1}},{"line":171,"address":[40878736],"length":1,"stats":{"Line":1}},{"line":174,"address":[40878719],"length":1,"stats":{"Line":1}},{"line":175,"address":[40878872],"length":1,"stats":{"Line":1}},{"line":179,"address":[40878809],"length":1,"stats":{"Line":1}},{"line":180,"address":[40878861],"length":1,"stats":{"Line":1}},{"line":181,"address":[40878970],"length":1,"stats":{"Line":1}},{"line":184,"address":[40878953],"length":1,"stats":{"Line":1}},{"line":185,"address":[40879135],"length":1,"stats":{"Line":1}},{"line":189,"address":[40879046,40879211],"length":1,"stats":{"Line":2}},{"line":191,"address":[40879290],"length":1,"stats":{"Line":1}}],"covered":35,"coverable":35},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","chat_session.rs"],"content":"use serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::sql_models::{LlmProgress, message::ChatSessionRow};\n\n/// Response model from the `/api/chat/chats` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct ChatsResponse {\n\t/// chat session ids belonging to the user who made the request\n\tpub chat_sessions: Vec\u003cChatSessionRow\u003e,\n}\n\n/// Response model from the `/api/chat/newChat` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct NewChatResponse {\n\t/// this chat session is guaranteed to not have any messages in it\n\tpub chat_session_id: i32,\n}\n\n/// Request model for the `/api/chat/rename` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct RenameRequest {\n\tpub new_title: String,\n\tpub id: i32,\n}\n\n/// Request model for the `/api/chat/progress` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct ProgressRequest {\n\tpub chat_session_id: i32,\n}\n\n/// Response model from the `/api/chat/progress` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct ProgressResponse {\n\tpub progress: LlmProgress,\n\tpub title: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","event.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse google_maps::places_new::Place;\nuse num_traits::ToPrimitive;\nuse once_cell::sync::Lazy;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::sql_models::{Period, event_list::EventListJoinRow};\n\n/// A single event without context from an itinerary\n#[derive(Debug, Clone, Serialize, Deserialize, FromRow, ToSchema, Default)]\npub struct Event {\n\t/// Primary key\n\tpub id: i32,\n\tpub event_name: String,\n\tpub event_description: Option\u003cString\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub user_created: bool,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub place_id: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub website_uri: Option\u003cString\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n\tpub photo_width: Option\u003ci32\u003e,\n\tpub photo_height: Option\u003ci32\u003e,\n\tpub photo_author: Option\u003cString\u003e,\n\tpub photo_author_uri: Option\u003cString\u003e,\n\tpub photo_author_photo_uri: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n\nimpl From\u003c\u0026EventListJoinRow\u003e for Event {\n\t#[cfg(not(tarpaulin_include))]\n\tfn from(value: \u0026EventListJoinRow) -\u003e Self {\n\t\tSelf {\n\t\t\tid: value.id,\n\t\t\tevent_name: value.event_name.clone(),\n\t\t\tevent_description: value.event_description.clone(),\n\t\t\tstreet_address: value.street_address.clone(),\n\t\t\tcity: value.city.clone(),\n\t\t\tcountry: value.country.clone(),\n\t\t\tpostal_code: value.postal_code,\n\t\t\tlat: value.lat.clone(),\n\t\t\tlng: value.lng.clone(),\n\t\t\tevent_type: value.event_type.clone(),\n\t\t\tuser_created: value.user_created.clone(),\n\t\t\thard_start: value.hard_start.clone(),\n\t\t\thard_end: value.hard_end.clone(),\n\t\t\ttimezone: value.timezone.clone(),\n\t\t\tplace_id: value.place_id.clone(),\n\t\t\twheelchair_accessible_parking: value.wheelchair_accessible_parking.clone(),\n\t\t\twheelchair_accessible_entrance: value.wheelchair_accessible_entrance.clone(),\n\t\t\twheelchair_accessible_restroom: value.wheelchair_accessible_restroom.clone(),\n\t\t\twheelchair_accessible_seating: value.wheelchair_accessible_seating.clone(),\n\t\t\tserves_vegetarian_food: value.serves_vegetarian_food.clone(),\n\t\t\tprice_level: value.price_level.clone(),\n\t\t\tutc_offset_minutes: value.utc_offset_minutes.clone(),\n\t\t\twebsite_uri: value.website_uri.clone(),\n\t\t\ttypes: value.types.clone(),\n\t\t\tphoto_name: value.photo_name.clone(),\n\t\t\tphoto_width: value.photo_width.clone(),\n\t\t\tphoto_height: value.photo_height.clone(),\n\t\t\tphoto_author: value.photo_author.clone(),\n\t\t\tphoto_author_uri: value.photo_author_uri.clone(),\n\t\t\tphoto_author_photo_uri: value.photo_author_photo_uri.clone(),\n\t\t\tweekday_descriptions: value.weekday_descriptions.clone(),\n\t\t\tsecondary_hours_type: value.secondary_hours_type.clone(),\n\t\t\tnext_open_time: value.next_open_time.clone(),\n\t\t\tnext_close_time: value.next_close_time.clone(),\n\t\t\topen_now: value.open_now.clone(),\n\t\t\tperiods: value.periods.clone(),\n\t\t\tspecial_days: value.special_days.clone(),\n\t\t\tblock_index: value.block_index,\n\t\t}\n\t}\n}\n\n#[cfg(not(tarpaulin_include))]\npub static REGEX_ST_ADDR: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"street-address\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_LOCALITY: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"locality\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_COUNTRY: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"country-name\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n#[cfg(not(tarpaulin_include))]\npub static REGEX_POST_CODE: Lazy\u003cRegex\u003e =\n\tLazy::new(|| Regex::new(r#\"\u003cspan\\s+class=\"postal-code\"\\s*\u003e([^\u003c]*)\u003c/span\u003e\"#).unwrap());\n\n#[cfg(not(tarpaulin_include))]\nimpl From\u003c\u0026Place\u003e for Event {\n\tfn from(value: \u0026Place) -\u003e Self {\n\t\t#[inline]\n\t\tfn extract(input: \u0026str, re: \u0026Regex) -\u003e Option\u003cString\u003e {\n\t\t\tre.captures(input)\n\t\t\t\t.and_then(|caps| caps.get(1))\n\t\t\t\t.map(|m| m.as_str().to_string())\n\t\t}\n\t\tlet empty = String::new();\n\t\tlet input = value.adr_format_address.as_ref().unwrap_or(\u0026empty).as_str();\n\t\tlet street_address = extract(input, \u0026REGEX_ST_ADDR);\n\t\tlet city = extract(input, \u0026REGEX_LOCALITY);\n\t\tlet country = extract(input, \u0026REGEX_COUNTRY);\n\t\tlet postal_code = extract(input, \u0026REGEX_POST_CODE)\n\t\t\t.map(|p| p.parse().ok())\n\t\t\t.unwrap_or(None);\n\t\tSelf {\n\t\t\tid: -1,\n\t\t\tevent_name: value\n\t\t\t\t.display_name\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|n| n.to_string())\n\t\t\t\t.unwrap_or(\"Unnamed Event\".to_string()),\n\t\t\tevent_description: value.editorial_summary.as_ref().map(|n| n.to_string()),\n\t\t\tstreet_address,\n\t\t\tcity,\n\t\t\tcountry,\n\t\t\tpostal_code,\n\t\t\tlat: value.location.map(|l| l.latitude.to_f64()).unwrap_or(None),\n\t\t\tlng: value.location.map(|l| l.longitude.to_f64()).unwrap_or(None),\n\t\t\tevent_type: value.primary_type.map(|t| t.to_string()),\n\t\t\tuser_created: false,\n\t\t\thard_start: None,\n\t\t\thard_end: None,\n\t\t\ttimezone: None,\n\t\t\tplace_id: value.id.clone(),\n\t\t\twheelchair_accessible_parking: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_parking)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_entrance: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_entrance)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_restroom: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_restroom)\n\t\t\t\t.unwrap_or(None),\n\t\t\twheelchair_accessible_seating: value\n\t\t\t\t.accessibility_options\n\t\t\t\t.map(|a| a.wheelchair_accessible_seating)\n\t\t\t\t.unwrap_or(None),\n\t\t\tserves_vegetarian_food: value.serves_vegetarian_food,\n\t\t\tprice_level: value.price_level.map(|p| p as i32),\n\t\t\tutc_offset_minutes: value.utc_offset_minutes,\n\t\t\twebsite_uri: value.website_uri.as_ref().map(|w| w.to_string()),\n\t\t\ttypes: Some(\n\t\t\t\tvalue\n\t\t\t\t\t.types\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|t| t.to_string())\n\t\t\t\t\t.collect::\u003cVec\u003c_\u003e\u003e()\n\t\t\t\t\t.join(\",\"),\n\t\t\t),\n\t\t\tphoto_name: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].name.clone())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_width: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].width_px as i32)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_height: if value.has_photos() {\n\t\t\t\tSome(value.photos[0].height_px as i32)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author: if value.has_photos() \u0026\u0026 !value.photos[0].author_attributions.is_empty() {\n\t\t\t\tvalue.photos[0].author_attributions[0].display_name.clone()\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author_uri: if value.has_photos()\n\t\t\t\t\u0026\u0026 !value.photos[0].author_attributions.is_empty()\n\t\t\t{\n\t\t\t\tvalue.photos[0].author_attributions[0]\n\t\t\t\t\t.uri\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map(|u| u.to_string())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tphoto_author_photo_uri: if value.has_photos()\n\t\t\t\t\u0026\u0026 !value.photos[0].author_attributions.is_empty()\n\t\t\t{\n\t\t\t\tvalue.photos[0].author_attributions[0]\n\t\t\t\t\t.photo_uri\n\t\t\t\t\t.as_ref()\n\t\t\t\t\t.map(|u| u.to_string())\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t},\n\t\t\tweekday_descriptions: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.weekday_descriptions.join(\"\\n\")),\n\t\t\tsecondary_hours_type: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.secondary_hours_type.map(|s| s as i32))\n\t\t\t\t.unwrap_or(None),\n\t\t\tnext_open_time: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.next_open_time.map(|t| {\n\t\t\t\t\t\tchrono::DateTime::parse_from_rfc3339(t.to_string().as_str())\n\t\t\t\t\t\t\t.map(|d| d.naive_utc())\n\t\t\t\t\t\t\t.ok()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(None),\n\t\t\tnext_close_time: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.next_close_time.map(|t| {\n\t\t\t\t\t\tchrono::DateTime::parse_from_rfc3339(t.to_string().as_str())\n\t\t\t\t\t\t\t.map(|d| d.naive_utc())\n\t\t\t\t\t\t\t.ok()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(None),\n\t\t\topen_now: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| r.open_now)\n\t\t\t\t.unwrap_or(None),\n\t\t\tperiods: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.periods\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|p| Period {\n\t\t\t\t\t\t\topen_date: p\n\t\t\t\t\t\t\t\t.open\n\t\t\t\t\t\t\t\t.date\n\t\t\t\t\t\t\t\t.map(|d| {\n\t\t\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\t\t\td.year() as i32,\n\t\t\t\t\t\t\t\t\t\td.month() as u32,\n\t\t\t\t\t\t\t\t\t\td.day() as u32,\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.unwrap_or(None),\n\t\t\t\t\t\t\topen_truncated: p.open.truncated,\n\t\t\t\t\t\t\topen_day: p.open.day as i32,\n\t\t\t\t\t\t\topen_hour: p.open.hour,\n\t\t\t\t\t\t\topen_minute: p.open.minute,\n\t\t\t\t\t\t\tclose_date: p\n\t\t\t\t\t\t\t\t.close\n\t\t\t\t\t\t\t\t.as_ref()\n\t\t\t\t\t\t\t\t.map(|p| {\n\t\t\t\t\t\t\t\t\tp.date.map(|d| {\n\t\t\t\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\t\t\t\td.year() as i32,\n\t\t\t\t\t\t\t\t\t\t\td.month() as u32,\n\t\t\t\t\t\t\t\t\t\t\td.day() as u32,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.unwrap_or(None)\n\t\t\t\t\t\t\t\t.unwrap_or(None),\n\t\t\t\t\t\t\tclose_truncated: p.close.as_ref().map(|p| p.truncated).unwrap_or(None),\n\t\t\t\t\t\t\tclose_day: p.close.as_ref().map(|p| p.day as i32),\n\t\t\t\t\t\t\tclose_hour: p.close.as_ref().map(|p| p.hour),\n\t\t\t\t\t\t\tclose_minute: p.close.as_ref().map(|p| p.minute),\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect()\n\t\t\t\t})\n\t\t\t\t.unwrap_or(Vec::new()),\n\t\t\tspecial_days: value\n\t\t\t\t.regular_opening_hours\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|r| {\n\t\t\t\t\tr.special_days\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|d| {\n\t\t\t\t\t\t\tNaiveDate::from_ymd_opt(\n\t\t\t\t\t\t\t\td.year()? as i32,\n\t\t\t\t\t\t\t\td.month()? as u32,\n\t\t\t\t\t\t\t\td.day()? as u32,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.collect::\u003cOption\u003cVec\u003c_\u003e\u003e\u003e()\n\t\t\t\t})\n\t\t\t\t.unwrap_or(None)\n\t\t\t\t.unwrap_or(Vec::new()),\n\t\t\tblock_index: None,\n\t\t}\n\t}\n}\n\n/// A user-created event. It must have a name, and all other fields are optional.\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UserEventRequest {\n\t/// If id is provided, it updates the user-event with that id. Otherwise it creates the event.\n\tpub id: Option\u003ci32\u003e,\n\tpub street_address: Option\u003cString\u003e,\n\tpub postal_code: Option\u003ci32\u003e,\n\tpub city: Option\u003cString\u003e,\n\tpub country: Option\u003cString\u003e,\n\tpub event_type: Option\u003cString\u003e,\n\tpub event_description: Option\u003cString\u003e,\n\tpub event_name: String,\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct UserEventResponse {\n\tpub id: i32,\n}\n\n/// A set of query filters to search for an event in the DB.\n///\n/// ## Example\n/// If event_name is provided, it will query the DB with something like this:\n/// ```sql\n/// SELECT * FROM events\n/// WHERE name LIKE $1\n/// LIMIT 10;\n/// ```\n#[derive(Debug, Deserialize, ToSchema, Default, Clone)]\npub struct SearchEventRequest {\n\t/// Search where id=...\n\tpub id: Option\u003ci32\u003e,\n\t/// Search where street_address like ...\n\tpub street_address: Option\u003cString\u003e,\n\t/// Search where postal_code=...\n\tpub postal_code: Option\u003ci32\u003e,\n\t/// Search where city like ...\n\tpub city: Option\u003cString\u003e,\n\t/// Search where countr like ...\n\tpub country: Option\u003cString\u003e,\n\t/// Search where event_type like ...\n\tpub event_type: Option\u003cString\u003e,\n\t/// Search where event_description like ...\n\tpub event_description: Option\u003cString\u003e,\n\t/// Search where event_name like ...\n\tpub event_name: Option\u003cString\u003e,\n\t/// Search where hard_start \u003c ...\n\tpub hard_start_before: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_start \u003e ...\n\tpub hard_start_after: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_end \u003c ...\n\tpub hard_end_before: Option\u003cNaiveDateTime\u003e,\n\t/// Search where hard_end \u003e ...\n\tpub hard_end_after: Option\u003cNaiveDateTime\u003e,\n\t/// Search where timezone like ...\n\tpub timezone: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SearchEventResponse {\n\tpub events: Vec\u003cEvent\u003e,\n}\n","traces":[{"line":105,"address":[37408752,37408770],"length":1,"stats":{"Line":0}},{"line":107,"address":[37408832,37408850],"length":1,"stats":{"Line":0}},{"line":109,"address":[37408912,37408930],"length":1,"stats":{"Line":0}},{"line":111,"address":[37408992,37409010],"length":1,"stats":{"Line":0}},{"line":114,"address":[42530812,42524160,42530460],"length":1,"stats":{"Line":0}},{"line":116,"address":[42530832],"length":1,"stats":{"Line":0}},{"line":117,"address":[42530887],"length":1,"stats":{"Line":0}},{"line":118,"address":[42530897],"length":1,"stats":{"Line":0}},{"line":119,"address":[37409168,37409195],"length":1,"stats":{"Line":0}},{"line":121,"address":[42524209],"length":1,"stats":{"Line":0}},{"line":122,"address":[42524428,42524350],"length":1,"stats":{"Line":0}},{"line":123,"address":[42524540],"length":1,"stats":{"Line":0}},{"line":124,"address":[42524613,42524712],"length":1,"stats":{"Line":0}},{"line":125,"address":[42524826,42524727],"length":1,"stats":{"Line":0}},{"line":126,"address":[42524940,42524841,42525035],"length":1,"stats":{"Line":0}},{"line":127,"address":[37409232,37409241],"length":1,"stats":{"Line":0}},{"line":128,"address":[42524992],"length":1,"stats":{"Line":0}},{"line":131,"address":[42525067,42525196],"length":1,"stats":{"Line":0}},{"line":136,"address":[37409472,37409456],"length":1,"stats":{"Line":0}},{"line":141,"address":[37409489,37409488],"length":1,"stats":{"Line":0}},{"line":142,"address":[37409504,37409505],"length":1,"stats":{"Line":0}},{"line":143,"address":[37409520,37409540],"length":1,"stats":{"Line":0}},{"line":148,"address":[42525963,42526038],"length":1,"stats":{"Line":0}},{"line":149,"address":[42526046],"length":1,"stats":{"Line":0}},{"line":153,"address":[42526169],"length":1,"stats":{"Line":0}},{"line":157,"address":[42526254],"length":1,"stats":{"Line":0}},{"line":161,"address":[42526339],"length":1,"stats":{"Line":0}},{"line":165,"address":[42526424],"length":1,"stats":{"Line":0}},{"line":166,"address":[37409696,37409703],"length":1,"stats":{"Line":0}},{"line":167,"address":[42526501],"length":1,"stats":{"Line":0}},{"line":168,"address":[37409728,37409712],"length":1,"stats":{"Line":0}},{"line":169,"address":[42526915],"length":1,"stats":{"Line":0}},{"line":177,"address":[42527016,42526947,42527040,42527194],"length":1,"stats":{"Line":0}},{"line":182,"address":[42527264,42527365,42527247,42527091],"length":1,"stats":{"Line":0}},{"line":187,"address":[42527391,42527315,42527492,42527374],"length":1,"stats":{"Line":0}},{"line":192,"address":[42527501,42527525,42527442],"length":1,"stats":{"Line":0}},{"line":197,"address":[42527823,42527730,42527799],"length":1,"stats":{"Line":0}},{"line":207,"address":[42528124,42528148,42528055],"length":1,"stats":{"Line":0}},{"line":217,"address":[42528356],"length":1,"stats":{"Line":0}},{"line":221,"address":[42528444],"length":1,"stats":{"Line":0}},{"line":226,"address":[42528570],"length":1,"stats":{"Line":0}},{"line":238,"address":[42528698],"length":1,"stats":{"Line":0}},{"line":250,"address":[42528826],"length":1,"stats":{"Line":0}},{"line":255,"address":[42528889,42528989],"length":1,"stats":{"Line":0}},{"line":299,"address":[42529044,42529237],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":45},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","itinerary.rs"],"content":"/*\n * src/models/itinerary.rs\n *\n * File for Itinerary table models and related responses\n *\n * Purpose:\n *   Strongly-typed models for the `itineraries` response DTOs\n *   used by itinerary routes.\n */\n\nuse chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\nuse crate::http_models::event::Event;\n\n/// A complete itinerary with event details\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct Itinerary {\n\t/// Primary key\n\tpub id: i32,\n\t/// UTC date that the first event may take place (%Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// UTC date that the last event may take place (%Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// List of days containing events for that day\n\t/// * Days are guaranteed to be sorted in chronological order\n\tpub event_days: Vec\u003cEventDay\u003e,\n\t/// Possible associated chat session for easy editing on frontend\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Events that are not assigned to any specific time slot\n\tpub unassigned_events: Vec\u003cEvent\u003e,\n}\n\n/// A single day of events in an itinerary\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct EventDay {\n\t/// All the events taking place in the morning\n\tpub morning_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the afternoon\n\tpub afternoon_events: Vec\u003cEvent\u003e,\n\t/// All the events taking place in the evening\n\tpub evening_events: Vec\u003cEvent\u003e,\n\t/// The date of this day within the range of itinerary start and end dates (Destination's local timezone - %Y-%m-%d)\n\tpub date: NaiveDate,\n}\n\n/// API route response for GET `/api/itinerary/saved`\n#[derive(Debug, Serialize, Deserialize, ToSchema, ToResponse)]\npub struct SavedResponse {\n\t/// List of saved itineraries for the user.\n\tpub itineraries: Vec\u003cItinerary\u003e,\n}\n\n/// Response model from `/api/itinerary/save` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SaveResponse {\n\t/// id of the itinerary that was just saved\n\t/// * May be the same as the itinerary id passed in the request\n\tpub id: i32,\n}\n\n/// Request model from /api/itinerary/unsave\n#[derive(Debug, Deserialize, ToSchema)]\npub struct UnsaveRequest {\n\t/// itinerary id to unsave\n\tpub id: i32,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","message.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse utoipa::{ToResponse, ToSchema};\n\n/// A message in a chat session\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct Message {\n\t/// Primary key\n\tpub id: i32,\n\t/// Whether the message was sent by a user or generated by the LLM\n\tpub is_user: bool,\n\t/// UTC timestamp this message was sent (%Y-%m-%d %H:%M:%S)\n\tpub timestamp: NaiveDateTime,\n\t/// Content of this message\n\tpub text: String,\n\t/// Possible itinerary associated with this message\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/messagePage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct MessagePageRequest {\n\t/// chat session to fetch page from\n\tpub chat_session_id: i32,\n\t/// Possible message id to represent the end of the page\n\t/// * If Some, it will fetch this message and consecutive previous messages in chronological order\n\t/// * If None, it will fetch the latest consecutive messages from the chat session in chronological order\n\tpub message_id: Option\u003ci32\u003e,\n}\n\n/// Response model for `/api/chat/messagePage` endpoint\n#[derive(Serialize, ToSchema, ToResponse)]\npub struct MessagePageResponse {\n\t/// A page of messages guaranteed to be sorted in chronological order\n\tpub message_page: Vec\u003cMessage\u003e,\n\t/// The id of the message that comes chronologically before the first message in message_page, if it exists\n\tpub prev_message_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/updateMessage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct UpdateMessageRequest {\n\t/// ID of the message to update. This message must belong to a chat session which belongs to the user who made the request\n\tpub message_id: i32,\n\t/// The text to replace the old content with\n\tpub new_text: String,\n\t/// A possible itinerary to give context to the LLM\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Request model for `/api/chat/sendMessage` endpoint\n#[derive(Deserialize, ToSchema)]\npub struct SendMessageRequest {\n\t/// The chat session to send this message in. It must belong to the user making the request.\n\tpub chat_session_id: i32,\n\t/// The content of the message\n\tpub text: String,\n\t/// A possible itinerary to give context to the LLM\n\tpub itinerary_id: Option\u003ci32\u003e,\n}\n\n/// Response model for `/api/chat/sendMessage` endpoint\n#[derive(Debug, Serialize, ToSchema, ToResponse)]\npub struct SendMessageResponse {\n\t/// The newly-created id of the message you just sent\n\tpub user_message_id: i32,\n\t/// The response message from the LLM\n\tpub bot_message: Message,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","http_models","mod.rs"],"content":"pub mod account;\npub mod chat_session;\npub mod event;\npub mod itinerary;\npub mod message;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","log.rs"],"content":"use {\n\tcrate::global::*,\n\tstd::{\n\t\tfs::{self, File},\n\t\tio::{BufWriter, Write},\n\t\tpath::Path,\n\t\tsync::{Once, OnceLock},\n\t},\n\ttracing::error,\n\ttracing_appender::{non_blocking::NonBlocking, rolling},\n\ttracing_subscriber::{\n\t\tEnvFilter, Layer, fmt::time::SystemTime, layer::SubscriberExt, util::SubscriberInitExt,\n\t},\n};\n\nstatic INIT_LOG: Once = Once::new();\nstatic mut LOG_WRITER: OnceLock\u003cNonBlocking\u003e = OnceLock::new();\nstatic mut TOOLS_LOG_WRITER: OnceLock\u003cNonBlocking\u003e = OnceLock::new();\n\n/// When the program panics, the backtrace is outputted to `logs/crash.log`.\npub fn init_panic_handler() {\n\tunsafe {\n\t\t// Safety\n\t\t//\n\t\t// Always safe on Windows.\n\t\t//\n\t\t// Other platforms: risk of race condition in multi-threaded environment.\n\t\t// We are not reading/writing this environment variable from multiple threads, so we're good.\n\t\tstd::env::set_var(\"RUST_BACKTRACE\", \"full\");\n\t}\n\tstd::panic::set_hook(Box::new(move |panic_info| {\n\t\tconst WRITE_ERR: \u0026str = \"Could not write to crash log\";\n\t\terror!(\"{}\", panic_info);\n\t\tprintln!(\"{}\", panic_info);\n\n\t\tfs::create_dir_all(LOG_DIR).expect(\"Could create crash log\");\n\t\tlet file = File::create(Path::new(LOG_DIR).join(CRASH_LOG))\n\t\t\t.expect(\"Could not create crash log file\");\n\t\tlet backtrace = std::backtrace::Backtrace::capture();\n\t\tlet mut writer = BufWriter::new(file);\n\n\t\twriteln!(writer, \"Time: {}\", chrono::Local::now()).expect(WRITE_ERR);\n\t\twriteln!(writer, \"{panic_info}\").expect(WRITE_ERR);\n\t\twriteln!(writer, \"stack backtrace:\\n{backtrace}\").expect(WRITE_ERR);\n\t\twriteln!(writer, \"Process finished with exit code 101\").expect(WRITE_ERR);\n\t\twriter.flush().expect(WRITE_ERR);\n\t}));\n}\n\n/// Creates a tracing registry and adds a layer to it. Layer outputs to `logs/latest.log`.\n///\n/// See `.env` variable `RUST_LOG` for layer filter. These variables should be loaded into the environment for the filter to work.\n/// See [dotenvy].\npub fn init_logger() {\n\tINIT_LOG.call_once(|| {\n\t\t// Remove old logs\n\t\t_ = fs::remove_file(Path::new(LOG_DIR).join(LATEST_LOG));\n\t\t_ = fs::remove_file(Path::new(LOG_DIR).join(TOOLS_LOG));\n\n\t\t// Setup main log writer\n\t\tlet (log_writer, log_guard) =\n\t\t\ttracing_appender::non_blocking(rolling::never(LOG_DIR, LATEST_LOG));\n\t\tlet latest_log_layer = tracing_subscriber::fmt::layer()\n\t\t\t.with_timer(SystemTime)\n\t\t\t.with_ansi(false)\n\t\t\t.log_internal_errors(true)\n\t\t\t.with_target(true)\n\t\t\t.with_file(true)\n\t\t\t.with_line_number(true)\n\t\t\t.with_level(true)\n\t\t\t.with_thread_names(true)\n\t\t\t.with_thread_ids(true)\n\t\t\t.pretty()\n\t\t\t.with_writer(log_writer.clone())\n\t\t\t.with_filter(EnvFilter::from_default_env());\n\n\t\t// Setup tools log writer (only captures tool_trace target)\n\t\tlet (tools_log_writer, tools_guard) =\n\t\t\ttracing_appender::non_blocking(rolling::never(LOG_DIR, TOOLS_LOG));\n\t\tlet tools_log_layer = tracing_subscriber::fmt::layer()\n\t\t\t.with_timer(SystemTime)\n\t\t\t.with_ansi(false)\n\t\t\t.log_internal_errors(false)\n\t\t\t.with_target(false)\n\t\t\t.with_file(false)\n\t\t\t.with_line_number(false)\n\t\t\t.with_level(false)\n\t\t\t.with_thread_names(false)\n\t\t\t.with_thread_ids(false)\n\t\t\t.compact()\n\t\t\t.with_writer(tools_log_writer.clone())\n\t\t\t.with_filter(EnvFilter::new(\"tool_trace=info\"));\n\n\t\ttracing_subscriber::registry()\n\t\t\t.with(latest_log_layer)\n\t\t\t.with(tools_log_layer)\n\t\t\t.init();\n\n\t\t#[allow(static_mut_refs)]\n\t\tunsafe {\n\t\t\t_ = LOG_WRITER.set(log_writer);\n\t\t\t_ = TOOLS_LOG_WRITER.set(tools_log_writer);\n\t\t}\n\n\t\t// Guards have to have a static lifetime.\n\t\t// We can just let the OS clean it up for us when the process is killed.\n\t\tBox::leak(Box::new(log_guard));\n\t\tBox::leak(Box::new(tools_guard));\n\t})\n}\n\n#[allow(unused)]\npub fn log_writer() -\u003e \u0026'static mut NonBlocking {\n\t#[allow(static_mut_refs)]\n\tunsafe {\n\t\tLOG_WRITER.get_mut().expect(\"Logger not initialized\")\n\t}\n}\n\n/// Macro for logging tool calls to tools.log with a simple stack trace format\n/// Usage: tool_trace!(agent: \"orchestrator\", tool: \"route_task\", status: \"start\", details: \"task_type=research\")\n#[macro_export]\nmacro_rules! tool_trace {\n\t(agent: $agent:expr, tool: $tool:expr, status: $status:expr) =\u003e {\n\t\ttracing::info!(\n\t\t\ttarget: \"tool_trace\",\n\t\t\t\"[{}] {} | {}\",\n\t\t\t$agent,\n\t\t\t$tool,\n\t\t\t$status\n\t\t);\n\t};\n\t(agent: $agent:expr, tool: $tool:expr, status: $status:expr, details: $details:expr) =\u003e {\n\t\ttracing::info!(\n\t\t\ttarget: \"tool_trace\",\n\t\t\t\"[{}] {} | {} | {}\",\n\t\t\t$agent,\n\t\t\t$tool,\n\t\t\t$status,\n\t\t\t$details\n\t\t);\n\t};\n}\n","traces":[{"line":21,"address":[37405088],"length":1,"stats":{"Line":1}},{"line":29,"address":[37405089],"length":1,"stats":{"Line":1}},{"line":31,"address":[42088304,42090613,42090607],"length":1,"stats":{"Line":2}},{"line":33,"address":[42089240,42088327],"length":1,"stats":{"Line":1}},{"line":34,"address":[42088964],"length":1,"stats":{"Line":1}},{"line":36,"address":[42089036],"length":1,"stats":{"Line":1}},{"line":37,"address":[42089104],"length":1,"stats":{"Line":1}},{"line":38,"address":[42089179],"length":1,"stats":{"Line":1}},{"line":39,"address":[42089218],"length":1,"stats":{"Line":1}},{"line":40,"address":[42089880],"length":1,"stats":{"Line":1}},{"line":42,"address":[42089951,42090023],"length":1,"stats":{"Line":2}},{"line":43,"address":[42090159],"length":1,"stats":{"Line":1}},{"line":44,"address":[42090295],"length":1,"stats":{"Line":1}},{"line":45,"address":[42090415],"length":1,"stats":{"Line":1}},{"line":46,"address":[42090512],"length":1,"stats":{"Line":1}},{"line":54,"address":[37405152],"length":1,"stats":{"Line":1}},{"line":55,"address":[37405153],"length":1,"stats":{"Line":2}},{"line":57,"address":[42090723],"length":1,"stats":{"Line":1}},{"line":58,"address":[42090940],"length":1,"stats":{"Line":1}},{"line":61,"address":[42091072],"length":1,"stats":{"Line":1}},{"line":62,"address":[42091049],"length":1,"stats":{"Line":1}},{"line":63,"address":[42091192,42091633],"length":1,"stats":{"Line":2}},{"line":64,"address":[42091256],"length":1,"stats":{"Line":1}},{"line":65,"address":[42091281],"length":1,"stats":{"Line":1}},{"line":66,"address":[42091288],"length":1,"stats":{"Line":1}},{"line":67,"address":[42091341],"length":1,"stats":{"Line":1}},{"line":68,"address":[42091369],"length":1,"stats":{"Line":1}},{"line":69,"address":[42091397],"length":1,"stats":{"Line":1}},{"line":70,"address":[42091425],"length":1,"stats":{"Line":1}},{"line":71,"address":[42091453],"length":1,"stats":{"Line":1}},{"line":72,"address":[42091481],"length":1,"stats":{"Line":1}},{"line":73,"address":[42091504],"length":1,"stats":{"Line":1}},{"line":74,"address":[42091527],"length":1,"stats":{"Line":1}},{"line":75,"address":[42091665,42091592,42093240,42091573],"length":1,"stats":{"Line":2}},{"line":78,"address":[42091792],"length":1,"stats":{"Line":1}},{"line":79,"address":[42091688,42091785],"length":1,"stats":{"Line":2}},{"line":80,"address":[42091912,42092336],"length":1,"stats":{"Line":2}},{"line":81,"address":[42091976],"length":1,"stats":{"Line":1}},{"line":82,"address":[42092001],"length":1,"stats":{"Line":1}},{"line":83,"address":[42092026],"length":1,"stats":{"Line":1}},{"line":84,"address":[42092051],"length":1,"stats":{"Line":1}},{"line":85,"address":[42092076],"length":1,"stats":{"Line":1}},{"line":86,"address":[42092101],"length":1,"stats":{"Line":1}},{"line":87,"address":[42092126],"length":1,"stats":{"Line":1}},{"line":88,"address":[42092151],"length":1,"stats":{"Line":1}},{"line":89,"address":[42092176],"length":1,"stats":{"Line":1}},{"line":90,"address":[42092199],"length":1,"stats":{"Line":1}},{"line":91,"address":[42092222],"length":1,"stats":{"Line":1}},{"line":92,"address":[42093148,42092295,42092268,42092368],"length":1,"stats":{"Line":2}},{"line":94,"address":[42092391],"length":1,"stats":{"Line":1}},{"line":95,"address":[42092451],"length":1,"stats":{"Line":1}},{"line":96,"address":[42092522],"length":1,"stats":{"Line":1}},{"line":97,"address":[42092601],"length":1,"stats":{"Line":1}},{"line":101,"address":[42092608],"length":1,"stats":{"Line":1}},{"line":102,"address":[42092730],"length":1,"stats":{"Line":1}},{"line":107,"address":[42092852],"length":1,"stats":{"Line":1}},{"line":108,"address":[42092956],"length":1,"stats":{"Line":1}},{"line":113,"address":[37405184],"length":1,"stats":{"Line":1}},{"line":116,"address":[37405185,37405250],"length":1,"stats":{"Line":1}},{"line":125,"address":[40602644,40587804,40619043,40492672,40493111,40618604,40603083,40588243],"length":1,"stats":{"Line":0}},{"line":134,"address":[40171380,40173313,40238182,40158522,40223556,40168965,40159247,40223153,40166817,40171814,40220623,40224659,40240185,40157217,40246221,40225640,40247659,40172623,40169410,40238621,40245782,40164374,40168255,40157675,40167597,40170848,40239464,40166414,40170190,40247001],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":61},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","main.rs"],"content":"#![allow(unexpected_cfgs)]\n\nmod controllers;\nmod db;\nmod http_models;\nmod log;\nmod middleware;\nmod sql_models;\n\n#[cfg(not(tarpaulin_include))]\nmod agent;\n#[cfg(not(tarpaulin_include))]\nmod error;\n#[cfg(not(tarpaulin_include))]\nmod global;\n#[cfg(not(tarpaulin_include))]\nmod swagger;\n\n#[cfg(test)]\nmod tests;\n\nuse crate::controllers::AxumRouter;\nuse crate::global::*;\nuse crate::http_models::event::{REGEX_COUNTRY, REGEX_LOCALITY, REGEX_POST_CODE, REGEX_ST_ADDR};\nuse axum::{Extension, routing::get_service};\nuse http::{Method, header::HeaderValue};\nuse std::env;\nuse std::net::SocketAddr;\nuse std::path::Path;\nuse std::str::FromStr;\nuse tower_cookies::CookieManagerLayer;\nuse tower_cookies::cookie::Key;\nuse tower_http::{\n\tcors::CorsLayer,\n\tservices::{ServeDir, ServeFile},\n};\n\n#[tokio::main]\nasync fn main() -\u003e std::result::Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n\t#[cfg(not(tarpaulin_include))]\n\t{\n\t\t// Load our evironment variables\n\t\tdotenvy::dotenv().ok();\n\t\tlog::init_panic_handler();\n\t\tlog::init_logger();\n\n\t\t// Read and store loaded environment variables\n\t\tlet api_base_url = env::var(\"API_BASE_URL\").expect(\"API_BASE_URL must be set\");\n\t\tlet front_end_url = env::var(\"FRONTEND_URL\").expect(\"FRONTEND_URL must be set\");\n\t\tlet bind_address = env::var(\"BIND_ADDRESS\").expect(\"BIND_ADDRESS must be set\");\n\n\t\t// Initialize the database pool connection\n\t\tlet pool = db::create_pool().await;\n\n\t\t// compile regexes ahead of time\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_ST_ADDR);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_LOCALITY);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_POST_CODE);\n\t\tonce_cell::sync::Lazy::force(\u0026REGEX_COUNTRY);\n\n\t\t// Initialize the AI agent\n\t\t// The agent will use MockLLM when DEPLOY_LLM != \"1\", so creation should always succeed\n\t\tlet (agent, chat_session_id, user_id, context_store) =\n\t\t\tagent::configs::orchestrator::create_orchestrator_agent(pool.clone())\n\t\t\t\t.expect(\"Failed to create orchestrator agent\");\n\n\t\t/*\n\t\t/ Configure CORS\n\t\t/ CORS is needed when a frontend (running on one domain or port)\n\t\t/ wants to send HTTP requests to a backend running on another domain or port.\n\t\t/ This is needed for the frontend to send requests to the backend.\n\t\t/ We allow all origins, methods, and headers currently, but this should be changed later for security.\n\t\t/ TODO: Ensure we have all the right values below, may need to constrict the requests we accept\n\t\t*/\n\t\tlet cors = CorsLayer::new()\n\t\t\t.allow_origin(\n\t\t\t\tfront_end_url\n\t\t\t\t\t.parse::\u003cHeaderValue\u003e()\n\t\t\t\t\t.expect(\"Invalid frontend_url format\"),\n\t\t\t)\n\t\t\t.allow_credentials(true)\n\t\t\t.allow_methods([Method::GET, Method::POST, Method::DELETE])\n\t\t\t.allow_headers([\n\t\t\t\thttp::header::CONTENT_TYPE,\n\t\t\t\thttp::header::ACCEPT,\n\t\t\t\thttp::header::AUTHORIZATION,\n\t\t\t\thttp::header::HeaderName::from_static(\"x-requested-with\"),\n\t\t\t]);\n\n\t\t// Use an encryption/signing key for private cookies\n\t\tlet cookie_key = Key::generate();\n\n\t\t// API routes with CORS middleware\n\t\tlet api_routes = AxumRouter::new()\n\t\t\t.nest(\"/account\", controllers::account::account_routes())\n\t\t\t.nest(\"/itinerary\", controllers::itinerary::itinerary_routes())\n\t\t\t.nest(\"/chat\", controllers::chat::chat_routes());\n\t\t// TODO: nest other routes...\n\n\t\tlet api_routes = AxumRouter::new().nest(\"/api\", api_routes);\n\n\t\t#[cfg(all(not(test), debug_assertions))]\n\t\tlet api_routes = crate::swagger::merge_swagger(api_routes);\n\n\t\t// Build the main router\n\t\tlet app = axum::Router::new()\n\t\t\t.merge(api_routes)\n\t\t\t// Static files served from /dist.\n\t\t\t// Fallback must be index.html since react handles routing on front end\n\t\t\t.fallback_service(get_service(\n\t\t\t\tServeDir::new(DIST_DIR)\n\t\t\t\t\t.fallback(ServeFile::new(Path::new(DIST_DIR).join(\"index.html\"))),\n\t\t\t))\n\t\t\t.layer(Extension(pool.clone()))\n\t\t\t.layer(Extension(cookie_key.clone()))\n\t\t\t.layer(Extension(std::sync::Arc::new(tokio::sync::Mutex::new(\n\t\t\t\tagent,\n\t\t\t))))\n\t\t\t.layer(Extension(chat_session_id))\n\t\t\t.layer(Extension(user_id))\n\t\t\t.layer(Extension(context_store))\n\t\t\t.layer(CookieManagerLayer::new())\n\t\t\t.layer(cors);\n\n\t\t/*\n\t\t/ Bind the router to a specific port\n\t\t/ We use the SocketAddr struct to bind the router to the port\n\t\t/ We use the 0.0.0.0 address to bind the router to localhost\n\t\t/ We will bind to port 3001 for now\n\t\t*/\n\t\tlet addr = SocketAddr::from_str(\u0026bind_address).expect(\"Invalid BIND_ADDRESS format\");\n\t\tprintln!(\"Server starting on {}\", api_base_url);\n\n\t\t/*\n\t\t/ Serve the router ie: Start the server\n\t\t/ We will start the server with the configured router and address\n\t\t*/\n\t\tlet listener = tokio::net::TcpListener::bind(addr).await.unwrap();\n\t\taxum::serve(listener, app.into_make_service()).await?;\n\n\t\tOk(())\n\t}\n}\n","traces":[{"line":39,"address":[37654480,37654932,37654926],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","middleware.rs"],"content":"use crate::error::AppError;\nuse axum::{extract::Request, middleware::Next, response::IntoResponse};\nuse chrono::Utc;\nuse sqlx::PgPool;\nuse tower_cookies::{\n\tCookies,\n\tcookie::{\n\t\tCookie, Key, SameSite,\n\t\ttime::{Duration, OffsetDateTime},\n\t},\n};\n\n/// Inserted into request extensions on authenticated requests\n#[derive(Clone, Copy, Debug)]\npub struct AuthUser {\n\tpub id: i32,\n}\n\n/// Auth middleware for account routes\n/// - Decrypts `auth-token` private cookie using `Key` from extensions\n/// - Validates embedded expiration and that the user exists in DB\n/// - Inserts `AuthUser` into request extensions on success; otherwise 401\npub async fn middleware_auth(cookies: Cookies, mut req: Request, next: Next) -\u003e impl IntoResponse {\n\tlet key = match req.extensions().get::\u003cKey\u003e() {\n\t\tSome(k) =\u003e k.clone(),\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\tlet pool = match req.extensions().get::\u003cPgPool\u003e() {\n\t\tSome(p) =\u003e p.clone(),\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\t// Decrypt private cookie and extract token\n\tlet decrypted = match cookies.private(\u0026key).get(\"auth-token\") {\n\t\tSome(c) =\u003e c,\n\t\tNone =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\tlet token = decrypted.value().to_string();\n\n\t// Expect format: user-\u003cid\u003e.\u003cexp\u003e.sign\n\tlet parts: Vec\u003c\u0026str\u003e = token.split('.').collect();\n\n\tif parts.len() != 3 || parts[2] != \"sign\" || !parts[0].starts_with(\"user-\") {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\tlet user_id: i32 = match parts[0][5..].parse() {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\tlet exp: i64 = match parts[1].parse() {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e return AppError::Unauthorized.into_response(),\n\t};\n\n\tlet now = Utc::now().timestamp();\n\tif now \u003e exp {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\t// If the cookie will expire in less than an hour, set it's expiration to one hour from now\n\tlet one_hour = 3600;\n\tif exp - now \u003c one_hour {\n\t\tlet new_exp = now + one_hour;\n\t\tlet new_token = format!(\"user-{}.{}.sign\", user_id, new_exp);\n\n\t\tlet domain = option_env!(\"DOMAIN\").unwrap_or(\"localhost\");\n\t\tlet app_env = option_env!(\"APP_ENV\").unwrap_or(\"development\");\n\t\tlet on_production = app_env == \"production\";\n\n\t\tlet new_cookie = Cookie::build((\"auth-token\", new_token.clone()))\n\t\t\t.domain(domain.to_string())\n\t\t\t.path(\"/\")\n\t\t\t.secure(on_production)\n\t\t\t.http_only(true)\n\t\t\t.same_site(if on_production {\n\t\t\t\tSameSite::Strict\n\t\t\t} else {\n\t\t\t\tSameSite::Lax\n\t\t\t})\n\t\t\t.expires(OffsetDateTime::now_utc().saturating_add(Duration::hours(1)))\n\t\t\t.max_age(Duration::hours(1))\n\t\t\t.build();\n\n\t\tcookies.private(\u0026key).add(new_cookie);\n\t}\n\n\t// Ensure user exists\n\tlet exists_row =\n\t\tsqlx::query_as::\u003c_, (bool,)\u003e(\"SELECT EXISTS(SELECT 1 FROM accounts WHERE id = $1)\")\n\t\t\t.bind(user_id)\n\t\t\t.fetch_one(\u0026pool)\n\t\t\t.await\n\t\t\t.unwrap_or((false,));\n\n\tif !exists_row.0 {\n\t\treturn AppError::Unauthorized.into_response();\n\t}\n\n\t// Attach user to request\n\treq.extensions_mut().insert(AuthUser { id: user_id });\n\n\tnext.run(req).await\n}\n","traces":[{"line":23,"address":[38107223,38107168],"length":1,"stats":{"Line":4}},{"line":24,"address":[42745837,42745976],"length":1,"stats":{"Line":2}},{"line":25,"address":[42746046],"length":1,"stats":{"Line":1}},{"line":26,"address":[42746076],"length":1,"stats":{"Line":0}},{"line":28,"address":[42746150],"length":1,"stats":{"Line":1}},{"line":29,"address":[42746367,42746254],"length":1,"stats":{"Line":2}},{"line":30,"address":[42746303],"length":1,"stats":{"Line":0}},{"line":34,"address":[42746481,42746580,42746370],"length":1,"stats":{"Line":3}},{"line":35,"address":[42746669],"length":1,"stats":{"Line":1}},{"line":36,"address":[42746734],"length":1,"stats":{"Line":1}},{"line":38,"address":[42746876],"length":1,"stats":{"Line":1}},{"line":41,"address":[42747053,42746956],"length":1,"stats":{"Line":2}},{"line":43,"address":[42747302,42747119,42747204],"length":1,"stats":{"Line":3}},{"line":44,"address":[42749991,42747256],"length":1,"stats":{"Line":0}},{"line":47,"address":[42747454],"length":1,"stats":{"Line":1}},{"line":48,"address":[42747678],"length":1,"stats":{"Line":1}},{"line":49,"address":[42747632,42749989],"length":1,"stats":{"Line":0}},{"line":52,"address":[42747698],"length":1,"stats":{"Line":1}},{"line":53,"address":[42747828],"length":1,"stats":{"Line":1}},{"line":54,"address":[42747790,42749987],"length":1,"stats":{"Line":0}},{"line":57,"address":[42747852],"length":1,"stats":{"Line":1}},{"line":58,"address":[42747922],"length":1,"stats":{"Line":1}},{"line":59,"address":[42749956,42747973],"length":1,"stats":{"Line":0}},{"line":63,"address":[42747943],"length":1,"stats":{"Line":1}},{"line":64,"address":[42748019,42747955],"length":1,"stats":{"Line":2}},{"line":65,"address":[42748184,42748091],"length":1,"stats":{"Line":1}},{"line":66,"address":[42748134,42748205],"length":1,"stats":{"Line":2}},{"line":68,"address":[42748348,42748451],"length":1,"stats":{"Line":2}},{"line":69,"address":[42748483],"length":1,"stats":{"Line":1}},{"line":70,"address":[42748546],"length":1,"stats":{"Line":1}},{"line":72,"address":[42749308,42748658,42748818,42749181,42748589],"length":1,"stats":{"Line":5}},{"line":73,"address":[42748758,42748826,42748777,42749934,42748623],"length":1,"stats":{"Line":2}},{"line":75,"address":[42748943],"length":1,"stats":{"Line":1}},{"line":77,"address":[42749004,42749028,42749018],"length":1,"stats":{"Line":3}},{"line":78,"address":[42749020],"length":1,"stats":{"Line":0}},{"line":80,"address":[42749010],"length":1,"stats":{"Line":1}},{"line":82,"address":[42749075,42749189,42748904,42749082,42749912],"length":1,"stats":{"Line":2}},{"line":83,"address":[42749340,42749240,42749267,42749880],"length":1,"stats":{"Line":2}},{"line":86,"address":[42749515,42749429],"length":1,"stats":{"Line":2}},{"line":90,"address":[42750185,42750272,42749797,42748049],"length":1,"stats":{"Line":4}},{"line":92,"address":[42749699],"length":1,"stats":{"Line":1}},{"line":93,"address":[42749736],"length":1,"stats":{"Line":1}},{"line":94,"address":[39090691],"length":1,"stats":{"Line":4}},{"line":95,"address":[42750257],"length":1,"stats":{"Line":1}},{"line":97,"address":[42750284],"length":1,"stats":{"Line":1}},{"line":98,"address":[42750288,42750353],"length":1,"stats":{"Line":0}},{"line":102,"address":[42750706,42750331],"length":1,"stats":{"Line":2}},{"line":104,"address":[39090712],"length":1,"stats":{"Line":2}}],"covered":40,"coverable":48},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","account.rs"],"content":"/// Row model for the `accounts` table.\n/// - Represents a persisted user.\npub struct AccountRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Unique email address\n\t#[allow(dead_code)] // email required for login route\n\tpub email: String,\n\t/// Argon2 hashed password\n\tpub password: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","event_list.rs"],"content":"use chrono::{NaiveDate, NaiveDateTime};\nuse serde::{Deserialize, Serialize};\n\nuse crate::sql_models::{Period, TimeOfDay};\n\n/// Row model for an inner join of `event_list` and `events` tables on chat session id.\n/// - Represents one event for an itinerary.\n#[derive(Debug, Serialize, Deserialize)]\npub struct EventListJoinRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Event name\n\tpub event_name: String,\n\t/// Event description\n\tpub event_description: Option\u003cString\u003e,\n\t/// Event address\n\tpub street_address: Option\u003cString\u003e,\n\t/// Event City\n\tpub city: Option\u003cString\u003e,\n\t/// Event Country\n\tpub country: Option\u003cString\u003e,\n\t/// Event post code\n\tpub postal_code: Option\u003ci32\u003e,\n\t/// Location coordinates\n\tpub lat: Option\u003cf64\u003e,\n\tpub lng: Option\u003cf64\u003e,\n\t/// Event type\n\tpub event_type: Option\u003cString\u003e,\n\t/// User-Created\n\tpub user_created: bool,\n\t/// Hard Start Time\n\tpub hard_start: Option\u003cNaiveDateTime\u003e,\n\t/// Hard End Time\n\tpub hard_end: Option\u003cNaiveDateTime\u003e,\n\t/// Timezone of hard start and hard end\n\tpub timezone: Option\u003cString\u003e,\n\tpub place_id: Option\u003cString\u003e,\n\tpub wheelchair_accessible_parking: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_entrance: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_restroom: Option\u003cbool\u003e,\n\tpub wheelchair_accessible_seating: Option\u003cbool\u003e,\n\tpub serves_vegetarian_food: Option\u003cbool\u003e,\n\tpub price_level: Option\u003ci32\u003e,\n\tpub utc_offset_minutes: Option\u003ci32\u003e,\n\tpub website_uri: Option\u003cString\u003e,\n\tpub types: Option\u003cString\u003e,\n\tpub photo_name: Option\u003cString\u003e,\n\tpub photo_width: Option\u003ci32\u003e,\n\tpub photo_height: Option\u003ci32\u003e,\n\tpub photo_author: Option\u003cString\u003e,\n\tpub photo_author_uri: Option\u003cString\u003e,\n\tpub photo_author_photo_uri: Option\u003cString\u003e,\n\tpub weekday_descriptions: Option\u003cString\u003e,\n\tpub secondary_hours_type: Option\u003ci32\u003e,\n\tpub next_open_time: Option\u003cNaiveDateTime\u003e,\n\tpub next_close_time: Option\u003cNaiveDateTime\u003e,\n\tpub open_now: Option\u003cbool\u003e,\n\tpub periods: Vec\u003cPeriod\u003e,\n\tpub special_days: Vec\u003cNaiveDate\u003e,\n\t/// Morning/Noon/Afternoon/Evening\n\tpub time_of_day: TimeOfDay,\n\t/// UTC date within itinerary date range (%Y-%m-%d)\n\tpub date: NaiveDate,\n\t/// Index the event is in within the time block.\n\t/// Must be some to guarantee ordering\n\tpub block_index: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","itinerary.rs"],"content":"use chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\n\n/// Row model for the `itineraries` table.\n#[derive(Debug, Serialize, Deserialize)]\npub struct ItineraryRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Owner account id (FK)\n\tpub account_id: Option\u003ci32\u003e,\n\t/// Start date for itinerary (Destination's local timezone - naive %Y-%m-%d)\n\tpub start_date: NaiveDate,\n\t/// End date for itinerary (Destination's local timezone - naive %Y-%m-%d)\n\tpub end_date: NaiveDate,\n\t/// Possible chat session to link to if this itinerary is edited\n\tpub chat_session_id: Option\u003ci32\u003e,\n\t/// Title of itinerary, defaults to include location and date range\n\tpub title: String,\n\t/// Array of event IDs that are unassigned to any specific time slot\n\tpub unassigned_event_ids: Option\u003cVec\u003ci32\u003e\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","message.rs"],"content":"use chrono::NaiveDateTime;\nuse serde::{Deserialize, Serialize};\nuse sqlx::FromRow;\nuse utoipa::ToSchema;\n\n/// Row model for `chat_sessions` table\n#[derive(Serialize, Deserialize, FromRow, ToSchema)]\npub struct ChatSessionRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Name of chat for user context\n\tpub title: String,\n}\n\n/// Row model for `message` table\n#[derive(Serialize, Deserialize, FromRow)]\npub struct MessageRow {\n\t/// Primary key\n\tpub id: i32,\n\t/// Chat session this message belongs to\n\tpub chat_session_id: i32,\n\t/// Possible itinerary associated with this message\n\tpub itinerary_id: Option\u003ci32\u003e,\n\t/// Whether this message was sent by the user or generated by the LLM\n\tpub is_user: bool,\n\t/// UTC timestamp this message was sent (%Y-%m-%d %H:%M:%S)\n\tpub timestamp: NaiveDateTime,\n\t/// Content of the message\n\tpub text: String,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","sql_models","mod.rs"],"content":"use chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\nuse sqlx::Type;\nuse utoipa::ToSchema;\n\npub mod account;\npub mod event_list;\npub mod itinerary;\npub mod message;\n\n/// Budget preference enum mapped to Postgres `budget_bucket`.\n/// Used in account preferences and returned by account APIs.\n/// - Fields:\n///   - Enum variants representing budget bands\n#[derive(Debug, Serialize, Deserialize, Clone, Type, ToSchema)]\n#[sqlx(type_name = \"budget_bucket\")]\npub enum BudgetBucket {\n\tVeryLowBudget,\n\tLowBudget,\n\tMediumBudget,\n\tHighBudget,\n\tLuxuryBudget,\n}\n\n/// Risk tolerance enum mapped to Postgres `risk_tolerence`.\n/// Used in account preferences and returned by account APIs.\n/// - Fields:\n///   - Enum variants representing risk appetite\n#[derive(Debug, Serialize, Deserialize, Clone, Type, ToSchema)]\n#[sqlx(type_name = \"risk_tolerence\")]\npub enum RiskTolerence {\n\tChillVibes,\n\tLightFun,\n\tAdventurer,\n\tRiskTaker,\n}\n\n/// The time of day the event will take place in the itinerary\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq)]\n#[sqlx(type_name = \"time_of_day\")]\npub enum TimeOfDay {\n\tMorning,\n\tAfternoon,\n\tEvening,\n}\n\n/// The status of the LLM pipeline\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq, ToSchema)]\n#[sqlx(type_name = \"llm_progress\")]\npub enum LlmProgress {\n\tReady,\n\t// Task Agent Tools\n\tRetrieveUserProfile,\n\tRetrieveChatContext,\n\tUpdateTripContext,\n\tUpdateChatTitle,\n\tAskForClarification,\n\t// Research Agent\n\tSearching,\n\tGeocoding,\n\tSearchingEvents,\n\t// Constraint Agent\n\tFiltering,\n\tCheckingConstraints,\n\t// Scheduling\n\tScheduling,\n\t// Optimizer Agent\n\tOptimizing,\n\tRankingEvents,\n\t// Final Response\n\tFinalizingItinerary,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, Type, PartialEq, ToSchema)]\n#[sqlx(type_name = \"event_period\")]\npub struct Period {\n\tpub open_date: Option\u003cNaiveDate\u003e,\n\tpub open_truncated: Option\u003cbool\u003e,\n\tpub open_day: i32,\n\tpub open_hour: i32,\n\tpub open_minute: i32,\n\tpub close_date: Option\u003cNaiveDate\u003e,\n\tpub close_truncated: Option\u003cbool\u003e,\n\tpub close_day: Option\u003ci32\u003e,\n\tpub close_hour: Option\u003ci32\u003e,\n\tpub close_minute: Option\u003ci32\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","swagger.rs"],"content":"use axum::Router;\nuse std::fs::{self, File};\nuse std::io::Write;\nuse std::path::PathBuf;\nuse utoipa::{\n\tModify, OpenApi,\n\topenapi::security::{ApiKey, ApiKeyValue, SecurityScheme},\n};\nuse utoipa_axum::router::OpenApiRouter;\nuse utoipa_swagger_ui::SwaggerUi;\n\nuse crate::controllers::{account::AccountApiDoc, chat::ChatApiDoc, itinerary::ItineraryApiDoc};\n\n#[derive(OpenApi)]\n#[openapi(\n\tmodifiers(\u0026SecurityAddon),\n\tsecurity(\n\t\t(),\n\t\t(\"set-cookie\"=[])\n\t),\n    info(\n    \ttitle=\"Journey API\",\n    \tdescription = \"The public API documentation for the Journey web application.\"\n    ),\n    nest(\n    \t(path=\"/api/account\", api=AccountApiDoc),\n    \t(path=\"/api/chat\", api=ChatApiDoc),\n    \t(path=\"/api/itinerary\", api=ItineraryApiDoc)\n    ),\n    servers(\n    \t(url=\"http://localhost:3001\", description=\"Local host server for development\"),\n     \t//TODO add deployed production server URL\n    )\n)]\nstruct ApiDoc;\n\npub struct SecurityAddon;\n\nimpl Modify for SecurityAddon {\n\tfn modify(\u0026self, openapi: \u0026mut utoipa::openapi::OpenApi) {\n\t\tif let Some(components) = openapi.components.as_mut() {\n\t\t\tcomponents.add_security_scheme(\n                \"set-cookie\",\n                SecurityScheme::ApiKey(ApiKey::Cookie(ApiKeyValue::with_description(\n                \t\"auth-token\",\n                 \t\"An HTTP-only cookie which must encode a valid account id, expiration timestamp, and other information\"\n                ))),\n            )\n\t\t}\n\t}\n}\n\n/// Merges swagger with the current routes\npub fn merge_swagger(router: OpenApiRouter) -\u003e Router {\n\tlet doc = ApiDoc::openapi();\n\tlet docs_path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"docs\");\n\tfs::create_dir_all(\u0026docs_path).unwrap();\n\tlet mut file = File::create(docs_path.join(\"openapi.json\")).unwrap();\n\tfile.write_all(doc.to_pretty_json().unwrap().as_bytes())\n\t\t.unwrap();\n\tlet (router, api) = OpenApiRouter::with_openapi(doc)\n\t\t.merge(router)\n\t\t.split_for_parts();\n\trouter.merge(SwaggerUi::new(\"/swagger\").url(\"/docs/openapi.json\", api.clone()))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","eclipse","marist","senior","capping","Capping2025","src","tests.rs"],"content":"use crate::agent::configs::orchestrator::create_dummy_orchestrator_agent;\nuse crate::http_models::chat_session::ProgressRequest;\nuse crate::sql_models::LlmProgress;\nuse crate::{\n\tagent, controllers, db,\n\tglobal::*,\n\thttp_models::{\n\t\taccount::{LoginRequest, SignupRequest, UpdateRequest},\n\t\tchat_session::RenameRequest,\n\t\tevent::{SearchEventRequest, UserEventRequest, UserEventResponse},\n\t\titinerary::{Itinerary, UnsaveRequest},\n\t\tmessage::{MessagePageRequest, SendMessageRequest, UpdateMessageRequest},\n\t},\n\tlog,\n\tmiddleware::AuthUser,\n\tsql_models::{BudgetBucket, RiskTolerence},\n};\nuse argon2::{\n\tArgon2,\n\tpassword_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString, rand_core::OsRng},\n};\nuse axum::{Extension, Json, Router};\nuse chrono::{NaiveDate, NaiveDateTime, Utc};\nuse serde_json::json;\nuse serial_test::serial;\nuse sqlx::{PgPool, migrate};\nuse std::{\n\tfs,\n\tio::Write,\n\tpath::Path,\n\ttime::{Duration, SystemTime},\n};\nuse tokio::net::TcpListener;\nuse tokio::sync::Mutex;\nuse tower_cookies::{\n\tCookie, CookieManagerLayer, Key,\n\tcookie::{CookieJar, SameSite, time},\n};\nuse tracing::{error, info, trace};\n\n// UNIT TESTS\n\n/// Test password verification logic\n#[test]\nfn test_password_verification() {\n\tlet password = \"test_password123\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hash the password\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify correct password\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// Verify incorrect password fails\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"wrong_password\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test token generation format\n#[test]\nfn test_token_generation() {\n\tlet user_id = 42;\n\tlet token = format!(\"user-{}.exp.sign\", user_id);\n\tassert_eq!(token, \"user-42.exp.sign\");\n\tassert!(token.starts_with(\"user-\"));\n\tassert!(token.ends_with(\".exp.sign\"));\n}\n\n/// Test cookie security settings\n#[test]\nfn test_cookie_security_development() {\n\tlet token_value = \"test-token-123\";\n\tlet on_production = false;\n\tlet domain = \"localhost\";\n\n\tlet cookie = Cookie::build((\"auth-token\", token_value))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.max_age(time::Duration::days(3))\n\t\t.build();\n\n\tassert_eq!(cookie.name(), \"auth-token\");\n\tassert_eq!(cookie.value(), token_value);\n\tassert_eq!(cookie.path(), Some(\"/\"));\n\tassert_eq!(cookie.http_only(), Some(true));\n\tassert_eq!(cookie.same_site(), Some(SameSite::Lax));\n\tassert!(!cookie.secure().unwrap_or(false));\n}\n\n/// Test cookie security settings for production\n#[test]\nfn test_cookie_security_production() {\n\tlet token_value = \"test-token-456\";\n\tlet on_production = true;\n\tlet domain = \"example.com\";\n\n\tlet cookie = Cookie::build((\"auth-token\", token_value))\n\t\t.domain(domain.to_string())\n\t\t.path(\"/\")\n\t\t.secure(on_production)\n\t\t.http_only(true)\n\t\t.same_site(if on_production {\n\t\t\tSameSite::Strict\n\t\t} else {\n\t\t\tSameSite::Lax\n\t\t})\n\t\t.max_age(time::Duration::days(3))\n\t\t.build();\n\n\tassert_eq!(cookie.name(), \"auth-token\");\n\tassert_eq!(cookie.value(), token_value);\n\tassert_eq!(cookie.http_only(), Some(true));\n\tassert_eq!(cookie.same_site(), Some(SameSite::Strict));\n\tassert!(cookie.secure().unwrap_or(false));\n}\n\n/// Test password hashing for signup\n#[test]\nfn test_signup_password_hashing() {\n\tlet password = \"secure_password_123\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hash the password (as done in signup)\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify the hash is not the same as the plain password\n\tassert_ne!(password_hash, password);\n\n\t// Verify the hash starts with expected format\n\tassert!(password_hash.starts_with(\"$argon2\"));\n\n\t// Verify we can verify the password later (as in login)\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n}\n\n/// Test that different salts produce different hashes\n#[test]\nfn test_signup_different_salts() {\n\tlet password = \"same_password\";\n\tlet argon2 = Argon2::default();\n\n\t// Generate two hashes with different salts\n\tlet salt1 = SaltString::generate(\u0026mut OsRng);\n\tlet hash1 = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt1)\n\t\t.unwrap()\n\t\t.to_string();\n\n\tlet salt2 = SaltString::generate(\u0026mut OsRng);\n\tlet hash2 = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt2)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Hashes should be different due to different salts\n\tassert_ne!(hash1, hash2);\n\n\t// But both should verify the same password\n\tlet parsed_hash1 = PasswordHash::new(\u0026hash1).unwrap();\n\tlet parsed_hash2 = PasswordHash::new(\u0026hash2).unwrap();\n\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash1)\n\t\t\t.is_ok()\n\t);\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(password.as_bytes(), \u0026parsed_hash2)\n\t\t\t.is_ok()\n\t);\n}\n\n/// Test that password hash cannot be reversed to plain text\n#[test]\nfn test_signup_hash_irreversibility() {\n\tlet password = \"my_secret_password_456\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Hash should not contain the plain password\n\tassert!(!password_hash.contains(password));\n\n\t// Hash should be significantly longer than input\n\tassert!(password_hash.len() \u003e password.len() * 2);\n}\n\n/// Test that any password can be hashed (even if it wouldn't pass validation)\n#[test]\nfn test_password_hashing_mechanism() {\n\t// Test that the hashing algorithm works with any input\n\tlet test_password = \"abc\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\t// Hashing mechanism should work regardless of validation rules\n\tlet result = argon2.hash_password(test_password.as_bytes(), \u0026salt);\n\tassert!(result.is_ok());\n\n\tlet password_hash = result.unwrap().to_string();\n\n\t// Verify the hash works\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(test_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// But wrong password should fail\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"wrong\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test password with special ASCII characters\n#[test]\nfn test_signup_special_characters_password() {\n\t// Only ASCII special characters are allowed\n\tlet special_password = \"Passw0rd!@#$%\";\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(special_password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify special characters are handled correctly\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(special_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n\n\t// Wrong password should fail\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(b\"Passw0rd!@#$\", \u0026parsed_hash)\n\t\t\t.is_err()\n\t);\n}\n\n/// Test maximum allowed password length (128 chars)\n#[test]\nfn test_signup_max_password_length() {\n\t// 128 characters with required complexity\n\tlet max_password = \"A\".to_string() + \u0026\"a\".repeat(126) + \"1\";\n\tassert_eq!(max_password.len(), 128);\n\n\tlet salt = SaltString::generate(\u0026mut OsRng);\n\tlet argon2 = Argon2::default();\n\n\tlet password_hash = argon2\n\t\t.hash_password(max_password.as_bytes(), \u0026salt)\n\t\t.unwrap()\n\t\t.to_string();\n\n\t// Verify max length password works\n\tlet parsed_hash = PasswordHash::new(\u0026password_hash).unwrap();\n\tassert!(\n\t\tArgon2::default()\n\t\t\t.verify_password(max_password.as_bytes(), \u0026parsed_hash)\n\t\t\t.is_ok()\n\t);\n}\n\n#[test]\nfn test_validate_email() {\n\t// valid\n\tassert!(SignupRequest::validate_email(\"user@example.com\"));\n\tassert!(SignupRequest::validate_email(\"test.user@domain.co.uk\"));\n\tassert!(SignupRequest::validate_email(\"name+tag@company.org\"));\n\tassert!(SignupRequest::validate_email(\"user123@test-domain.com\"));\n\n\t// invalid\n\tassert!(!SignupRequest::validate_email(\"\"));\n\tassert!(!SignupRequest::validate_email(\"notanemail\"));\n\tassert!(!SignupRequest::validate_email(\"@example.com\"));\n\tassert!(!SignupRequest::validate_email(\"user@\"));\n\tassert!(!SignupRequest::validate_email(\"user@.com\"));\n\tassert!(!SignupRequest::validate_email(\"user @example.com\"));\n\tassert!(!SignupRequest::validate_email(\"user@exam ple.com\"));\n}\n\n#[test]\nfn test_validate_password() {\n\t// valid\n\tassert!(SignupRequest::validate_password(\"Password1\").is_ok());\n\tassert!(SignupRequest::validate_password(\"MySecure123\").is_ok());\n\tassert!(SignupRequest::validate_password(\"Passw0rd!@#\").is_ok());\n\tassert!(SignupRequest::validate_password(\"LongerPassword123\").is_ok());\n\n\t// too short\n\tlet result = SignupRequest::validate_password(\"Pass1\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must be at least 8 characters long\"\n\t);\n\n\t// no uppercase\n\tlet result = SignupRequest::validate_password(\"password123\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one uppercase letter\"\n\t);\n\n\t// no lowercase\n\tlet result = SignupRequest::validate_password(\"PASSWORD123\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one lowercase letter\"\n\t);\n\n\t// no number\n\tlet result = SignupRequest::validate_password(\"PasswordOnly\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain at least one number\"\n\t);\n\n\t// too long\n\tlet password = \"A\".repeat(129) + \"1a\";\n\tlet result = SignupRequest::validate_password(\u0026password);\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must be 128 characters or less\"\n\t);\n\n\t// non ascii\n\tlet result = SignupRequest::validate_password(\"Password1パスワード\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain only ASCII characters\"\n\t);\n\n\t// emoji\n\tlet result = SignupRequest::validate_password(\"Password1🔒\");\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Password must contain only ASCII characters\"\n\t);\n\n\t// max length allowed\n\t// Test that exactly 128 characters is okay (with required chars)\n\tlet password = \"A\".to_string() + \u0026\"a\".repeat(126) + \"1\";\n\tassert_eq!(password.len(), 128);\n\tassert!(SignupRequest::validate_password(\u0026password).is_ok());\n}\n\n#[test]\nfn test_validate_signup_payload() {\n\t// valid\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tassert!(payload.validate().is_ok());\n\n\t// empty email\n\tlet payload = SignupRequest {\n\t\temail: \"\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Email is required\");\n\n\t// invalid email\n\tlet payload = SignupRequest {\n\t\temail: \"not-an-email\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Invalid email format\");\n\n\t// empty first name\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"First name is required\");\n\n\t// empty last name\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(result.unwrap_err(), \"Last name is required\");\n\n\t// first name too long\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"a\".repeat(51),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"First name must be 50 characters or less\"\n\t);\n\n\t// last name too long\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"a\".repeat(51),\n\t\tpassword: \"Password123\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert_eq!(\n\t\tresult.unwrap_err(),\n\t\t\"Last name must be 50 characters or less\"\n\t);\n\n\t// weak password\n\tlet payload = SignupRequest {\n\t\temail: \"test@example.com\".to_string(),\n\t\tfirst_name: \"John\".to_string(),\n\t\tlast_name: \"Doe\".to_string(),\n\t\tpassword: \"weak\".to_string(),\n\t};\n\tlet result = payload.validate();\n\tassert!(result.is_err());\n\tassert!(result.unwrap_err().contains(\"Password\"));\n\n\t// whitespace trimming\n\tlet payload = SignupRequest {\n\t\temail: \"  test@example.com  \".to_string(),\n\t\tfirst_name: \"  John  \".to_string(),\n\t\tlast_name: \"  Doe  \".to_string(),\n\t\tpassword: \"Password123\".to_string(), // Valid ASCII password\n\t};\n\t// Email and names should be validated after trimming whitespace\n\tassert!(payload.validate().is_ok());\n}\n\n/// Verifies that `db::create_pool` panics when `DATABASE_URL` is not set.\n#[test]\n#[serial(db)]\nfn test_db_pool_panics_without_env() {\n\t// Save and clear DATABASE_URL\n\tlet prev = std::env::var(\"DATABASE_URL\").ok();\n\tunsafe {\n\t\tstd::env::remove_var(\"DATABASE_URL\");\n\t}\n\n\tlet result = std::panic::catch_unwind(|| {\n\t\tlet rt = tokio::runtime::Runtime::new().unwrap();\n\t\trt.block_on(async {\n\t\t\t// Should panic due to missing env var\n\t\t\tlet _ = db::create_pool().await;\n\t\t});\n\t});\n\n\t// Restore DATABASE_URL\n\tmatch prev {\n\t\tSome(val) =\u003e unsafe { std::env::set_var(\"DATABASE_URL\", val) },\n\t\tNone =\u003e unsafe { std::env::remove_var(\"DATABASE_URL\") },\n\t}\n\n\tassert!(result.is_err());\n}\n\n/// Optional integration test requiring a real database in `DATABASE_URL`.\n/// Run with: `cargo test -- --ignored`\n#[tokio::test]\n#[ignore]\n#[serial(db)]\nasync fn test_db_pool_connects_and_selects() {\n\tlet database_url = match std::env::var(\"DATABASE_URL\") {\n\t\tOk(v) =\u003e v,\n\t\tErr(_) =\u003e {\n\t\t\t// Not set in most environments; mark as success skip\n\t\t\tinfo!(\"DATABASE_URL not set; skipping real DB test\");\n\t\t\treturn;\n\t\t}\n\t};\n\n\t// Ensure env var is present for this test\n\tunsafe {\n\t\tstd::env::set_var(\"DATABASE_URL\", database_url);\n\t}\n\n\tlet pool = db::create_pool().await;\n\n\t// Simple liveness query\n\tlet row: (i32,) = sqlx::query_as(\"SELECT 1\")\n\t\t.fetch_one(\u0026pool)\n\t\t.await\n\t\t.expect(\"SELECT 1 should succeed\");\n\tassert_eq!(row.0, 1);\n}\n\n/// Verifies that `logs/latest.log` is created and written to from log events.\n#[test]\n#[serial(log)]\nfn test_logger() {\n\t//dotenv doesn't work in github actions bc .env is ignored\n\tunsafe {\n\t\t// Safety\n\t\t//\n\t\t// Always safe on Windows.\n\t\t//\n\t\t// Other platforms: risk of race condition in multi-threaded environment.\n\t\t// We are not reading/writing this environment variable from multiple threads, so we're good.\n\t\tstd::env::set_var(\"RUST_LOG\", \"warn,Capping2025=debug\");\n\t}\n\tlet latest_log_path = Path::new(LOG_DIR).join(LATEST_LOG);\n\tlog::init_logger();\n\ttrace!(\"Test trace\");\n\terror!(\"Test error\");\n\tlog::log_writer().flush().unwrap();\n\t//wait for IO to finish because flushing doesn't work?\n\tstd::thread::sleep(Duration::from_millis(10));\n\tlet logs = fs::read_to_string(latest_log_path).unwrap();\n\tinfo!(\"{logs}\");\n\tassert!(logs.len() \u003e 0);\n}\n\n/// Verifies that `logs/crash.log` is created and written to on a panic.\n#[test]\n#[serial(panic_log)]\nfn test_panic_handler() {\n\tlog::init_panic_handler();\n\tstd::panic::catch_unwind(|| {\n\t\tpanic!(\"Test panic\");\n\t})\n\t.unwrap_err();\n\tlet content = fs::read_to_string(Path::new(LOG_DIR).join(CRASH_LOG)).unwrap();\n\tassert!(content.len() \u003e 0);\n}\n\n/// It's easier to have all these in 1 test to share a db pool, and we don't have to spin up a server\n#[tokio::test]\n#[serial(db)]\nasync fn test_controllers() {\n\t_ = dotenvy::dotenv();\n\tlet cookies = CookieJar::new();\n\tlet key = Extension(Key::derive_from(\u0026[0u8; 32]));\n\tlet pool = Extension(db::create_pool().await);\n\n\t_ = tokio::join!(\n\t\ttest_signup_conflict_on_duplicate_email(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_http_login_invalid_credentials(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_current_endpoint_returns_account(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_returns_account(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_partial_fields(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_update_endpoint_with_preferences(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_get_itinerary_id_not_found(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_invalid_signup_email(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_saved_itineraries_endpoint(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_save_itineraries(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_chat_flow(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_user_event_flow(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_itinerary_success(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_itinerary_not_found(cookies.clone(), key.clone(), pool.clone()),\n\t\ttest_unsave_already_unsaved_itinerary(cookies.clone(), key.clone(), pool.clone()),\n\t);\n}\n\nasync fn test_signup_conflict_on_duplicate_email(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"dupe+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Bob\"),\n\t\tlast_name: String::from(\"Dupe\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// First signup should succeed\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json.clone())\n\t\t.await\n\t\t.unwrap();\n\t// Second signup with same email should 409\n\tassert_eq!(\n\t\tcontrollers::account::api_signup(\u0026mut cookies, key, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t409\n\t);\n}\n\nasync fn test_http_login_invalid_credentials(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"badEmail+{}@example.com\", unique);\n\tlet json = Json(LoginRequest {\n\t\temail,\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// attempt to login with nonexistant email\n\tassert_eq!(\n\t\tcontrollers::account::api_login(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n\n\tlet email = format!(\"goodEmail+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail: email.clone(),\n\t\tfirst_name: String::from(\"Alice\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// signup\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet json = Json(LoginRequest {\n\t\temail,\n\t\tpassword: String::from(\"ChickenNugget1234\"),\n\t});\n\t// attempt to login with a correct email, but the wrong password\n\tassert_eq!(\n\t\tcontrollers::account::api_login(\u0026mut cookies, key, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n}\n\nasync fn test_current_endpoint_returns_account(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"current+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Current\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\t// Test /current endpoint returns Account struct\n\t_ = controllers::account::api_current(pool.clone(), user)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_returns_account(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"update+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Update\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with all fields\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: Some(format!(\"updated+{}@example.com\", unique)),\n\t\tfirst_name: Some(String::from(\"Updated\")),\n\t\tlast_name: Some(String::from(\"User\")),\n\t\tpassword: Some(String::from(\"NewPassword123\")),\n\t\tcurrent_password: Some(String::from(\"Password123\")),\n\t\tbudget_preference: Some(BudgetBucket::HighBudget),\n\t\trisk_preference: Some(RiskTolerence::Adventurer),\n\t\tfood_allergies: Some(String::from(\"Peanuts, shellfish\")),\n\t\tdisabilities: Some(String::from(\"Wheelchair accessible\")),\n\t\tprofile_picture: Some(String::from(\"base64-txt\")),\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_partial_fields(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"partial+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Partial\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with only some fields\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: None,\n\t\tfirst_name: Some(String::from(\"PartiallyUpdated\")),\n\t\tlast_name: None,\n\t\tpassword: None,\n\t\tcurrent_password: None,\n\t\tbudget_preference: None,\n\t\trisk_preference: None,\n\t\tfood_allergies: Some(String::from(\"Gluten\")),\n\t\tdisabilities: None,\n\t\tprofile_picture: None,\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_update_endpoint_with_preferences(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"prefs+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Prefs\"),\n\t\tlast_name: String::from(\"Tester\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /update endpoint with enum preferences\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(UpdateRequest {\n\t\temail: None,\n\t\tfirst_name: None,\n\t\tlast_name: None,\n\t\tpassword: None,\n\t\tcurrent_password: None,\n\t\tbudget_preference: Some(BudgetBucket::LuxuryBudget),\n\t\trisk_preference: Some(RiskTolerence::RiskTaker),\n\t\tfood_allergies: None,\n\t\tdisabilities: None,\n\t\tprofile_picture: None,\n\t});\n\t_ = controllers::account::api_update(pool, user, json)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_get_itinerary_id_not_found(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"get_itinerary+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Get\"),\n\t\tlast_name: String::from(\"Itinerary\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /{id} endpoint with non-existent itinerary (should return 404)\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_get_itinerary(user, axum::extract::Path(999999), pool.clone())\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n}\n\nasync fn test_invalid_signup_email(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"invalid_email_{}\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Get\"),\n\t\tlast_name: String::from(\"Event\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tassert_eq!(\n\t\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n}\n\nasync fn test_saved_itineraries_endpoint(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"saved_itineraries+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Test /saved endpoint returns user's itineraries\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\t_ = controllers::itinerary::api_saved_itineraries(user, pool)\n\t\t.await\n\t\t.unwrap();\n}\n\nasync fn test_save_itineraries(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_save_itinerary_new+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// save itinerary with id not in db\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Updated Title\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\tassert_ne!(itinerary_id, 0);\n\n\t// save itinerary with a matching id already in db\n\tlet json = Json(Itinerary {\n\t\tid: itinerary_id,\n\t\tstart_date: NaiveDate::parse_from_str(\"2026-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2026-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"2nd Updated Title\"),\n\t});\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_save(user, pool, json)\n\t\t\t.await\n\t\t\t.unwrap()\n\t\t\t.id,\n\t\titinerary_id\n\t);\n}\n\nasync fn test_chat_flow(mut cookies: CookieJar, key: Extension\u003cKey\u003e, pool: Extension\u003cPgPool\u003e) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_latest_message_page+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Create agent for testing - use dummy agent if DEPLOY_LLM != \"1\"\n\n\t// Clone the pool\n\tlet pool = pool.0.clone();\n\n\t// Always use dummy agent for tests\n\tlet (agent_executor, chat_session_id_atomic, _user_id_atomic, context_store) =\n\t\tcreate_dummy_orchestrator_agent(pool.clone()).expect(\"Dummy agent creation failed\");\n\n\t// Wrap in Extension and Arc\u003cMutex\u003e as usual\n\tlet agent = Extension(std::sync::Arc::new(tokio::sync::Mutex::new(agent_executor)));\n\tlet chat_session_id_atomic_ext = Extension(chat_session_id_atomic);\n\tlet context_store_ext = Extension(context_store);\n\n\tlet pool_ext = Extension(pool.clone());\n\n\t// create new chat\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet first_chat_session_id = controllers::chat::api_new_chat(user, pool_ext)\n\t\t.await\n\t\t.unwrap()\n\t\t.chat_session_id;\n\tassert_ne!(first_chat_session_id, 0);\n\n\t// create chat session - reusing first one because it's empty\n\tlet chat_session_id = controllers::chat::api_new_chat(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap()\n\t\t.chat_session_id;\n\tassert_eq!(first_chat_session_id, chat_session_id);\n\n\t// send a bunch of messages\n\tlet mut message_ids = [0; MESSAGE_PAGE_LEN as usize + 5];\n\tfor i in 0..MESSAGE_PAGE_LEN as usize + 5 {\n\t\tlet json = Json(SendMessageRequest {\n\t\t\tchat_session_id,\n\t\t\ttext: format!(\"Test msg {}\", i),\n\t\t\titinerary_id: None,\n\t\t});\n\t\tmessage_ids[i] = controllers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson,\n\t\t)\n\t\t.await\n\t\t.unwrap()\n\t\t.user_message_id;\n\t\tassert_ne!(message_ids[i], 0);\n\t}\n\n\t// send empty message\n\tlet json = Json(SendMessageRequest {\n\t\tchat_session_id,\n\t\ttext: String::new(),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t400\n\t);\n\n\t// send message invalid chat session\n\tlet json = Json(SendMessageRequest {\n\t\tchat_session_id: 0,\n\t\ttext: String::from(\"Test msg invalid chat session id\"),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_send_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// get llm progress\n\tlet json = Json(ProgressRequest { chat_session_id });\n\tassert_eq!(\n\t\tcontrollers::chat::api_progress(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap()\n\t\t\t.0\n\t\t\t.progress,\n\t\tLlmProgress::Ready\n\t);\n\n\t// llm progress invalid chat session id\n\tlet json = Json(ProgressRequest {\n\t\tchat_session_id: -1,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_progress(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// get latest messages and make sure messages are in chronological order\n\tlet chat_session = controllers::chat::api_chats(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap();\n\tlet chat_session = chat_session.0.chat_sessions.first().unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tlatest_page\n\t\t\t.0\n\t\t\t.message_page\n\t\t\t.is_sorted_by(|a, b| a.timestamp \u003c b.timestamp)\n\t);\n\n\t// get specific messages and make sure messages are in chronological order\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: Some(latest_page.message_page[0].id),\n\t});\n\tlet next_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tnext_page\n\t\t\t.0\n\t\t\t.message_page\n\t\t\t.is_sorted_by(|a, b| a.timestamp \u003c b.timestamp)\n\t);\n\tassert_eq!(\n\t\tlatest_page.message_page[0].id,\n\t\tnext_page.message_page.last().unwrap().id\n\t);\n\n\t// get page with invalid message id\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: Some(0),\n\t});\n\tlet empty_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(empty_page.message_page.len(), 0);\n\tassert_eq!(empty_page.prev_message_id, None);\n\n\t// get page with invalid chat session id\n\n\t// update message with empty text\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: message_ids[0],\n\t\tnew_text: String::new(),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_update_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t400\n\t);\n\n\t// update message with invalid message id\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: 0,\n\t\tnew_text: String::from(\"Updated message\"),\n\t\titinerary_id: None,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_update_message(\n\t\t\tuser,\n\t\t\tExtension(pool.clone()),\n\t\t\tagent.clone(),\n\t\t\tchat_session_id_atomic_ext.clone(),\n\t\t\tcontext_store_ext.clone(),\n\t\t\tjson\n\t\t)\n\t\t.await\n\t\t.unwrap_err()\n\t\t.status_code()\n\t\t.as_u16(),\n\t\t404\n\t);\n\n\t// update message\n\tlet json = Json(UpdateMessageRequest {\n\t\tmessage_id: message_ids[0],\n\t\tnew_text: String::from(\"Updated message\"),\n\t\titinerary_id: None,\n\t});\n\t_ = controllers::chat::api_update_message(\n\t\tuser,\n\t\tExtension(pool.clone()),\n\t\tagent.clone(),\n\t\tchat_session_id_atomic_ext.clone(),\n\t\tcontext_store_ext.clone(),\n\t\tjson,\n\t)\n\t.await\n\t.unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(latest_page.prev_message_id, None);\n\tassert_eq!(latest_page.message_page.len(), 2);\n\n\t//rename chat empty string\n\tlet json = Json(RenameRequest {\n\t\tnew_title: String::from(\"\"),\n\t\tid: chat_session.id,\n\t});\n\tassert_eq!(\n\t\tcontrollers::chat::api_rename(user, Extension(pool.clone()), json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t400\n\t);\n\n\t//rename chat\n\tlet new_title = String::from(\"Updated Title\");\n\tlet json = Json(RenameRequest {\n\t\tnew_title: new_title.clone(),\n\t\tid: chat_session.id,\n\t});\n\tcontrollers::chat::api_rename(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tlet Json(chats) = controllers::chat::api_chats(user, Extension(pool.clone()))\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tchats\n\t\t\t.chat_sessions\n\t\t\t.iter()\n\t\t\t.any(move |chat| chat.id == chat_session.id \u0026\u0026 chat.title == new_title)\n\t);\n\n\t//delete chat session\n\tcontrollers::chat::api_delete_chat(\n\t\tuser,\n\t\tExtension(pool.clone()),\n\t\taxum::extract::Path(chat_session_id),\n\t)\n\t.await\n\t.unwrap();\n\tlet json = Json(MessagePageRequest {\n\t\tchat_session_id: chat_session.id,\n\t\tmessage_id: None,\n\t});\n\tlet latest_page = controllers::chat::api_message_page(user, Extension(pool.clone()), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(latest_page.prev_message_id, None);\n\tassert_eq!(latest_page.message_page.len(), 0);\n}\n\nasync fn test_user_event_flow(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_user_event_flow+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Saved\"),\n\t\tlast_name: String::from(\"Itineraries\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// create event\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\tlet test = String::from(\"test\");\n\tlet description = String::from(\"Unit test event\");\n\tlet json = Json(UserEventRequest {\n\t\tid: None,\n\t\tevent_name: test.clone(),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\tevent_description: Some(description.clone()),\n\t\thard_start: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2025-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t\tphoto_name: None,\n\t});\n\tlet Json(UserEventResponse { id }) =\n\t\tcontrollers::itinerary::api_user_event(user, pool.clone(), json)\n\t\t\t.await\n\t\t\t.unwrap();\n\n\t// update event\n\tlet update_str = String::from(\"test updated\");\n\tlet json = Json(UserEventRequest {\n\t\tid: Some(id),\n\t\tevent_name: update_str.clone(),\n\t\tevent_description: Some(description),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\thard_start: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2015-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2025-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t\tphoto_name: None,\n\t});\n\tlet Json(res) = controllers::itinerary::api_user_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(id, res.id);\n\n\t// search event\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\t..Default::default()\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(res.events.iter().any(|e| e.event_name == update_str));\n\n\t// comprehensive search\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\tstreet_address: Some(test.clone()),\n\t\tpostal_code: Some(1),\n\t\tcity: Some(test.clone()),\n\t\tcountry: Some(test.clone()),\n\t\tevent_type: Some(test.clone()),\n\t\tevent_description: Some(test.clone()),\n\t\tevent_name: Some(test.clone()),\n\t\thard_start_before: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2020-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_start_after: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2010-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end_before: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2030-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\thard_end_after: Some(\n\t\t\tNaiveDateTime::parse_from_str(\"2020-09-05 23:56:04\", \"%Y-%m-%d %H:%M:%S\").unwrap(),\n\t\t),\n\t\ttimezone: Some(String::from(\"UTC\")),\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(res.events.iter().any(|e| e.event_name == update_str));\n\n\t// delete event\n\tcontrollers::itinerary::api_delete_user_event(user, pool.clone(), axum::extract::Path(id))\n\t\t.await\n\t\t.unwrap();\n\n\t// verify deletion\n\tlet json = Json(SearchEventRequest {\n\t\tid: Some(id),\n\t\t..Default::default()\n\t});\n\tlet Json(res) = controllers::itinerary::api_search_event(user, pool, json)\n\t\t.await\n\t\t.unwrap();\n\tassert!(!res.events.iter().any(|e| e.event_name == update_str));\n}\n\n// INTEGRATION TESTS\n\nstatic mut PORT: u16 = 0;\n\n#[tokio::test]\n#[serial(db, log, panic_log)]\nasync fn test_endpoints() {\n\t// Only use dotenvy for local testing\n\t// CI testing should use GitHub environment variables\n\t_ = dotenvy::dotenv();\n\n\t// Initialize project logger once so test logs are written to logs/latest.log\n\t// Set a default log level for tests if not provided\n\tif std::env::var(\"RUST_LOG\").is_err() {\n\t\tunsafe { std::env::set_var(\"RUST_LOG\", \"debug\") };\n\t}\n\tlog::init_panic_handler();\n\tlog::init_logger();\n\n\tlet pool = db::create_pool().await;\n\tmatch migrate!().run(\u0026pool).await {\n\t\tOk(_) =\u003e (),\n\t\tErr(sqlx::migrate::MigrateError::VersionMismatch(_)) =\u003e {\n\t\t\teprintln!(\"migrations version mismatch; assuming DB already prepared. Skipping.\");\n\t\t}\n\t\tErr(e) =\u003e panic!(\"migrations run: {e}\"),\n\t}\n\n\t// Build app\n\t// Use an encryption/signing key for private cookies\n\tlet cookie_key = Key::generate();\n\n\t// Always use dummy agent for tests\n\tlet (agent_executor, chat_session_id_atomic, user_id_atomic, _context_store) =\n\t\tcreate_dummy_orchestrator_agent(pool.clone()).expect(\"Dummy agent creation failed\");\n\n\t// Wrap in Extension and Arc\u003cMutex\u003e for router layers\n\tlet agent_arc = std::sync::Arc::new(tokio::sync::Mutex::new(agent_executor));\n\n\tlet account_routes = controllers::account::account_routes();\n\tlet itinerary_routes = controllers::itinerary::itinerary_routes();\n\tlet chat_routes = controllers::chat::chat_routes();\n\tlet api_routes = Router::new()\n\t\t.nest(\"/account\", account_routes)\n\t\t.nest(\"/itinerary\", itinerary_routes)\n\t\t.nest(\"/chat\", chat_routes);\n\tlet app = Router::new()\n\t\t.nest(\"/api\", api_routes)\n\t\t.layer(Extension(pool.clone()))\n\t\t.layer(Extension(cookie_key.clone()))\n\t\t.layer(Extension(agent_arc.clone()))\n\t\t.layer(Extension(chat_session_id_atomic))\n\t\t.layer(CookieManagerLayer::new());\n\n\t// Bind to ephemeral port and spawn server\n\tlet listener = TcpListener::bind(\"127.0.0.1:0\")\n\t\t.await\n\t\t.expect(\"bind test server\");\n\tunsafe { PORT = listener.local_addr().unwrap().port() };\n\tlet server = axum::serve(listener, app.into_make_service()).into_future();\n\ttokio::spawn(server);\n\n\t// Any unit tests that test cookies or middleware, or any integration tests should go here.\n\t// Any other unit test should not go here. Instead, run it as a separate unit test and just invoke the controller directly.\n\ttokio::join!(\n\t\ttest_signup_and_login_happy_path(\u0026cookie_key),\n\t\ttest_auth_for_all_required(),\n\t\ttest_http_signup_and_login_flow(),\n\t\ttest_validate_with_bad_and_good_cookie(),\n\t\ttest_get_itinerary_invalid_format(),\n\t\ttest_signup_logout(),\n\t\ttest_cookie_exp_extended(),\n\t\t// just throw all the tests in here\n\t);\n}\n\nasync fn test_signup_and_login_happy_path(key: \u0026Key) {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"user+{}@example.com\", unique);\n\n\t// Signup\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Alice\",\n\t\t\t\t\"last_name\": \"Tester\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(resp.status().as_u16(), 200);\n\n\t// Login\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"user+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(resp.status().as_u16(), 200);\n\t// Extract cookie and decrypt via private jar\n\tlet set_cookie = resp.header(\"set-cookie\").unwrap();\n\t// Parse full Set-Cookie line (handles '=' inside value)\n\tlet parsed = Cookie::parse(set_cookie.to_string()).unwrap();\n\tlet mut jar = CookieJar::new();\n\tjar.add(parsed.clone());\n\tlet decrypted = jar.private(\u0026key).get(parsed.name()).unwrap();\n\t// token: user-\u003cid\u003e.\u003cexp\u003e.sign\n\tlet parts: Vec\u003c\u0026str\u003e = decrypted.value().split('.').collect();\n\tassert_eq!(parts.len(), 3);\n\tassert!(parts[0].starts_with(\"user-\"));\n\tassert_eq!(parts[2], \"sign\");\n\tlet exp: i64 = parts[1].parse().unwrap();\n\tlet now = chrono::Utc::now().timestamp();\n\tassert!(exp \u003e now);\n}\n\nasync fn test_auth_for_all_required() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\n\tlet account_update_payload = json!({});\n\tlet chat_message_page_payload = json!({\n\t\t\"chat_session_id\": 1,\n\t\t\"message_id\": 1\n\t});\n\tlet chat_update_message_payload = json!({\n\t\t\"message_id\": 1,\n\t\t\"new_text\": \"test\"\n\t});\n\tlet chat_send_message_payload = json!({\n\t\t\"chat_session_id\": 1,\n\t\t\"text\": \"test\"\n\t});\n\tlet chat_rename_payload = json!({\n\t\t\"new_title\": \"Updated Title\",\n\t\t\"id\": 1\n\t});\n\tlet chat_progress_payload = json!({\n\t\t\"chat_session_id\": 10\n\t});\n\tlet itinerary_save_payload = json!({\n\t\t\"id\": 1,\n\t\t\"start_date\": \"2025-11-05 00:00:00\",\n\t\t\"end_date\": \"2025-11-10 00:00:00\",\n\t\t\"morning_events\": [],\n\t\t\"noon_events\": [],\n\t\t\"afternoon_events\": [],\n\t\t\"evening_events\": []\n\t});\n\tlet itinerary_user_event_payload = json!({\n\t\t\"event_name\": \"Test Event\"\n\t});\n\tlet itinerary_search_event_payload = json!({\n\t\t\"event_description\": \"test\"\n\t});\n\n\tfor res in futures::future::join_all([\n\t\thc.do_get(\"/api/account/current\"),\n\t\thc.do_get(\"/api/account/validate\"),\n\t\thc.do_get(\"/api/account/logout\"),\n\t\thc.do_get(\"/api/chat/chats\"),\n\t\thc.do_get(\"/api/chat/newChat\"),\n\t\thc.do_get(\"/api/itinerary/saved\"),\n\t\thc.do_get(\"/api/itinerary/:id\"),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n\n\tfor res in futures::future::join_all([\n\t\thc.do_post(\"/api/account/update\", account_update_payload),\n\t\thc.do_post(\"/api/chat/messagePage\", chat_message_page_payload),\n\t\thc.do_post(\"/api/chat/updateMessage\", chat_update_message_payload),\n\t\thc.do_post(\"/api/chat/sendMessage\", chat_send_message_payload),\n\t\thc.do_post(\"/api/chat/rename\", chat_rename_payload),\n\t\thc.do_post(\"/api/chat/progress\", chat_progress_payload),\n\t\thc.do_post(\"/api/itinerary/save\", itinerary_save_payload),\n\t\thc.do_post(\"/api/itinerary/userEvent\", itinerary_user_event_payload),\n\t\thc.do_post(\"/api/itinerary/searchEvent\", itinerary_search_event_payload),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n\n\tfor res in futures::future::join_all([\n\t\thc.do_delete(\"/api/itinerary/userEvent/1\"),\n\t\thc.do_delete(\"/api/chat/1\"),\n\t])\n\t.await\n\t.iter()\n\t{\n\t\tassert_eq!(\n\t\t\tres.as_ref().unwrap().status().as_u16(),\n\t\t\t401,\n\t\t\t\"Protected route should require authentication\"\n\t\t);\n\t}\n}\n\nasync fn test_http_signup_and_login_flow() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"user+{}@example.com\", unique);\n\n\t// Signup\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Alice\",\n\t\t\t\t\"last_name\": \"Tester\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tresp.status().is_success(),\n\t\t\"signup failed: {}\",\n\t\tresp.status()\n\t);\n\n\t// Login\n\tlet resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"user+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert!(\n\t\tresp.status().is_success(),\n\t\t\"login failed: {}\",\n\t\tresp.status()\n\t);\n}\n\nasync fn test_validate_with_bad_and_good_cookie() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\t// No cookie (treated similarly to bad/invalid cookie): expect unauthorized\n\tlet resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tresp.status().as_u16(),\n\t\t401,\n\t\t\"Missing/invalid cookie should return 401\"\n\t);\n\n\t// Good cookie: create user and login to receive a valid private cookie, then validate\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"cookie+{}@example.com\", unique);\n\n\tlet signup = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Cook\",\n\t\t\t\t\"last_name\": \"Ie\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup.status().as_u16(), 200);\n\n\tlet login = hc\n\t\t.do_post(\n\t\t\t\"/api/account/login\",\n\t\t\tjson!({\n\t\t\t\t\"email\": format!(\"cookie+{}@example.com\", unique),\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(login.status().as_u16(), 200);\n\n\t// Client should now hold the private cookie; call validate and expect 200\n\tlet resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tresp.status().as_u16(),\n\t\t200,\n\t\t\"/validate with good cookie should return 200\"\n\t);\n}\n\nasync fn test_get_itinerary_invalid_format() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"get_itinerary+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Itinerary\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\t// Test with invalid ID format (should return 400)\n\tlet invalid_resp = hc.do_get(\"/api/itinerary/invalid\").await.unwrap();\n\tassert_eq!(invalid_resp.status().as_u16(), 400);\n}\n\nasync fn test_signup_logout() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"login_then_logout+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Event\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\tlet cookie = signup_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003e SystemTime::now());\n\n\t// Test profile picture update WHILE LOGGED IN\n\tlet update_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/update\",\n\t\t\tjson!({\n\t\t\t\t\"profile_picture\": \"https://example.com/pic.jpg\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(update_resp.status().as_u16(), 200);\n\n\tlet body = update_resp.json_body().unwrap();\n\tassert_eq!(body[\"profile_picture\"], \"https://example.com/pic.jpg\");\n\n\t// NOW logout\n\tlet logout_resp = hc.do_get(\"/api/account/logout\").await.unwrap();\n\tassert_eq!(logout_resp.status().as_u16(), 200);\n\n\tlet cookie = logout_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003c SystemTime::now());\n\n\t// Hit any protected route - should be 401 now\n\tlet validate_res = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(\n\t\tvalidate_res.status().as_u16(),\n\t\t401,\n\t\t\"Missing/invalid cookie should return 401\"\n\t);\n}\n\nasync fn test_cookie_exp_extended() {\n\tlet hc = httpc_test::new_client(format!(\"http://localhost:{}\", unsafe { PORT })).unwrap();\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_cookie_exp_extended+{}@example.com\", unique);\n\n\t// Signup user\n\tlet signup_resp = hc\n\t\t.do_post(\n\t\t\t\"/api/account/signup\",\n\t\t\tjson!({\n\t\t\t\t\"email\": email,\n\t\t\t\t\"first_name\": \"Get\",\n\t\t\t\t\"last_name\": \"Event\",\n\t\t\t\t\"password\": \"Password123\"\n\t\t\t}),\n\t\t)\n\t\t.await\n\t\t.unwrap();\n\tassert_eq!(signup_resp.status().as_u16(), 200);\n\n\tlet cookie = signup_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(cookie.expires.unwrap() \u003e SystemTime::now());\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003c SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(TEST_COOKIE_EXP_SECONDS as u64))\n\t\t\t\t.unwrap()\n\t);\n\n\t// Hit any protected route\n\tlet validate_resp = hc.do_get(\"/api/account/validate\").await.unwrap();\n\tassert_eq!(validate_resp.status().as_u16(), 200);\n\n\tlet cookie = validate_resp.res_cookie(\"auth-token\").unwrap();\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003e SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(TEST_COOKIE_EXP_SECONDS as u64))\n\t\t\t\t.unwrap()\n\t);\n\tassert!(\n\t\tcookie.expires.unwrap()\n\t\t\t\u003c SystemTime::now()\n\t\t\t\t.checked_add(Duration::from_secs(3600))\n\t\t\t\t.unwrap()\n\t);\n}\n\nasync fn test_unsave_itinerary_success(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_success+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"Success\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// First, save an itinerary\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Test Itinerary to Unsave\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\tassert_ne!(itinerary_id, 0);\n\n\t// Now unsave it\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Verify it's no longer in saved itineraries\n\tlet saved = controllers::itinerary::api_saved_itineraries(user, pool)\n\t\t.await\n\t\t.unwrap();\n\tassert!(!saved.itineraries.iter().any(|i| i.id == itinerary_id));\n}\n\nasync fn test_unsave_itinerary_not_found(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_not_found+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"NotFound\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// Try to unsave a non-existent itinerary\n\tlet json = Json(UnsaveRequest { id: 999999 });\n\tassert_eq!(\n\t\tcontrollers::itinerary::api_unsave(user, pool, json)\n\t\t\t.await\n\t\t\t.unwrap_err()\n\t\t\t.status_code()\n\t\t\t.as_u16(),\n\t\t404\n\t);\n}\n\nasync fn test_unsave_already_unsaved_itinerary(\n\tmut cookies: CookieJar,\n\tkey: Extension\u003cKey\u003e,\n\tpool: Extension\u003cPgPool\u003e,\n) {\n\tlet unique = Utc::now().timestamp_nanos_opt().unwrap();\n\tlet email = format!(\"test_unsave_already_unsaved+{}@example.com\", unique);\n\tlet json = Json(SignupRequest {\n\t\temail,\n\t\tfirst_name: String::from(\"Unsave\"),\n\t\tlast_name: String::from(\"Already\"),\n\t\tpassword: String::from(\"Password123\"),\n\t});\n\t// Signup user\n\tcontrollers::account::api_signup(\u0026mut cookies, key.clone(), pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\tlet cookie = cookies.get(\"auth-token\").unwrap();\n\tlet parts: Vec\u003c\u0026str\u003e = cookie.value().split(\u0026['-', '.']).collect();\n\tlet user = Extension(AuthUser {\n\t\tid: parts[1].parse().unwrap(),\n\t});\n\n\t// Save an itinerary\n\tlet json = Json(Itinerary {\n\t\tid: 0,\n\t\tstart_date: NaiveDate::parse_from_str(\"2025-01-01\", \"%Y-%m-%d\").unwrap(),\n\t\tend_date: NaiveDate::parse_from_str(\"2025-12-31\", \"%Y-%m-%d\").unwrap(),\n\t\tevent_days: vec![],\n\t\tunassigned_events: vec![],\n\t\tchat_session_id: None,\n\t\ttitle: String::from(\"Test Itinerary\"),\n\t});\n\tlet itinerary_id = controllers::itinerary::api_save(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap()\n\t\t.id;\n\n\t// Unsave it once\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool.clone(), json)\n\t\t.await\n\t\t.unwrap();\n\n\t// Try to unsave it again\n\tlet json = Json(UnsaveRequest { id: itinerary_id });\n\tcontrollers::itinerary::api_unsave(user, pool, json)\n\t\t.await\n\t\t.unwrap();\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>